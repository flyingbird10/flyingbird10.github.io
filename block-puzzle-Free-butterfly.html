<!DOCTYPE html>
<html lang="gu">

<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-SHQ1VR77Q3"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-SHQ1VR77Q3');
  </script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Block Puzzle Free Butterfly</title>
  <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAARElEQVRYR+3OsQ0AIAwDQPz/04YJYgQq5+Z4tgCJ7ADV3gEi0gEi0gEi0gEi0gEi0gEi0gEi0gEi0gEi0gEi0gEi0gH6+gL1VgL1VgL1VgAAAABJRU5ErkJggg==" sizes="32x32" />
  <!-- Open Graph Meta Tags -->
  <meta property="og:title" content="Block Puzzle Free Butterfly - Play Online">
  <meta property="og:description"
    content="Play addictive Block Puzzle Free Butterfly online. Relaxing and fun brain puzzle game.">
  <meta property="og:image" content="https://flyingbirdapp.in/game-preview.png">
  <meta property="og:url" content="https://flyingbirdapp.in/block-puzzle-Free-butterfly.html">
  <meta property="og:type" content="website">
  <meta property="og:site_name" content="Flying Bird App">

  <!-- JSON-LD Structured Data (Schema.org) -->
  <!-- SoftwareApplication: Google Rich Results supported type -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "SoftwareApplication",
    "name": "Block Puzzle Free Butterfly",
    "url": "https://flyingbirdapp.in/block-puzzle-Free-butterfly.html",
    "image": "https://flyingbirdapp.in/game-preview.png",
    "description": "Block Puzzle Free Butterfly is an addictive and relaxing brain puzzle game. Drag and drop blocks to complete rows and columns. Play online for free in your browser.",
    "applicationCategory": "GameApplication",
    "applicationSubCategory": "PuzzleGame",
    "operatingSystem": "Web Browser, Android",
    "offers": {
      "@type": "Offer",
      "price": "0",
      "priceCurrency": "USD"
    },
    "aggregateRating": {
      "@type": "AggregateRating",
      "ratingValue": "4.8",
      "ratingCount": "1024",
      "bestRating": "5",
      "worstRating": "1"
    },
    "publisher": {
      "@type": "Organization",
      "name": "Flying Bird App",
      "url": "https://flyingbirdapp.in"
    },
    "author": {
      "@type": "Organization",
      "name": "Flying Bird App"
    }
  }
  </script>

  <!-- FAQPage Schema: Guaranteed to show in Google Rich Results -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "FAQPage",
    "mainEntity": [
      {
        "@type": "Question",
        "name": "How do you play Block Puzzle Free Butterfly?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "Drag and drop butterfly-shaped blocks onto the 10x10 board. Complete full rows or columns to clear them and earn points. The game ends when no more blocks can be placed on the board."
        }
      },
      {
        "@type": "Question",
        "name": "Is Block Puzzle Free Butterfly free to play?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "Yes! Block Puzzle Free Butterfly is completely free to play online in your browser. No download or installation required."
        }
      },
      {
        "@type": "Question",
        "name": "Is there a time limit in Block Puzzle Free Butterfly?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "The Classic mode has no time limit, so you can play at your own pace. There is also a Timed mode where you race against the clock for extra challenge."
        }
      },
      {
        "@type": "Question",
        "name": "Can I play Block Puzzle Free Butterfly on mobile?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "Yes! You can play Block Puzzle Free Butterfly directly in your mobile browser, or download the Android app from the Google Play Store."
        }
      }
    ]
  }
  </script>

  <!-- ===================================================================== -->
  <!-- FIREBASE CONFIGURATION AND INITIALIZATION                             -->
  <!-- Firebase v12.4.0 Modular SDK માટે configuration                      -->
  <!-- Authentication, Firestore Database, Analytics setup                   -->
  <!-- ===================================================================== -->
  <!-- Firebase v9 Modular SDK -->
  <script type="module">
    // Firebase client config (client API key is meant to be in frontend; secure it via
    // Google Cloud Console: Credentials → API key → Application restriction = HTTP referrers
    // with your domain only, and API restriction = only needed Firebase APIs)
    const firebaseConfig = {
      apiKey: "AIzaSyBSXV5Umhdb12WV-IiKUXwfY7qqogXCB0w",
      authDomain: "block-puzzle-free-butterfly.firebaseapp.com",
      projectId: "block-puzzle-free-butterfly",
      storageBucket: "block-puzzle-free-butterfly.appspot.com",
      messagingSenderId: "927055700205",
      appId: "1:927055700205:web:e98778e8ba669991d52ce4",
      measurementId: "G-NKVQHXHDYX"
    };

    // Firebase imports - Using latest v12.4.0
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/12.4.0/firebase-app.js';
    import { getAnalytics } from 'https://www.gstatic.com/firebasejs/12.4.0/firebase-analytics.js';
    import {
      getAuth,
      signInAnonymously,
      onAuthStateChanged,
      signInWithEmailAndPassword,
      createUserWithEmailAndPassword,
      signOut,
      linkWithCredential,
      EmailAuthProvider,
      updateProfile,
      sendPasswordResetEmail,
      setPersistence,
      browserLocalPersistence,
      reauthenticateWithCredential
    } from 'https://www.gstatic.com/firebasejs/12.4.0/firebase-auth.js';
    import {
      getFirestore,
      doc,
      setDoc,
      getDoc,
      updateDoc,
      deleteDoc,
      serverTimestamp,
      collection,
      addDoc,
      query,
      orderBy,
      where,
      limit,
      getDocs
    } from 'https://www.gstatic.com/firebasejs/12.4.0/firebase-firestore.js';

    // Check if running on proper protocol
    const isLocalFile = location.protocol === 'file:';
    if (isLocalFile) {
      console.warn('⚠️ Running on file:// protocol. Firebase features may not work properly. Please use a local server (http:// or https://) for full functionality.');
    }

    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const analytics = getAnalytics(app);
    const auth = getAuth(app);
    setPersistence(auth, browserLocalPersistence).catch((error) => {
      console.error('Failed to enforce persistent auth state:', error);
    });
    const db = getFirestore(app);

    // Make Firebase available globally
    window.firebaseApp = app;
    window.firebaseAuth = auth;
    window.firebaseDB = db;
    window.firebaseAnalytics = analytics;
    window.firebaseModules = {
      auth: { signInAnonymously, onAuthStateChanged, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, linkWithCredential, EmailAuthProvider, updateProfile, sendPasswordResetEmail, reauthenticateWithCredential },
      firestore: { doc, setDoc, getDoc, updateDoc, deleteDoc, serverTimestamp, collection, addDoc, query, orderBy, where, limit, getDocs }
    };

    console.log("Firebase v12.4.0 initialized successfully!");
  </script>

  <!-- ===================================================================== -->
  <!-- CSS STYLES SECTION                                                    -->
  <!-- બધા UI components, animations, અને responsive design માટે styles    -->
  <!-- ===================================================================== -->
  <style>
    /* ================================================================= */
    /* CSS VARIABLES - Layout and sizing configuration                  */
    /* Board size, cell size, spacing, padding વગેરે માટે variables     */
    /* ================================================================= */
    /* layout variables (replace previous :root block) */
    :root {
      --board-width: 400px;
      /* max board width */
      --frame-padding: 6px;
      /* frame inner padding (px) */
      --frame-border: 6px;
      /* visual border thickness (px) */
      --grid-gap: 2px;
      /* gap between cells */
      /* inner available size for 10x10 grid: board minus frame paddings and borders */
      --inner-size: calc(var(--board-width) - (2 * var(--frame-padding)) - (2 * var(--frame-border)));
      /* cell size computed so 10 cells + 9 gaps exactly fill inner-size */
      --cell-size: calc((var(--inner-size) - (9 * var(--grid-gap))) / 10);
      --piece-block-size: calc(var(--cell-size) * 0.4);
      --ui-gap: 8px;
      --btn-padding: 8px 30px;
      --font-size-base: 16px;
    }

    html,
    body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      position: fixed;
      font-family: sans-serif;
      background: #591970;
      touch-action: pan-x pan-y;
      /* Prevent text selection during drag */
      -webkit-user-select: none;
      user-select: none;
      /* Prevent pull-to-refresh and overscroll */
      -webkit-overscroll-behavior: none;
      overscroll-behavior: none;
    }

    /* ================================================================= */
    /* HOME SCREEN STYLING - Animated gradient background               */
    /* Main menu screen with multicolor animated gradient               */
    /* ================================================================= */
    /* Home screen multicolor animated background */
    #homeScreen {
      position: fixed;
      inset: 0;
      display: flex !important;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
      overflow-y: auto;
      overflow-x: hidden;
      /* Allow vertical scrolling if content exceeds height */
      /* smooth multi-color gradient (animated) */
      background: linear-gradient(120deg, #ff7ab6, #7a6bff, #4ade80, #ffd166);
      background-size: 300% 300%;
      animation: gradientShift 12s ease infinite;
      /* Ensure home screen maintains layout when modals are shown */
      pointer-events: auto;
      /* Initial state for smooth transitions */
      opacity: 1;
      visibility: visible;
      box-sizing: border-box;
      padding-bottom: 24px;
      padding-top: 50px;
      gap: 8px;
      /* Reduce gap between elements */
      min-height: 100vh;
      height: auto;
      /* Allow flexible height */
    }

    /* ================================================================= */
    /* GRADIENT ANIMATION KEYFRAMES                                      */
    /* Background gradient animation માટે keyframe definitions          */
    /* ================================================================= */
    @keyframes gradientShift {
      0% {
        background-position: 0% 50%;
      }

      50% {
        background-position: 100% 50%;
      }

      100% {
        background-position: 0% 50%;
      }
    }

    /* Header gradient animation keyframes */
    /* Header gradient animation */
    @keyframes gradientShiftHeader {
      0% {
        background-position: 0% 50%;
      }

      50% {
        background-position: 100% 50%;
      }

      100% {
        background-position: 0% 50%;
      }
    }

    /* ================================================================= */
    /* HOME SCREEN OVERLAY AND Z-INDEX STACKING                          */
    /* Dark overlay for text readability and proper element layering    */
    /* ================================================================= */
    /* subtle dark overlay so text remains readable */
    #homeScreen::before {
      content: "";
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.25);
      pointer-events: none;
      z-index: 0;
    }

    /* keep UI above the background */
    #homeScreen>* {
      position: relative;
      z-index: 1;
    }

    /* keep UI stacking simple (no decorative SVG background) */
    #homeScreen,
    /* Ensure proper z-index stacking */
    #homeScreen {
      z-index: 1;
    }

    #homeScreen,
    .gameContainer {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .gameContainer {
      z-index: 3;
    }

    /* Ensure hidden screens are completely invisible to prevent flashing */
    #homeScreen[style*="display: none"] {
      opacity: 0 !important;
      visibility: hidden !important;
      pointer-events: none !important;
    }

    .gameContainer[style*="display: none"] {
      opacity: 0 !important;
      visibility: hidden !important;
      pointer-events: none !important;
    }

    /* Ensure game container background is hidden when opacity is 0 */
    .gameContainer[style*="opacity: 0"],
    .gameContainer[style*="opacity:0"] {
      background: transparent !important;
    }

    /* ================================================================= */
    /* GAME CONTAINER - Classic અને Timed game screens                  */
    /* Game play દરમિયાન નો background અને layout                       */
    /* Home screen જેવું જ animated gradient background                */
    /* ================================================================= */
    .gameContainer {
      display: none;
      overflow-y: hidden;
      overflow-x: hidden;
      /* same multicolor animated background as home */
      background: linear-gradient(120deg, #ff7ab6, #7a6bff, #4ade80, #ffd166);
      background-size: 300% 300%;
      animation: gradientShift 12s ease infinite;
      color: white;
      position: fixed;
      inset: 0;
      justify-content: flex-start;
      align-items: center;
      flex-direction: column;
      /* Prevent layout shift when dragging blocks */
      min-height: 100vh;
      height: 100vh;
      max-height: 100vh;
      flex-shrink: 0;
      box-sizing: border-box;
      /* Add padding for header and ad space - will be adjusted in media queries */
      padding-top: 50px;
      padding-bottom: 80px;
      /* Initial state for smooth transitions - ensure completely hidden */
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }

    /* Ensure game container is visible when shown */
    .gameContainer[style*="display: flex"] {
      pointer-events: auto;
    }

    /* Game container dark overlay for readability */
    .gameContainer::before {
      content: "";
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.25);
      pointer-events: none;
      z-index: 0;
    }

    /* ensure game UI sits above the animated background */
    .gameContainer>* {
      position: relative;
      z-index: 1;
    }

    /* ================================================================= */
    /* DELETE ACCOUNT BUTTON & MODAL STYLING                             */
    /* ================================================================= */

    /* Delete Account Button (Top-left corner) */
    .delete-account-btn {
      top: -30px;
      left: -110px;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: rgba(239, 68, 68, 0.2);
      border: 1px solid rgba(239, 68, 68, 0.4);
      color: #fca5a5;
      font-size: 1.2rem;
      cursor: pointer;
      transition: all 0.3s ease;
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
    }

    .delete-account-btn:hover {
      background: rgba(239, 68, 68, 0.4);
      border-color: rgba(239, 68, 68, 0.7);
      transform: scale(1.12);
    }

    /* Delete Confirmation Modal */
    .delete-confirm-modal {
      max-width: 500px;
    }

    .delete-warning {
      color: rgba(226, 232, 240, 0.9);
      line-height: 1.6;
      margin: 12px 0;
    }

    .delete-warning-final {
      color: #fca5a5;
      font-size: 1rem;
      margin: 16px 0;
      padding: 12px;
      background: rgba(239, 68, 68, 0.1);
      border-radius: 8px;
      border: 1px solid rgba(239, 68, 68, 0.3);
    }

    .delete-list {
      list-style: none;
      padding: 0;
      margin: 16px 0;
    }

    .delete-list li {
      padding: 8px 12px;
      margin: 6px 0;
      background: rgba(15, 23, 42, 0.6);
      border-radius: 6px;
      border-left: 3px solid rgba(248, 113, 113, 0.5);
      color: rgba(226, 232, 240, 0.9);
    }

    .delete-list li:before {
      content: "✗ ";
      color: #f87171;
      font-weight: bold;
      margin-right: 8px;
    }

    .welcome-actions button.delete-btn {
      background: linear-gradient(135deg, #ef4444, #dc2626);
      color: #fff;
      box-shadow: 0 10px 30px rgba(239, 68, 68, 0.35);
    }

    .welcome-actions button.delete-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 14px 34px rgba(239, 68, 68, 0.5);
      background: linear-gradient(135deg, #dc2626, #b91c1c);
    }

    /* ================================================================= */
    /* USER STATS CARD STYLING                                           */
    /* Home screen પર user statistics display માટે card                */
    /* Games played, high scores, play time, achievements દર્શાવે છે   */
    /* Animated gradient background with compact square design          */
    /* ================================================================= */
    /* User Stats Card Styling */
    .user-stats-card {
      background: linear-gradient(120deg, #d457f0, #4f70f5, #24a5eb, #f4a141);
      background-size: 300% 300%;
      animation: gradientShift 8s ease infinite;
      border: 3px solid rgba(255, 255, 255, 0.4);
      border-radius: 20px;
      padding: 11px;
      margin: 5px auto;
      /* Reduced from 15px to 5px */
      max-height: 250px;
      min-height: 200px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      /* Allow user to resize and scroll content if needed */
      resize: none;
      overflow: auto;
      min-width: 200px;
    }

    .user-stats-hidden {
      display: none;
    }

    .user-stats-card.hidden {
      display: none;
    }

    /* ----------------------------------------------------------------- */
    /* Stats Header - User name અને sync status icon                    */
    /* ----------------------------------------------------------------- */
    .stats-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      border-bottom: 2px solid rgba(255, 255, 255, 0.3);
      padding-bottom: 6px;
    }

    #syncStatusIcon {
      font-size: 14px;
    }

    .account-actions {
      display: flex;
      flex-direction: row;
      gap: 8px;
      margin-top: 12px;
      justify-content: center;
      align-items: center;
    }

    .account-actions button {
      padding: 8px 16px;
      border-radius: 10px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      background: linear-gradient(135deg, rgba(28, 4, 186, 0.984), rgb(234, 14, 190));
      color: #fff;
      transition: all 0.2s ease;
      border: 1px solid rgba(255, 255, 255, 0.2);
      min-width: 100px;
    }

    .account-actions button:hover {
      background: linear-gradient(135deg, rgba(166, 2, 141), rgba(228, 162, 8, 0.85));
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .auth-modal {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.65);
      -webkit-backdrop-filter: blur(6px);
      backdrop-filter: blur(6px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 20000;
      padding: 20px;
      /* Allow modal to scroll if content exceeds viewport (helps selects near bottom) */
      overflow-y: auto;
      overscroll-behavior: contain;
      /* Ensure modal doesn't affect home screen layout */
      pointer-events: auto;
    }

    .auth-modal.active {
      display: flex;
      pointer-events: auto;
    }

    /* Ensure modal content is interactive */
    .auth-modal.active .auth-modal-content {
      pointer-events: auto;
    }

    /* Info Page Styles (How to Play & Privacy Policy) */
    .info-page {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.95);
      -webkit-backdrop-filter: blur(6px);
      backdrop-filter: blur(6px);
      display: none;
      flex-direction: column;
      z-index: 20001;
      overflow-y: auto;
      box-sizing: border-box;
      padding-top: 10px;
    }

    .info-page:not(.user-stats-hidden) {
      display: flex;
    }

    .info-page-header {
      position: sticky;
      top: 0;
      background: linear-gradient(135deg, rgba(127, 75, 247, 0.95), rgba(46, 147, 240, 0.95));
      padding: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    }

    .back-button {
      background: rgba(255, 255, 255, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: white;
      padding: 10px 20px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 16px;
      font-weight: 600;
      transition: all 0.3s ease;
    }

    .back-button:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: translateX(-3px);
    }

    .info-page-header h2 {
      color: white;
      font-size: 24px;
      margin: 0;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }

    .info-page-content {
      flex: 1;
      padding: 20px;
      max-width: 100%;
      width: 100%;
      margin: 0 auto;
      color: #e5e7eb;
      box-sizing: border-box;
      overflow-x: hidden;
      overflow-y: auto;
      /* Allow scrolling */
    }


    .info-page-content iframe {
      width: 100%;
      height: 100%;
      min-height: 600px;
      border: none;
      background: white;
      border-radius: 10px;
      box-sizing: border-box;
    }

    @media (max-width: 768px) {
      .info-page-content {
        padding: 30px;
      }
    }

    .auth-modal-content {
      position: relative;
      margin: auto;
      /* 3D Gradient Background */
      background: linear-gradient(135deg,
          rgba(127, 75, 247, 0.95) 0%,
          rgba(46, 147, 240, 0.95) 25%,
          rgba(157, 51, 244, 0.95) 50%,
          rgba(237, 11, 245, 0.95) 75%,
          rgba(247, 61, 117, 0.95) 100%);
      background-size: 400% 400%;
      animation: gradientShift 15s ease infinite;
      border-radius: 20px;
      padding: 24px;
      width: min(420px, 90vw);
      max-width: 420px;
      max-height: 92vh;
      /* more headroom so dropdowns are not clipped */
      overflow-y: auto;
      overscroll-behavior: contain;
      box-shadow:
        0 25px 70px rgba(0, 0, 0, 0.5),
        0 10px 30px rgba(139, 92, 246, 0.3),
        inset 0 1px 1px rgba(255, 255, 255, 0.2);
      border: 4px solid rgba(255, 255, 255, 0.568);
      position: relative;
      color: #0eeed0;
      margin: auto;
    }

    /* Mobile responsive for auth modals */
    /* Mobile-specific height reduction for home page */
    @media (max-width: 768px) and (max-height: 900px) {

      /* Reduce home screen title height */
      #homeScreen h1 {
        padding: 6px 8px;
        font-size: clamp(1.4rem, 7vw, 1.6rem);
        line-height: 1.3;
        letter-spacing: 2px;
        margin: 3px 0;
        /* Reduced from 8px */
      }

      /* Reduce user stats card margin */
      .user-stats-card {
        margin: 3px auto;
        /* Reduced from default */
      }

      /* Reduce home actions container spacing */
      #homeScreen .home-actions {
        gap: 8px;
        /* Reduced to prevent overlap */
        margin: 3px;
        margin-top: 3px;
        /* Reduced top margin */
        margin-bottom: 10px;
        /* Bottom margin for ad */
      }

      /* Reduce button heights */
      #homeScreen .home-actions button {
        min-height: 55px;
        padding: 6px 8px;
        gap: 2px;
      }

      /* Reduce button text sizes */
      #homeScreen .home-actions button .action-title {
        font-size: 0.8rem;
      }

      #homeScreen .home-actions button .action-subtitle {
        font-size: 0.55rem;
      }

      /* Reduce overall home screen spacing */
      #homeScreen {
        padding: 5px;
        padding-top: 5px;
        /* Reduced top padding */
        padding-bottom: 80px;
        /* Increased for ad visibility */
        gap: 5px;
        /* Reduced gap between elements */
        justify-content: flex-start;
        /* Start from top */
        overflow-y: auto;
        overflow-x: hidden;
        height: 100vh;
        max-height: 100vh;
        /* Ensure mobile scrolling works properly */
      }
    }

    @media (max-width: 480px) {
      .auth-modal-content {
        width: 95vw;
        max-width: 95vw;
        padding: 20px 16px;
        border-radius: 15px;
        max-height: 90vh;
      }

      .auth-modal {
        padding: 10px;
      }
    }

    /* Country picker custom UI */
    .country-picker-trigger {
      margin-top: 8px;
      padding: 10px;
      border-radius: 8px;
      border: 1px solid rgba(226, 232, 240, 0.2);
      background: rgba(15, 23, 42, 0.6);
      color: #fff;
      font-size: 1rem;
      cursor: pointer;
      -webkit-user-select: none;
      user-select: none;
    }

    .country-picker-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      width: 100%;
      height: 100%;
      background: rgba(15, 23, 42, 0.85);
      /* Removed backdrop-filter to prevent flashing - using solid background instead */
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 30000;
      padding: 16px;
      /* Optimize rendering to prevent flashing - especially for Android 12 and below */
      -webkit-transform: translateZ(0);
      transform: translateZ(0);
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
      /* Disable transitions on older Android to prevent flashing */
      transition: none;
      /* Force hardware acceleration */
      -webkit-perspective: 1000;
      perspective: 1000;
    }

    .country-picker-overlay.user-stats-hidden {
      display: none !important;
      visibility: hidden;
      opacity: 0;
      pointer-events: none;
      -webkit-transform: translateZ(0);
      transform: translateZ(0);
    }

    .country-picker-panel {
      background: linear-gradient(135deg,
          rgba(127, 75, 247, 0.95) 0%,
          rgba(46, 147, 240, 0.95) 25%,
          rgba(157, 51, 244, 0.95) 50%,
          rgba(237, 11, 245, 0.95) 75%,
          rgba(247, 61, 117, 0.95) 100%);
      background-size: 400% 400%;
      animation: gradientShift 15s ease infinite;
      border-radius: 16px;
      border: 2px solid rgba(255, 255, 255, 0.2);
      width: min(420px, 92vw);
      max-width: 420px;
      max-height: 80vh;
      padding: 12px;
      box-shadow: 0 25px 70px rgba(0, 0, 0, 0.5);
      color: #fff;
      display: flex;
      flex-direction: column;
      gap: 10px;
      /* Optimize rendering to prevent flashing - especially for Android 12 and below */
      -webkit-transform: translateZ(0);
      transform: translateZ(0);
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
      /* Force hardware acceleration */
      -webkit-perspective: 1000;
      perspective: 1000;
      /* Disable transitions on older Android */
      transition: none;
      /* Prevent layout shifts */
      position: relative;
      overflow: hidden;
    }

    /* Disable gradient animation on old Android to prevent flashing */
    .country-picker-panel.old-android {
      -webkit-animation: none !important;
      animation: none !important;
      background: linear-gradient(135deg,
          rgba(127, 75, 247, 0.95) 0%,
          rgba(46, 147, 240, 0.95) 50%,
          rgba(247, 61, 117, 0.95) 100%);
      background-size: 100% 100%;
    }

    .picker-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .picker-close {
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: #fff;
      border-radius: 8px;
      padding: 6px 10px;
      cursor: pointer;
    }

    .picker-search {
      padding: 10px;
      border-radius: 8px;
      border: 1px solid rgba(226, 232, 240, 0.2);
      background: rgba(15, 23, 42, 0.6);
      color: #fff;
      font-size: 1rem;
      width: 100%;
    }

    .country-list {
      overflow-y: auto;
      flex: 1 1 auto;
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 8px;
      padding: 6px;
      background: rgba(15, 23, 42, 0.35);
      /* Optimize scrolling to prevent flashing - especially for Android 12 and below */
      -webkit-transform: translateZ(0);
      transform: translateZ(0);
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
      /* Force hardware acceleration */
      -webkit-perspective: 1000;
      perspective: 1000;
      /* Prevent layout shifts */
      position: relative;
    }

    .country-item {
      padding: 8px 10px;
      border-radius: 8px;
      cursor: pointer;
      color: #fff;
      display: flex;
      align-items: center;
      gap: 10px;
      /* Optimize rendering to prevent flashing - especially for Android 12 and below */
      -webkit-transform: translateZ(0);
      transform: translateZ(0);
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
      /* Disable transitions on older Android to prevent flashing */
      transition: none;
      /* Force hardware acceleration */
      position: relative;
      -webkit-tap-highlight-color: transparent;
    }

    .country-item:hover,
    .country-item.active {
      background: rgba(255, 255, 255, 0.15);
    }

    /* Let the guest profile modal allow dropdown popover to escape content box */
    #guestProfileModal .auth-modal-content {
      overflow: visible;
      /* so native select popover isn't clipped by content box */
      max-height: 92vh;
    }

    /* Ensure the guest profile form area itself scrolls smoothly when needed */
    #guestProfileModal .auth-modal-content form {
      overflow: auto;
    }

    @keyframes gradientShift {
      0% {
        background-position: 0% 50%;
      }

      50% {
        background-position: 100% 50%;
      }

      100% {
        background-position: 0% 50%;
      }
    }

    .auth-modal-content h3 {
      margin: 0 0 12px;
      font-size: 1.4rem;
      text-align: center;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }

    .auth-modal-content p {
      margin: 0 0 16px;
      text-align: center;
      color: rgba(255, 255, 255, 0.95);
      font-size: 0.95rem;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
    }

    .auth-close-btn {
      position: absolute;
      top: 12px;
      right: 12px;
      background: rgba(0, 0, 0, 0.3);
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      width: 32px;
      height: 32px;
      font-size: 1.2rem;
      color: rgba(255, 255, 255, 0.9);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    }

    .auth-close-btn:hover {
      background: rgba(68, 233, 239, 0.8);
      transform: rotate(90deg);
    }

    /* Modal Compact Style for Leaderboard & Achievements */
    .modal-compact {
      max-width: 330px !important;
      width: min(330px, 75vw) !important;
      max-height: 750px;
      height: min(750px, 85vh);
      overflow-y: auto;
      padding-bottom: 70px;
      /* Space for floating button */
      position: relative;
    }

    .modal-filter-row {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }

    .filter-btn {
      padding: 8px 16px;
      border-radius: 10px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      background: rgba(255, 255, 255, 0.1);
      color: white;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
    }

    .filter-btn:hover {
      background: rgba(255, 255, 255, 0.25);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .country-select {
      padding: 8px 12px;
      border-radius: 10px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      background: rgba(255, 255, 255, 0.15);
      color: white;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s ease;
      outline: none;
    }

    .country-select option {
      background: rgba(30, 41, 59, 0.95);
      color: white;
      padding: 8px;
    }

    .country-select:hover,
    .country-select:focus {
      background: rgba(255, 255, 255, 0.25);
      border-color: rgba(255, 255, 255, 0.5);
    }

    .modal-button {
      position: sticky;
      bottom: 0;
      left: 0;
      right: 0;
      margin: 0;
      padding: 14px 24px;
      border-radius: 0 0 20px 20px;
      border: none;
      border-top: 2px solid rgba(255, 255, 255, 0.3);
      background: linear-gradient(135deg, rgba(204, 72, 240, 0.98), rgba(59, 246, 212, 0.98));
      color: white;
      font-size: 16px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s ease;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.4);
      width: calc(100% + 48px);
      margin-left: -24px;
      margin-right: -24px;
      z-index: 10;
      box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.3);
    }

    .modal-button:hover {
      background: linear-gradient(135deg, rgba(68, 219, 239, 0.98), rgba(245, 158, 11, 0.98));
      transform: scale(1.02);
      box-shadow: 0 -6px 16px rgba(0, 0, 0, 0.5);
    }

    .auth-modal-content form {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .auth-modal-content label {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 0.9rem;
      color: rgba(226, 232, 240, 0.9);
    }

    .auth-modal-content input[type="email"],
    .auth-modal-content input[type="password"],
    .auth-modal-content input[type="text"] {
      padding: 10px;
      border-radius: 8px;
      border: 1px solid rgba(226, 232, 240, 0.2);
      background: rgba(15, 23, 42, 0.6);
      color: #fff;
      font-size: 1rem;
    }

    .auth-modal-content select {
      padding: 10px;
      border-radius: 8px;
      border: 1px solid rgba(226, 232, 240, 0.2);
      background: rgba(15, 23, 42, 0.6);
      color: #fff;
      font-size: 1rem;
      cursor: pointer;
    }

    .auth-modal-content select:focus {
      outline: none;
      border-color: rgba(59, 130, 246, 0.5);
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }

    .auth-form-group {
      margin-bottom: 16px;
    }

    .auth-form-group label {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 0.9rem;
      color: rgba(226, 232, 240, 0.9);
    }

    .auth-modal-content button[type="submit"] {
      margin-top: 8px;
      padding: 10px 14px;
      border-radius: 10px;
      border: none;
      font-weight: 600;
      cursor: pointer;
      background: linear-gradient(120deg, #7dd3fc, #38bdf8);
      color: #0f172a;
    }

    .auth-switch {
      margin-top: 12px;
      text-align: center;
    }

    .auth-switch button {
      background: transparent;
      border: none;
      color: #38bdf8;
      cursor: pointer;
      font-size: 0.9rem;
      text-decoration: underline;
    }

    .auth-error {
      background: rgba(248, 113, 113, 0.18);
      border: 1px solid rgba(248, 113, 113, 0.4);
      border-radius: 8px;
      padding: 8px 10px;
      color: #fecaca;
      font-size: 0.85rem;
    }

    .auth-message {
      background: rgba(74, 222, 128, 0.18);
      border: 1px solid rgba(74, 222, 128, 0.4);
      border-radius: 8px;
      padding: 8px 10px;
      color: #bbf7d0;
      font-size: 0.85rem;
    }

    .welcome-actions {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 20px;
    }

    .welcome-actions button {
      padding: 12px;
      border-radius: 10px;
      font-size: 1rem;
      font-weight: 600;
      border: none;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .welcome-actions button.primary {
      background: linear-gradient(135deg, #fde68a, #f59e0b);
      color: #672601;
      box-shadow: 0 10px 30px rgba(245, 158, 11, 0.35);
    }

    .welcome-actions button.primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 14px 34px rgba(245, 158, 11, 0.45);
    }

    .welcome-actions button.outline {
      background: linear-gradient(135deg, #3ecba3, #09c719);
      color: #2205af;
      border: 1px solid rgba(148, 163, 184, 0.4);
    }

    .welcome-actions button.outline:hover {
      transform: translateY(-2px);
      border-color: rgba(148, 163, 184, 0.7);
      color: #67e8f9;
    }

    /* Small hint link under welcome actions */
    .hint-link {
      margin-top: 10px;
      font-size: 0.9rem;
      color: #93c5fd;
      text-align: center;
      cursor: pointer;
      text-decoration: underline;
    }

    .hint-link:hover {
      color: #bfdbfe;
    }

    .stats-header h3 {
      margin: 1px;
      font-size: 14px;
      color: #fff;
      font-weight: 700;
    }

    #syncStatusIcon {
      font-size: 16px;
      animation: spin 2s linear infinite;
    }

    #syncStatusIcon.synced {
      animation: none;
    }

    @keyframes spin {
      from {
        transform: rotate(0deg);
      }

      to {
        transform: rotate(360deg);
      }
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 5px;
      margin-bottom: 8px;
    }

    /* Adjust grid for 6 items (3 columns, 2 rows) */
    .stat-item:nth-child(4),
    .stat-item:nth-child(5),
    .stat-item:nth-child(6) {
      grid-column: span 1;
    }

    .stat-item:nth-child(4) {
      margin-left: 0%;
    }

    .stat-item {
      text-align: center;
      background: linear-gradient(100deg, rgba(56, 1, 71, 0.951), rgb(181, 2, 169));
      border-radius: 8px;
      padding: 5px 2px;
      border: 2px solid rgba(161, 56, 247, 0.52);
    }

    .stat-value {
      display: block;
      font-size: 16px;
      font-weight: 500;
      color: #fbe8ef;
      text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
    }

    .stat-label {
      display: block;
      font-size: 7px;
      color: rgba(255, 255, 255, 0.9);
      margin-top: 2px;
      font-weight: 500;
    }

    .toolbar {
      display: flex;
      gap: var(--ui-gap);
      margin: 0px;
      flex-wrap: wrap;
      justify-content: center;
    }

    /* Game toolbar buttons styled like home action cards */
    .gameContainer .toolbar button {
      position: relative;
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 600;
      border: none;
      cursor: pointer;
      background: linear-gradient(135deg, #16e0e7 0%, #bfa64a 100%);
      color: #7a058d;
      transition: background 0.2s ease;
      text-shadow: 0 2px 6px rgba(0, 0, 0, 0.6);
      transition: transform 0.25s ease, box-shadow 0.25s ease, border-color 0.25s ease, background 0.25s ease;
      min-height: 34px;
      min-width: 50px;
      overflow: hidden;
      transform-style: preserve-3d;
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    /* 3D glow effect for toolbar buttons */
    .gameContainer .toolbar button::after {
      content: "";
      position: absolute;
      inset: auto 8px -12px;
      height: 20px;
      border-radius: 50%;
      background: radial-gradient(circle at center, rgba(236, 233, 254, 0.35) 0%, rgba(236, 233, 254, 0) 65%);
      filter: blur(1.5px);
      transition: opacity 0.25s ease;
      opacity: 0.6;
    }

    /* Hover effects for toolbar buttons */
    .gameContainer .toolbar button:hover {
      transform: translateY(-4px) scale(1.02) rotateX(2deg);
      box-shadow: 0 18px 32px rgba(10, 10, 45, 0.6);
      border-color: rgba(196, 210, 255, 0.5);
    }

    .gameContainer .toolbar button:hover::after {
      opacity: 0.8;
    }

    .gameContainer .toolbar button:active {
      transform: translateY(-1px) scale(0.99);
      box-shadow: 0 8px 16px rgba(12, 6, 48, 0.45);
    }

    /* Home screen action cards - fixed to prevent ad overlap */
    #homeScreen .home-actions {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      /* Reduced from 14px to prevent overlap */
      margin: 5px;
      margin-top: 5px;
      /* Reduced top margin */
      margin-bottom: 10px;
      /* Bottom margin for ad space */
      box-sizing: border-box;
      perspective: 900px;
      justify-items: center;
      position: relative;
      z-index: 5;
      max-width: calc(100% - 20px);
      /* Prevent overflow */
    }

    #homeScreen .home-actions button {
      position: relative;
      padding: 8px 10px;
      border-radius: 10px;
      background: linear-gradient(115deg, rgb(110, 3, 160), rgba(9, 119, 229, 0.885));
      box-shadow: 0 8px 16px rgba(12, 6, 48, 0.4);
      border: 4px solid rgba(119, 46, 245, 0.812);
      color: #e0e7ff;
      font-size: 0.85rem;
      font-weight: 700;
      letter-spacing: 0.01em;
      text-shadow: 0 2px 4px rgba(15, 23, 42, 0.5);
      transition: transform 0.25s ease, box-shadow 0.25s ease, border-color 0.25s ease;
      min-width: 100px;
      min-height: 70px;
      width: 100%;
      overflow: hidden;
      transform-style: preserve-3d;
      text-align: center;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      gap: 4px;
    }

    #homeScreen .home-actions button::after {
      content: "";
      position: absolute;
      inset: auto 12px -18px;
      height: 28px;
      border-radius: 50%;
      background: radial-gradient(circle at center, rgba(236, 233, 254, 0.45) 0%, rgba(236, 233, 254, 0) 65%);
      filter: blur(2px);
      transition: opacity 0.25s ease;
      opacity: 0.7;
    }

    #homeScreen .home-actions button:hover {
      transform: translateY(-8px) scale(1.02) rotateX(4deg);
      box-shadow: 0 26px 44px rgba(10, 10, 45, 0.6);
      border-color: rgba(196, 210, 255, 0.5);
    }

    #homeScreen .home-actions button:hover::after {
      opacity: 0.9;
    }

    #homeScreen .home-actions button:active {
      transform: translateY(-2px) scale(0.99);
      box-shadow: 0 14px 28px rgba(12, 6, 48, 0.45);
    }

    #homeScreen .home-actions button .action-title {
      display: block;
      font-size: 0.95rem;
      font-weight: 700;
      letter-spacing: 0.01em;
      color: #eef2ff;
    }

    #homeScreen .home-actions button .action-subtitle {
      display: block;
      font-size: 0.65rem;
      font-weight: 500;
      color: rgba(226, 232, 240, 0.85);
      margin-top: 2px;
      text-shadow: none;
      letter-spacing: 0.02em;
    }

    /* centered compact animated popups (sound) */
    .banner {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: none;
      width: min(74vw, 250px);
      max-width: 82%;
      min-height: 110px;
      max-height: 60vh;
      padding: 20px;
      border-radius: 12px;
      /* animated gradient using the home palette but reversed (opposite) */
      background: linear-gradient(135deg, #f74dcf, #d632f3, #33bdf4, #a0b828);
      background-size: 300% 300%;
      animation: gradientShiftPopup 8s ease infinite;
      color: #fff;
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.55), 0 2px 8px rgba(0, 0, 0, 0.25) inset;
      -webkit-backdrop-filter: blur(6px) saturate(1.05);
      backdrop-filter: blur(6px) saturate(1.05);
      z-index: 14000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 20px;
      text-align: center;
      overflow-y: hidden;
      overflow-x: hidden;
      padding-bottom: 20px;
    }

    /* soft complementary glow behind popup (slightly different tones) */
    .banner::before {
      content: "";
      position: absolute;
      inset: -10px;
      border-radius: 16px;
      background: linear-gradient(120deg, rgba(255, 209, 102, 0.20), rgba(74, 222, 128, 0.18), rgba(122, 107, 255, 0.16));
      background-size: 300% 300%;
      filter: blur(18px) saturate(1.05);
      opacity: 0.55;
      z-index: -2;
      pointer-events: none;
      animation: gradientShiftPopup 12s ease infinite;
    }

    /* subtle inner overlay to keep content readable */
    .banner::after {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: 12px;
      background: rgba(0, 0, 0, 0.10);
      z-index: -1;
      pointer-events: none;
    }

    /* smaller centered contents */
    .banner h3 {
      margin: 0 0 12px 0;
      font-size: 1.05rem;
      font-weight: 700;
      line-height: 1.1;
    }

    .banner p {
      margin: 0 0 12px 0;
      font-size: 0.95rem;
      color: #e6eefb;
    }

    .banner .btn-row {
      display: flex;
      gap: 20px;
      width: 100%;
      justify-content: center;
      margin-top: 12px;
      flex-wrap: wrap;
    }

    .banner button {
      padding: 5px 7px;
      border-radius: 8px;
      min-width: 70px;
      background: linear-gradient(90deg, #ad15ee, #0dc60a);
      border: none;
      color: #fff;
      cursor: pointer;
      margin: 8px 10px;
      font-weight: 600;
    }

    /* Ensure buttons in banner have proper spacing between them */
    .banner button+button {
      margin-left: 16px;
    }

    /* ensure specific overlays use same centered style */
    #pauseOverlayClassic,
    #gameOverClassic,
    #pauseOverlayTimed,
    #gameOverTimed {
      /* Match sound popup styling */
      z-index: 14000 !important;
      pointer-events: auto;
      width: min(45vw, 170px) !important;
      max-width: 50% !important;
      padding: 15px !important;
      /* Same gradient as banner class */
      background: linear-gradient(135deg, #1e3a8a, #0ea5e9, #bf7dfc, #dff475);
      background-size: 300% 300%;
      animation: gradientShiftHeader 8s ease infinite;
    }

    /* Sound popup styles */
    #soundPopup {
      display: none;
    }

    #soundPopup>div {
      margin: 10px 0;
    }

    #soundPopup label {
      display: block;
      margin-bottom: 10px;
    }

    #soundPopup input[type="range"] {
      width: 100%;
      margin-top: 5px;
    }

    /* Loading Popup */
    .loading-popup {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.7);
      -webkit-backdrop-filter: blur(4px);
      backdrop-filter: blur(4px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 30000;
      pointer-events: auto;
    }

    .loading-popup.user-stats-hidden {
      display: none;
    }

    .loading-content {
      background: linear-gradient(135deg, rgba(28, 4, 186, 0.984), rgb(234, 14, 190));
      padding: 30px 40px;
      border-radius: 15px;
      text-align: center;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      border: 2px solid rgba(255, 255, 255, 0.3);
    }

    .loading-spinner {
      font-size: 3rem;
      animation: spin 1s linear infinite;
      margin-bottom: 15px;
    }

    @keyframes spin {
      from {
        transform: rotate(0deg);
      }

      to {
        transform: rotate(360deg);
      }
    }

    .loading-text {
      color: white;
      font-size: 1.2rem;
      font-weight: 600;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }

    /* MOBILE / RESPONSIVE RULES */
    @media (max-width: 760px) {
      :root {
        --board-width: min(420px);
        /* recompute inner-size and cell_size on mobile */
        --inner-size: calc(var(--board-width) - (2 * var(--frame-padding)) - (2 * var(--frame-border)));
        --cell-size: calc((var(--inner-size) - (9 * var(--grid-gap))) / 10);
        --piece-block-size: calc(var(--cell-size) * 0.35);
        --btn-padding: 10px 16px;
        --font-size-base: 15px;
      }

      /* Make suggestion box pieces smaller on tablet/mobile */
      #piecesClassic .piece,
      #piecesTimed .piece {
        transform: scale(0.92);
      }
    }

    /* responsive tweaks */
    @media (max-width: 420px) {
      :root {
        --board-width: min(94vw, 340px);
        --inner-size: calc(var(--board-width) - (2 * var(--frame-padding)) - (2 * var(--frame-border)));
        --cell-size: calc((var(--inner-size) - (9 * var(--grid-gap))) / 10);
        --piece-block-size: calc(var(--cell-size) * 0.35);
        --btn-padding: 8px 10px;
        --font-size-base: 14px;
      }

      /* Make suggestion box pieces even smaller on mobile */
      #piecesClassic .piece,
      #piecesTimed .piece {
        transform: scale(0.9);
      }

      .banner {
        width: min(90vw, 300px);
        padding: 10px;
        gap: 15px;
      }

      .banner h3 {
        font-size: 1rem;
      }

      .banner p {
        font-size: 0.9rem;
      }

      .banner button {
        min-width: 76px;
        padding: 7px 10px;
        font-size: 14px;
      }
    }

    /* popup gradient keyframes (different palette than page) */
    @keyframes gradientShiftPopup {
      0% {
        background-position: 0% 50%;
      }

      50% {
        background-position: 100% 50%;
      }

      100% {
        background-position: 0% 50%;
      }
    }

    /* board/grid sizing: cell-size is computed to perfectly fill the frame's inner area */
    #gridClassic,
    #gridTimed {
      display: grid;
      grid-template-columns: repeat(10, var(--cell-size));
      grid-template-rows: repeat(10, var(--cell-size));
      gap: var(--grid-gap);
      width: var(--inner-size);
      /* exact inner area width */
      height: calc((var(--cell-size) * 10) + (9 * var(--grid-gap)));
      box-sizing: border-box;
      margin: 0 auto;
      touch-action: none;
      position: relative;
      z-index: 1;
    }

    .cell {
      width: var(--cell-size);
      height: var(--cell-size);
      background: #475569;
      border-radius: calc(var(--cell-size) * 0.1);
      position: relative;
      z-index: 2;
    }

    /* Pieces trays (added, keeps UI theme) */
    #piecesClassic,
    #piecesTimed {
      display: flex;
      gap: 12px;
      margin: 4px auto;
      flex-wrap: nowrap;
      justify-content: center;
      width: var(--board-width);
      max-width: 100%;
      overflow-x: auto;
      padding: 8px;
      /* Fixed height to prevent layout shift when ANY block is dragged (4-cell, 5-cell, etc.) */
      min-height: calc((var(--piece-block-size) * 5) + (4px * 4) + 12px + 12px);
      height: calc((var(--piece-block-size) * 5) + (4px * 4) + 12px + 12px);
      max-height: calc((var(--piece-block-size) * 5) + (4px * 4) + 12px + 12px);
      flex-shrink: 0;
      box-sizing: border-box;
      position: relative;
      z-index: 10;
      /* Ensure visibility */
      visibility: visible;
      opacity: 1;
    }

    .piece {
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      padding: 6px;
      border-radius: 8px;
      background: transparent;
      /* Fixed size to prevent layout shift - 5 cells + 4 gaps (max size for any block) */
      width: calc((var(--piece-block-size) * 5) + (4px * 4) + 12px);
      height: calc((var(--piece-block-size) * 5) + (4px * 4) + 12px);
      min-width: calc((var(--piece-block-size) * 5) + (4px * 4) + 12px);
      min-height: calc((var(--piece-block-size) * 5) + (4px * 4) + 12px);
      max-width: calc((var(--piece-block-size) * 5) + (4px * 4) + 12px);
      max-height: calc((var(--piece-block-size) * 5) + (4px * 4) + 12px);
      box-sizing: border-box;
      flex-shrink: 0;
      -webkit-user-select: none;
      user-select: none;
      touch-action: none;
      -webkit-touch-callout: none;
    }

    .piece-inner {
      display: grid;
      gap: 4px;
    }

    .piece.selected {
      box-shadow: 0 0 0 2px #38bdf8 inset;
      opacity: 0.6;
    }

    /* When dragging, both original and clone look identical */
    .piece.selected.dragging {
      /* Override selected styles to match clone exactly */
      opacity: 1 !important;
      box-shadow: none !important;
    }

    /* Ensure selected piece blocks keep 3D effect */
    .piece.selected .block {
      box-shadow:
        inset 0 -3px 6px rgba(0, 0, 0, 0.3),
        inset 0 3px 6px rgba(255, 255, 255, 0.4),
        0 2px 4px rgba(0, 0, 0, 0.2);
      background-image: linear-gradient(145deg,
          rgba(255, 255, 255, 0.3) 0%,
          rgba(255, 255, 255, 0.1) 40%,
          rgba(0, 0, 0, 0.1) 100%);
    }

    .piece.selected .block::before {
      content: "";
      position: absolute;
      top: 10%;
      left: 10%;
      right: 10%;
      height: 30%;
      background: linear-gradient(to bottom,
          rgba(255, 255, 255, 0.6),
          rgba(255, 255, 255, 0));
      border-radius: 2px 2px 50% 50%;
    }

    /* Blur invalid pieces that cannot be placed */
    .piece.invalid {
      opacity: 0.4;
      filter: blur(2px);
      cursor: not-allowed;
    }

    /* When dragging, piece follows cursor - exact copy of original */
    .piece.dragging {
      position: fixed !important;
      pointer-events: none;
      z-index: 99999 !important;
      /* Higher than preview (z-index: 2) */
      transition: none !important;
      /* GPU acceleration optimizations */
      will-change: transform;
      transform: translateZ(0);
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
      /* Do NOT override transform; JS controls position via transform */
      /* Override selected styles to show exact original appearance */
      box-shadow: none !important;
      opacity: 1 !important;
      filter: none !important;
      /* Allow piece to resize based on content */
      width: auto !important;
      height: auto !important;
      padding: 0 !important;
      margin: 0 !important;
    }

    /* Scale up piece-inner to use grid gap when dragging */
    .piece.dragging .piece-inner,
    .piece.selected.dragging .piece-inner {
      gap: var(--grid-gap) !important;
      display: grid;
    }

    /* Scale up block size to match grid cells when dragging */
    .piece.dragging .block,
    .piece.selected.dragging .block {
      width: var(--cell-size) !important;
      height: var(--cell-size) !important;
      margin: 0 !important;
    }

    /* Ensure blocks in dragging piece maintain 3D glossy effect */
    .piece.dragging .block {
      box-shadow:
        inset 0 -3px 6px rgba(0, 0, 0, 0.3),
        inset 0 3px 6px rgba(255, 255, 255, 0.4),
        0 2px 4px rgba(0, 0, 0, 0.2) !important;
      background-image: linear-gradient(145deg,
          rgba(255, 255, 255, 0.3) 0%,
          rgba(255, 255, 255, 0.1) 40%,
          rgba(0, 0, 0, 0.1) 100%) !important;
      border: 2px solid rgba(255, 255, 255, 0.9) !important;
    }

    .piece.dragging .block::before {
      content: "";
      position: absolute;
      top: 10%;
      left: 10%;
      right: 10%;
      height: 30%;
      background: linear-gradient(to bottom,
          rgba(255, 255, 255, 0.6),
          rgba(255, 255, 255, 0));
      border-radius: 2px 2px 50% 50%;
      pointer-events: none;
    }

    /* Remove shadow piece styles - no longer needed */

    /* Preview on grid - 3D style like dragging blocks */
    .cell.preview {
      box-shadow:
        inset 0 -3px 6px rgba(0, 0, 0, 0.3),
        inset 0 3px 6px rgba(255, 255, 255, 0.4),
        0 2px 4px rgba(0, 0, 0, 0.2);
      background-image: linear-gradient(145deg,
          rgba(255, 255, 255, 0.3) 0%,
          rgba(255, 255, 255, 0.1) 40%,
          rgba(0, 0, 0, 0.1) 100%);
      border: 2px solid rgba(255, 255, 255, 0.9) !important;
    }

    .cell.preview::before {
      content: "";
      position: absolute;
      top: 10%;
      left: 10%;
      right: 10%;
      height: 30%;
      background: linear-gradient(to bottom,
          rgba(255, 255, 255, 0.6),
          rgba(255, 255, 255, 0));
      border-radius: 2px 2px 50% 50%;
      pointer-events: none;
    }

    .cell.preview-invalid {
      background: rgba(239, 68, 68, 0.7) !important;
      box-shadow:
        inset 0 -3px 6px rgba(0, 0, 0, 0.3),
        inset 0 3px 6px rgba(255, 100, 100, 0.4),
        0 2px 4px rgba(239, 68, 68, 0.3);
      border: 2px solid rgba(239, 68, 68, 1) !important;
    }

    .block {
      width: var(--piece-block-size);
      height: var(--piece-block-size);
      border-radius: 4px;
      position: relative;
      box-shadow:
        inset 0 -3px 6px rgba(0, 0, 0, 0.3),
        inset 0 3px 6px rgba(255, 255, 255, 0.4),
        0 2px 4px rgba(0, 0, 0, 0.2);
      /* Gradient overlay on top of backgroundColor */
      background-image: linear-gradient(145deg,
          rgba(255, 255, 255, 0.3) 0%,
          rgba(255, 255, 255, 0.1) 40%,
          rgba(0, 0, 0, 0.1) 100%);
    }

    .block::before {
      content: "";
      position: absolute;
      top: 10%;
      left: 10%;
      right: 10%;
      height: 30%;
      background: linear-gradient(to bottom,
          rgba(255, 255, 255, 0.6),
          rgba(255, 255, 255, 0));
      border-radius: 2px 2px 50% 50%;
    }

    /* Grid cells with 3D effect */
    .cell {
      position: relative;
      box-shadow: inset 0 0 3px rgba(0, 0, 0, 0.3);
    }

    .cell.filled {
      box-shadow:
        inset 0 -3px 8px rgba(0, 0, 0, 0.35),
        inset 0 3px 8px rgba(255, 255, 255, 0.3),
        0 3px 5px rgba(0, 0, 0, 0.25);
      background: linear-gradient(145deg,
          rgba(255, 255, 255, 0.25) 0%,
          rgba(255, 255, 255, 0.05) 40%,
          rgba(0, 0, 0, 0.15) 100%);
    }

    .cell.filled::before {
      content: "";
      position: absolute;
      top: 8%;
      left: 8%;
      right: 8%;
      height: 25%;
      background: linear-gradient(to bottom,
          rgba(255, 255, 255, 0.5),
          rgba(255, 255, 255, 0));
      border-radius: 2px 2px 50% 50%;
      pointer-events: none;
    }

    /* Butterfly on each cell */
    .cell.filled::after {
      content: "🦋";
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 0.70rem;
      opacity: 0.95;
      pointer-events: none;
      z-index: 2;
      filter: brightness(0) invert(1) drop-shadow(0 2px 6px rgba(0, 0, 0, 0.8));
    }

    /* Line clear animation - Butterfly Flying - Multiple Directions */

    /* Butterfly Flying Up */
    @keyframes butterflyFlyUp {
      0% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1) rotate(0deg);
      }

      30% {
        opacity: 1;
        transform: translate(-50%, -90%) scale(1.15) rotate(-3deg);
      }

      50% {
        opacity: 1;
        transform: translate(-50%, -150%) scale(1.2) rotate(3deg);
      }

      70% {
        opacity: 0.9;
        transform: translate(-50%, -240%) scale(1.1) rotate(-5deg);
      }

      85% {
        opacity: 0.6;
        transform: translate(-50%, -330%) scale(0.95) rotate(5deg);
      }

      95% {
        opacity: 0.3;
        transform: translate(-50%, -420%) scale(0.8) rotate(-8deg);
      }

      100% {
        opacity: 0;
        transform: translate(-50%, -525%) scale(0.6) rotate(10deg);
      }
    }

    /* Butterfly Flying Right (like freeing from cage) */
    @keyframes butterflyFlyRight {
      0% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1) rotate(0deg);
      }

      20% {
        opacity: 1;
        transform: translate(45%, -90%) scale(1.2) rotate(10deg);
      }

      40% {
        opacity: 0.9;
        transform: translate(135%, -135%) scale(1.15) rotate(-5deg);
      }

      60% {
        opacity: 0.8;
        transform: translate(225%, -120%) scale(1.05) rotate(15deg);
      }

      80% {
        opacity: 0.5;
        transform: translate(315%, -90%) scale(0.9) rotate(-10deg);
      }

      100% {
        opacity: 0;
        transform: translate(450%, -60%) scale(0.6) rotate(20deg);
      }
    }

    /* Butterfly Flying Left (like freeing from cage) */
    @keyframes butterflyFlyLeft {
      0% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1) rotate(0deg);
      }

      20% {
        opacity: 1;
        transform: translate(-135%, -90%) scale(1.2) rotate(-10deg);
      }

      40% {
        opacity: 0.9;
        transform: translate(-225%, -135%) scale(1.15) rotate(5deg);
      }

      60% {
        opacity: 0.8;
        transform: translate(-315%, -120%) scale(1.05) rotate(-15deg);
      }

      80% {
        opacity: 0.5;
        transform: translate(-405%, -90%) scale(0.9) rotate(10deg);
      }

      100% {
        opacity: 0;
        transform: translate(-540%, -60%) scale(0.6) rotate(-20deg);
      }
    }

    /* Butterfly Flying Diagonal Up-Right */
    @keyframes butterflyFlyDiagonal {
      0% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1) rotate(0deg);
      }

      25% {
        opacity: 1;
        transform: translate(30%, -105%) scale(1.2) rotate(8deg);
      }

      50% {
        opacity: 0.9;
        transform: translate(120%, -195%) scale(1.15) rotate(-6deg);
      }

      75% {
        opacity: 0.6;
        transform: translate(225%, -300%) scale(0.95) rotate(12deg);
      }

      100% {
        opacity: 0;
        transform: translate(330%, -420%) scale(0.7) rotate(-15deg);
      }
    }

    /* Butterfly Flying Down (like escaping downward) */
    @keyframes butterflyFlyDown {
      0% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1) rotate(0deg);
      }

      30% {
        opacity: 1;
        transform: translate(-50%, 45%) scale(1.15) rotate(5deg);
      }

      60% {
        opacity: 0.8;
        transform: translate(-50%, 135%) scale(1.1) rotate(-8deg);
      }

      100% {
        opacity: 0;
        transform: translate(-50%, 270%) scale(0.7) rotate(12deg);
      }
    }

    /* Placement animation - pulse/scale effect when block is placed */
    @keyframes blockPlacePulse {
      0% {
        transform: scale(1);
        opacity: 1;
      }

      50% {
        transform: scale(1.15);
        opacity: 0.9;
      }

      100% {
        transform: scale(1);
        opacity: 1;
      }
    }

    /* Board fill/clear animations for game start/over */
    .cell.board-filling {
      animation: boardCellFill 0.25s ease-out forwards !important;
    }

    .cell.board-clearing {
      animation: boardCellClear 0.25s ease-out forwards !important;
    }

    @keyframes boardCellFill {
      0% {
        background: rgba(30, 41, 59, 0.5);
        transform: scale(0.3);
        opacity: 0;
        box-shadow: 0 0 0 rgba(239, 68, 68, 0);
      }

      25% {
        background: linear-gradient(135deg, #ef4444, #f97316, #fbbf24);
        transform: scale(1.05);
        opacity: 1;
        box-shadow: 0 0 20px rgba(239, 68, 68, 0.8);
      }

      50% {
        background: linear-gradient(135deg, #f97316, #fbbf24, #ef4444);
        transform: scale(1.15);
        opacity: 1;
        box-shadow: 0 0 30px rgba(249, 115, 22, 1);
      }

      75% {
        background: linear-gradient(135deg, #fbbf24, #ef4444, #f97316);
        transform: scale(1.05);
        opacity: 1;
        box-shadow: 0 0 20px rgba(251, 191, 36, 0.8);
      }

      100% {
        background: rgba(30, 41, 59, 0.5);
        transform: scale(1);
        opacity: 1;
        box-shadow: 0 0 0 rgba(239, 68, 68, 0);
      }
    }

    @keyframes boardCellClear {
      0% {
        background: rgba(30, 41, 59, 0.5);
        transform: scale(1);
        opacity: 1;
        box-shadow: 0 0 0 rgba(239, 68, 68, 0);
      }

      25% {
        background: linear-gradient(135deg, #ef4444, #f97316, #fbbf24);
        transform: scale(1.05);
        opacity: 1;
        box-shadow: 0 0 20px rgba(239, 68, 68, 0.8);
      }

      50% {
        background: linear-gradient(135deg, #f97316, #fbbf24, #ef4444);
        transform: scale(1.15);
        opacity: 1;
        box-shadow: 0 0 30px rgba(249, 115, 22, 1);
      }

      75% {
        background: linear-gradient(135deg, #fbbf24, #ef4444, #f97316);
        transform: scale(1.05);
        opacity: 0.8;
        box-shadow: 0 0 20px rgba(251, 191, 36, 0.8);
      }

      100% {
        background: rgba(30, 41, 59, 0.5);
        transform: scale(0.3);
        opacity: 0;
        box-shadow: 0 0 0 rgba(239, 68, 68, 0);
      }
    }

    @keyframes cellFade {
      0% {
        opacity: 1;
        background: #ffffff !important;
        box-shadow: 0 0 25px #ffffff !important;
      }

      30% {
        opacity: 1;
        background: #fbbf24 !important;
        box-shadow: 0 0 20px #fbbf24 !important;
      }

      60% {
        opacity: 0.6;
        background: #f59e0b !important;
      }

      100% {
        opacity: 0;
      }
    }

    @keyframes bonusPulse {
      0% {
        transform: translate(-50%, -50%) scale(0.3);
        opacity: 0;
      }

      50% {
        transform: translate(-50%, -50%) scale(1.2);
        opacity: 1;
      }

      100% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 0;
      }
    }


    /* Multicolor glow effect for completed lines */
    .cell.line-complete-glow {
      animation: lineGlowPulse 0.5s ease-in-out;
    }

    @keyframes lineGlowPulse {

      0%,
      100% {
        box-shadow:
          0 0 20px var(--glow-color-1),
          0 0 40px var(--glow-color-2),
          0 0 60px var(--glow-color-3),
          inset 0 0 20px var(--glow-color-2);
      }

      50% {
        box-shadow:
          0 0 30px var(--glow-color-1),
          0 0 60px var(--glow-color-2),
          0 0 90px var(--glow-color-3),
          inset 0 0 30px var(--glow-color-2);
      }
    }

    @keyframes lineGlowPulsePreview {

      0%,
      100% {
        opacity: 0.9;
        transform: scale(1);
      }

      50% {
        opacity: 1;
        transform: scale(1.02);
      }
    }


    /* Black butterfly shadow that stays after butterfly flies away */
    .cell.butterfly-shadow::before {
      content: "🦋";
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 0.70rem;
      opacity: 0.25;
      pointer-events: none;
      z-index: 1;
      filter: brightness(0) drop-shadow(0 1px 3px rgba(0, 0, 0, 0.5));
      animation: shadowFadeIn 0.8s ease-out forwards;
    }

    @keyframes shadowFadeIn {
      0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.5);
      }

      100% {
        opacity: 0.25;
        transform: translate(-50%, -50%) scale(1);
      }
    }

    /* Points animation popup - Enhanced with bigger size and more glow */
    .points-popup {
      position: absolute;
      font-size: 3.5rem;
      font-weight: 900;
      color: #fbbf24;
      text-shadow:
        0 0 20px rgba(251, 191, 36, 1),
        0 0 40px rgba(251, 191, 36, 0.7),
        0 0 60px rgba(251, 191, 36, 0.6),
        0 0 80px rgba(251, 191, 36, 0.4),
        3px 3px 6px rgba(0, 0, 0, 0.7);
      pointer-events: none;
      z-index: 1000;
      animation: popupFloat 1s ease-out forwards;
      filter: drop-shadow(0 0 15px currentColor);
    }

    /* Combo popup - Smaller animated text with semi-transparent background */
    .combo-popup {
      position: absolute;
      font-size: 1.8rem;
      font-weight: 800;
      color: #fff;
      background: linear-gradient(135deg, rgba(236, 72, 153, 0.45), rgba(245, 158, 11, 0.45));
      padding: 8px 18px;
      border-radius: 10px;
      border: 2px solid rgba(255, 255, 255, 0.4);
      text-shadow:
        0 0 15px rgba(255, 255, 255, 0.9),
        0 0 30px rgba(255, 255, 255, 0.6),
        2px 2px 4px rgba(0, 0, 0, 0.7);
      box-shadow:
        0 0 20px rgba(236, 72, 153, 0.5),
        0 0 40px rgba(245, 158, 11, 0.4),
        0 6px 24px rgba(0, 0, 0, 0.3);
      pointer-events: none;
      z-index: 1001;
      animation: comboFloat 0.7s ease-out forwards;
      filter: drop-shadow(0 0 8px currentColor);
      -webkit-backdrop-filter: blur(4px);
      backdrop-filter: blur(4px);
    }

    @keyframes popupFloat {
      0% {
        opacity: 0;
        transform: translateY(0) scale(0.5);
        filter: blur(0px);
      }

      20% {
        opacity: 1;
        transform: translateY(-20px) scale(1.1);
        filter: blur(0px);
      }

      80% {
        opacity: 1;
        transform: translateY(-80px) scale(1.0);
        filter: blur(0px);
      }

      100% {
        opacity: 0;
        transform: translateY(-100px) scale(0.7);
        filter: blur(2px);
      }
    }

    @keyframes comboFloat {
      0% {
        opacity: 0;
        transform: translate(-60%, 0) scale(0.5) rotate(-10deg);
      }

      30% {
        opacity: 1;
        transform: translate(-60%, -20px) scale(1.15) rotate(5deg);
      }

      70% {
        opacity: 1;
        transform: translate(-60%, -50px) scale(1.0) rotate(0deg);
      }

      100% {
        opacity: 0;
        transform: translate(-60%, -70px) scale(0.7) rotate(-5deg);
      }
    }

    /* Attractive framed border around main board */
    .boardFrame {
      width: var(--board-width);
      box-sizing: border-box;
      /* include padding inside width */
      padding: var(--frame-padding);
      border-radius: 14px;
      position: relative;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0.01));
      border: var(--frame-border) solid rgba(255, 255, 255, 0.04);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.30), inset 0 1px 0 rgba(255, 255, 255, 0.02);
      -webkit-backdrop-filter: blur(6px) saturate(1.05);
      backdrop-filter: blur(6px) saturate(1.05);
      transition: transform .18s ease, box-shadow .18s ease;
      z-index: 10;
      margin: 12px auto;
      overflow: visible;
      display: flex;
      align-items: center;
      justify-content: center;
      /* Fixed height to prevent layout shift with ANY block (4-cell, 5-cell, etc.) */
      min-height: calc((var(--cell-size) * 10) + (9 * var(--grid-gap)) + (2 * var(--frame-padding)) + (2 * var(--frame-border)));
      height: calc((var(--cell-size) * 10) + (9 * var(--grid-gap)) + (2 * var(--frame-padding)) + (2 * var(--frame-border)));
      max-height: calc((var(--cell-size) * 10) + (9 * var(--grid-gap)) + (2 * var(--frame-padding)) + (2 * var(--frame-border)));
      flex-shrink: 0;
    }

    /* subtle animated colorful glow (behind the frame) */
    .boardFrame::before {
      content: "";
      position: absolute;
      inset: -8px;
      border-radius: 18px;
      background: conic-gradient(from 180deg, rgba(255, 122, 182, 0.30), rgba(122, 107, 255, 0.30), rgba(74, 222, 128, 0.30), rgba(255, 209, 102, 0.30));
      filter: blur(12px) saturate(1.05);
      opacity: 0.8;
      z-index: -1;
      animation: boardGlow 6s linear infinite;
      pointer-events: none;
    }

    /* ensure the inner grid sits nicely inside the frame */
    .boardFrame>#gridClassic,
    .boardFrame>#gridTimed {
      background: rgba(3, 7, 18, 0.32);
      border-radius: 8px;
      box-sizing: border-box;
      display: grid;
      /* ensure the grid fills the frame inner area exactly - FIXED to prevent layout shift */
      width: var(--inner-size);
      height: calc((var(--cell-size) * 10) + (9 * var(--grid-gap)));
      min-height: calc((var(--cell-size) * 10) + (9 * var(--grid-gap)));
      max-height: calc((var(--cell-size) * 10) + (9 * var(--grid-gap)));
      flex-shrink: 0;
    }

    /* MOBILE / RESPONSIVE RULES - Keep for board sizing */
    @media (max-width: 760px) {

      /* stretch toolbar buttons */
      .toolbar button {
        flex: 1 1 auto;
        min-width: 0;
      }

      /* fix toolbar - relative positioning for proper spacing */
      .gameContainer .toolbar {
        position: relative;
        left: auto;
        transform: none;
        bottom: auto;
        width: var(--board-width);
        max-width: 96vw;
        margin-top: 16px;
        margin-bottom: 4px;
        padding: 8px;
        border-radius: 12px;
        display: flex;
        gap: 8px;
        justify-content: space-between;
        background: rgba(8, 10, 18, 0.55);
        z-index: 30;
      }

      /* touch improvements */
      #gridClassic,
      #gridTimed {
        touch-action: manipulation;
      }

      /* compact piece tray on mobile */
      #piecesClassic,
      #piecesTimed {
        gap: 8px;
        padding: 6px;
      }
    }

    /* Classic-mode layout & visual tweaks */
    #classicContainer {
      align-items: center;
      justify-content: flex-start;
      padding-top: 50px;
      padding-bottom: 80px;
      gap: 4px;
    }

    #classicContainer h2 {
      margin: 0 0 4px;
      font-size: 1.7rem;
      font-weight: 900;
      line-height: 1.2;
      text-align: center;
      /* attractive background box - animated blue to sky blue to light green gradient */
      background: linear-gradient(135deg, #1e3a8a, #0973a4, #8228d7, #a0b828);
      background-size: 300% 300%;
      animation: gradientShiftHeader 8s ease infinite;
      padding: 16px 32px;
      border-radius: 16px;
      border: 3px solid rgba(255, 255, 255, 0.25);
      box-shadow:
        0 8px 32px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.2),
        0 0 60px rgba(30, 58, 138, 0.5);
      -webkit-backdrop-filter: blur(10px);
      backdrop-filter: blur(10px);
      /* stylish font family */
      font-family: 'Segoe UI', 'Helvetica Neue', 'Arial Black', sans-serif;
      letter-spacing: 2px;
      /* Remove gradient from h2 itself - gradient is on .text-gradient span */
      color: #fff;
      text-shadow: none;
      z-index: 10100;
      position: relative;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
      display: inline-block;
    }

    #classicContainer h2:hover {
      transform: translateY(-3px);
      box-shadow:
        0 12px 40px rgba(0, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.3),
        0 0 80px rgba(14, 165, 233, 0.6);
    }

    #scoreHsRow {
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: center;
      margin: 4px 0 8px;
      z-index: 10100;
    }

    #scoreHsRow p {
      margin: 0;
      padding: 6px 10px;
      border-radius: 8px;
      background: rgba(109, 3, 174, 0.839);
      color: #2bcee1;
      font-weight: 600;
    }

    #scoreHsRow .hs {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding-left: 10px;
      padding-right: 10px;
    }

    /* Timer display - compact style */
    #timerDisplay {
      margin: 2px 0 4px;
      padding: 4px 12px;
      font-size: 1.1rem;
      font-weight: 600;
      color: rgba(244, 138, 17, 0.839);
      background: rgba(52, 13, 96, 0.861);
      border-radius: 10px;
      text-align: center;
    }

    /* center board with proper spacing */
    .boardFrame {
      margin-top: 8px;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    /* Interval Ad Countdown Timer - Very small size, top-left corner of board */
    /* Game Timer Container - Above Board */
    .game-timer-container {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      gap: 8px;
      margin: 4px 0 8px;
      padding: 0 10px;
      width: var(--board-width);
      max-width: 100%;
    }

    .interval-ad-countdown {
      background: rgba(128, 128, 128, 0.85);
      color: white;
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 0.65rem;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      min-width: 50px;
    }

    .interval-ad-countdown .countdown-time {
      font-size: 0.7rem;
      font-weight: 700;
      line-height: 1;
    }

    /* Mobile adjustments for timer */
    @media (max-width: 760px) {
      .game-timer-container {
        gap: 6px;
        padding: 0 5px;
      }

      .interval-ad-countdown {
        padding: 3px 6px;
        font-size: 0.6rem;
        min-width: 45px;
      }

      .interval-ad-countdown .countdown-time {
        font-size: 0.65rem;
      }
    }

    /* suggestion/pieces tray: centered, more gap, proper spacing */
    #piecesClassic {
      margin-top: 4px;
      margin-bottom: 4px;
      justify-content: center;
      gap: 18px;
      width: var(--board-width);
      max-width: 100%;
    }

    #piecesClassic .piece {
      margin: 0 6px;
    }

    /* toolbar/controls row - proper spacing from pieces tray */
    .gameContainer .toolbar {
      margin-top: 8px;
      margin-bottom: 4px;
      z-index: 10100;
      /* Adjust bottom position to make room for ad on all screens */
      position: relative;
      width: var(--board-width);
      max-width: 100%;
    }

    /* On mobile, adjust toolbar position for ad */
    @media (max-width: 760px) {
      .gameContainer {
        padding-top: 50px;
        padding-bottom: 80px;
      }

      .gameContainer .toolbar {
        position: relative;
        margin-top: 6px;
        margin-bottom: 2px;
      }

      #piecesClassic,
      #piecesTimed {
        margin-top: 4px;
        margin-bottom: 4px;
      }
    }

    /* ensure overlays (pause/gameover) are above board */
    #pauseOverlayClassic,
    #gameOverClassic,
    #pauseOverlayTimed,
    #gameOverTimed {
      z-index: 12000 !important;
      pointer-events: auto;
    }

    /* Timed-mode layout & visual tweaks (same as Classic) */
    #timedContainer {
      align-items: center;
      justify-content: flex-start;
      padding-top: 50px;
      padding-bottom: 80px;
    }

    #timedContainer h2 {
      margin: 0 0 4px;
      font-size: 1.7rem;
      font-weight: 900;
      line-height: 1.2;
      text-align: center;
      /* attractive background box - animated blue to sky blue to light green gradient */
      background: linear-gradient(135deg, #1e3a8a, #0973a4, #8228d7, #a0b828);
      background-size: 300% 300%;
      animation: gradientShiftHeader 8s ease infinite;
      padding: 12px 28px;
      border-radius: 16px;
      border: 3px solid rgba(255, 255, 255, 0.415);
      box-shadow:
        0 8px 32px rgba(54, 52, 52, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.2),
        0 0 60px rgba(30, 58, 138, 0.5);
      -webkit-backdrop-filter: blur(10px);
      backdrop-filter: blur(10px);
      /* stylish font family */
      font-family: 'Segoe UI', 'Helvetica Neue', 'Arial Black', sans-serif;
      letter-spacing: 2px;
      /* Remove gradient from h2 itself - gradient is on .text-gradient span */
      color: #ffffff;
      text-shadow: none;
      z-index: 10100;
      position: relative;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
      display: inline-block;
    }

    #timedContainer h2:hover {
      transform: translateY(-3px);
      box-shadow:
        0 12px 40px rgba(0, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.3),
        0 0 80px rgba(14, 165, 233, 0.6);
    }

    #scoreHsRowTimed {
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: center;
      margin: 4px 0 8px;
      z-index: 10100;
    }

    #scoreHsRowTimed p {
      margin: 0;
      padding: 6px 10px;
      border-radius: 8px;
      background: rgba(109, 3, 174, 0.839);
      color: #2bcee1;
      font-weight: 600;
    }

    #scoreHsRowTimed .hs {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding-left: 10px;
      padding-right: 10px;
    }

    /* center pieces tray for Timed - same as Classic */
    #piecesTimed {
      margin-top: 4px;
      margin-bottom: 4px;
      justify-content: center;
      gap: 18px;
      width: var(--board-width);
      max-width: 100%;
    }

    #piecesTimed .piece {
      margin: 0 6px;
    }

    /* Emoji styling - keep original colors, not affected by gradient */
    .emoji {
      background: none !important;
      background-clip: unset !important;
      -webkit-text-fill-color: currentColor !important;
      color: currentColor;
      display: inline;
    }

    /* Text gradient for headings */
    .text-gradient {
      background: linear-gradient(135deg, #6e05a6 0%, #91047c 25%, #976803 50%, #a00d6c 75%, #b34705 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      color: transparent;
    }

    #classicContainer .text-gradient,
    #timedContainer .text-gradient {
      background: linear-gradient(90deg, #34f0e0, #69f243, #eee318);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      color: transparent;
    }

    /* Home title: larger and multicolor gradient with attractive box */
    #homeScreen h1 {
      width: -webkit-fill-available;
      max-width: 650px;
      font-size: clamp(2rem, 9vw, 2rem);
      /* responsive large size */
      font-weight: 900;
      line-height: 1.5;
      text-align: center;
      /* attractive background box - animated blue to sky blue to light green gradient */
      background: linear-gradient(135deg, #1e3a8a, #0ea5e9, #bf7dfc, #dff475);
      background-size: 300% 300%;
      animation: gradientShiftHeader 8s ease infinite;
      padding: 10px;
      border-radius: 15px;
      border: 4px solid rgb(98, 53, 235);
      box-shadow:
        0 8px 32px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.2),
        0 0 60px rgba(30, 58, 138, 0.5);
      -webkit-backdrop-filter: blur(10px);
      backdrop-filter: blur(10px);
      /* stylish font family */
      font-family: 'Segoe UI', 'Helvetica Neue', 'Arial Black', sans-serif;
      letter-spacing: 3px;
      /* Remove gradient from h1 itself */
      color: #fff;
      text-shadow: none;
      z-index: 2;
      position: relative;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
      margin: 5px 0;
      /* Reduced margin */
    }

    #homeScreen h1:hover {
      transform: translateY(-5px);
      box-shadow:
        0 12px 40px rgba(0, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.3),
        0 0 80px rgba(14, 165, 233, 0.6);
    }

    /* ================================================================= */
    /* RESPONSIVE DESIGN - 4 Breakpoint System                          */
    /* Phone, Tablet, Tablet Landscape, Desktop responsive styles       */
    /* ================================================================= */
    /* ----------------------------------------------------------------- */
    /* 1. PHONE - Screen width smaller than 479px                       */
    /* Optimized for mobile phones in portrait mode                     */
    /* ----------------------------------------------------------------- */
    @media (max-width: 479px) {
      body {
        font-size: 14px;
        overflow: hidden;
      }

      #homeScreen {
        padding: 30px;
        gap: 20px;
      }

      #homeScreen h1 {
        font-size: 1.3rem;
        padding: 8px 12px;
        margin: 8px auto;
        max-width: 100%;
        min-width: auto;
        letter-spacing: 1.5px;
      }

      .user-stats-card {
        max-width: 100%;
        min-width: 290px;
        padding: 20px 0px;
        margin: 10px 10px;
        min-height: 200px;
        max-height: 250px;
      }

      .stats-header {
        font-size: 0.9rem;
        margin-bottom: 8px;
      }

      .stats-grid {
        gap: 6px;
      }

      .stat-item {
        min-width: 60px;
      }

      .stat-label {
        font-size: 0.65rem;
      }

      .stat-value {
        font-size: 1rem;
      }

      .account-actions {
        gap: 6px;
        margin-top: 8px;
      }

      .account-actions button {
        font-size: 0.75rem;
        padding: 6px 10px;
        min-width: 70px;
      }

      /* Further reduce spacing for very small screens */
      #homeScreen h1 {
        padding: 0px 0px;
        font-size: clamp(1.3rem, 6.5vw, 1.5rem);
        line-height: 1.2;
        letter-spacing: 1.5px;
        margin: 5px 0;
        /* Further reduced */
      }

      .user-stats-card {
        margin: 10px auto;
        /* Further reduced */
      }

      #homeScreen .home-actions {
        grid-template-columns: repeat(2, 1fr);
        gap: 12px;
        /* Reduced from 8px to prevent overlap */
        max-width: 100vw;
        width: 100vw;
        padding: 15px;
        margin: 5px;
        margin-top: 10px;
        /* Reduced */
        margin-bottom: 10px;
        /* Space for ad */
      }

      #homeScreen {
        padding-bottom: 65px;
        /* Extra space for ad on small screens */
        gap: 4px;
        /* Reduced gap */
      }

      #homeScreen .home-actions button {
        min-width: 120px;
        min-height: 50px;
        padding: 5px 8px;
        font-size: 0.75rem;
        gap: 2px;
      }

      #homeScreen .home-actions button .action-title {
        font-size: 0.75rem;
      }

      #homeScreen .home-actions button .action-subtitle {
        font-size: 0.55rem;
      }

      .gameContainer {
        padding: 0px;
      }

      .gameContainer h2 {
        font-size: 1.2rem;
        margin: 8px 0;
      }

      .gameContainer .toolbar {
        max-width: 95%;
        padding: 8px;
        gap: 6px;
      }

      .gameContainer .toolbar button {
        font-size: 0.75rem;
        padding: 6px 8px;
        min-width: 50px;
      }

      #scoreClassic,
      #scoreTimed,
      #timerDisplay {
        font-size: 1rem;
        padding: 8px 10px;
      }

      .banner {
        width: 50%;
        max-width: 320px;
        padding: 15px;
      }

      .banner h3 {
        font-size: 1.1rem;
      }

      .banner button {
        font-size: 0.85rem;
        padding: 8px 14px;
      }

      /* Modal responsive adjustments */
      .modal-compact {
        width: 80vw !important;
        max-width: 320px !important;
        padding: 14px;
        padding-bottom: 60px;
      }

      .auth-modal {
        padding: 12px;
        max-width: 90%;
      }

      .auth-modal-content {
        padding: 12px;
      }

      .filter-btn {
        padding: 6px 10px;
        font-size: 12px;
      }

      .country-select {
        padding: 6px 8px;
        font-size: 12px;
      }

      .modal-button {
        width: 100%;
        padding: 10px 16px;
        font-size: 14px;
      }

      /* Board and game elements responsive */
      .boardFrame {
        padding: calc(var(--cell-size) * 0.08);
        transform: translateY(-6px);
      }

      .boardFrame::before {
        inset: -3px;
        filter: blur(8px);
      }

      #classicContainer h2,
      #timedContainer h2 {
        font-size: 1.45rem;
        padding: 10px 20px;
        border-radius: 12px;
        letter-spacing: 1px;
        margin-top: 2px;
      }

      #timerDisplay {
        margin: 0 0 2px;
        padding: 2px 8px;
        font-size: 1rem;
      }

      #piecesClassic {
        margin-top: -8px;
        gap: 14px;
      }

      #piecesTimed {
        margin-top: -22px;
        gap: 14px;
      }

      #timedContainer {
        max-height: 100vh;
        overflow-y: auto;
        padding-top: 40px;
        padding-bottom: 75px;
      }

      #classicContainer {
        max-height: 100vh;
        overflow-y: auto;
        padding-top: 35px;
        padding-bottom: 80px;
      }

      #timedContainer #scoreHsRowTimed {
        margin-top: 0;
        margin-bottom: 10px;
      }

      #timedContainer #timerDisplay {
        margin-top: 0;
        margin-bottom: 10px;
      }

      #timedContainer .boardFrame {
        margin-top: 0;
      }
    }

    /* ----------------------------------------------------------------- */
    /* 2. TABLET - Screen width between 479px and 767px                 */
    /* Optimized for tablets in portrait mode                           */
    /* ----------------------------------------------------------------- */
    @media (min-width: 479px) and (max-width: 767px) {
      body {
        font-size: 15px;
      }

      #homeScreen {
        padding: 15px;
        gap: 15px;
      }

      #homeScreen h1 {
        font-size: 1.6rem;
        padding: 10px 16px;
        margin: 10px auto;
        max-width: 85%;
        letter-spacing: 2px;
      }

      .user-stats-card {
        max-width: 85%;
        min-width: 350px;
        padding: 12px;
        margin: 12px auto;
        min-height: 180px;
        max-height: 250px;
      }

      .stats-header {
        font-size: 1rem;
        margin-bottom: 10px;
      }

      .stats-grid {
        gap: 8px;
      }

      .stat-item {
        min-width: 70px;
      }

      .stat-label {
        font-size: 0.7rem;
      }

      .stat-value {
        font-size: 1.1rem;
      }

      .account-actions {
        gap: 8px;
        margin-top: 10px;
      }

      .account-actions button {
        font-size: 0.8rem;
        padding: 7px 12px;
        min-width: 80px;
      }

      #homeScreen .home-actions {
        grid-template-columns: repeat(2, 1fr);
        gap: 12px;
        max-width: 500px;
        width: 100%;
      }

      #homeScreen .home-actions button {
        min-width: 140px;
        min-height: 90px;
        padding: 12px;
        font-size: 0.85rem;
      }

      #homeScreen .home-actions button .action-title {
        font-size: 0.95rem;
      }

      #homeScreen .home-actions button .action-subtitle {
        font-size: 0.65rem;
      }

      .gameContainer {
        padding: 15px;
      }

      .gameContainer h2 {
        font-size: 1.4rem;
        margin: 10px 0;
      }

      .gameContainer .toolbar {
        max-width: 90%;
        padding: 10px;
        gap: 8px;
      }

      .gameContainer .toolbar button {
        font-size: 0.8rem;
        padding: 8px 10px;
        min-width: 60px;
      }

      #scoreClassic,
      #scoreTimed,
      #timerDisplay {
        font-size: 1.15rem;
        padding: 10px 14px;
      }

      .banner {
        width: 85%;
        max-width: 400px;
        padding: 18px;
      }

      .banner h3 {
        font-size: 1.2rem;
      }

      .banner button {
        font-size: 0.9rem;
        padding: 9px 16px;
      }

      /* Modal responsive adjustments */
      .modal-compact {
        width: 70vw !important;
        max-width: 400px !important;
        padding: 16px;
        padding-bottom: 65px;
      }

      .auth-modal {
        padding: 14px;
        max-width: 85%;
      }

      .auth-modal-content {
        padding: 14px;
      }

      .filter-btn {
        padding: 7px 12px;
        font-size: 13px;
      }

      .country-select {
        padding: 7px 10px;
        font-size: 13px;
      }

      .modal-button {
        width: 100%;
        padding: 11px 18px;
        font-size: 15px;
      }
    }

    /* ----------------------------------------------------------------- */
    /* 3. TABLET LANDSCAPE - Screen width between 767px and 991px       */
    /* Optimized for tablets in landscape orientation                   */
    /* ----------------------------------------------------------------- */
    @media (min-width: 767px) and (max-width: 991px) {
      body {
        font-size: 16px;
      }

      #homeScreen {
        padding: 20px;
        gap: 5 px;
      }

      #homeScreen h1 {
        font-size: 1.9rem;
        padding: 12px 20px;
        margin: 12px auto;
        max-width: 80%;
        letter-spacing: 2.5px;
      }

      .user-stats-card {
        max-width: 75%;
        min-width: 400px;
        padding: 14px;
        margin: 14px auto;
        min-height: 260px;
        max-height: 290px;
      }

      .stats-header {
        font-size: 1.05rem;
        margin-bottom: 12px;
      }

      .stats-grid {
        gap: 10px;
      }

      .stat-item {
        min-width: 80px;
      }

      .stat-label {
        font-size: 0.75rem;
      }

      .stat-value {
        font-size: 1.2rem;
      }

      .account-actions {
        gap: 10px;
        margin-top: 12px;
      }

      .account-actions button {
        font-size: 0.85rem;
        padding: 8px 14px;
        min-width: 90px;
      }

      #homeScreen .home-actions {
        grid-template-columns: repeat(2, 1fr);
        gap: 14px;
        max-width: 600px;
        width: 100%;
      }

      #homeScreen .home-actions button {
        min-width: 160px;
        min-height: 100px;
        padding: 14px;
        font-size: 0.9rem;
      }

      #homeScreen .home-actions button .action-title {
        font-size: 1rem;
      }

      #homeScreen .home-actions button .action-subtitle {
        font-size: 0.7rem;
      }

      .gameContainer {
        padding: 20px;
      }

      .gameContainer h2 {
        font-size: 1.6rem;
        margin: 12px 0;
      }

      .gameContainer .toolbar {
        max-width: 85%;
        padding: 12px;
        gap: 10px;
      }

      .gameContainer .toolbar button {
        font-size: 0.85rem;
        padding: 9px 12px;
        min-width: 70px;
      }

      #scoreClassic,
      #scoreTimed,
      #timerDisplay {
        font-size: 1.25rem;
        padding: 11px 16px;
      }

      .banner {
        width: 75%;
        max-width: 480px;
        padding: 20px;
      }

      .banner h3 {
        font-size: 1.3rem;
      }

      .banner button {
        font-size: 0.95rem;
        padding: 10px 18px;
      }

      /* Modal responsive adjustments */
      .modal-compact {
        width: 60vw !important;
        max-width: 480px !important;
        padding: 18px;
        padding-bottom: 70px;
      }

      .auth-modal {
        padding: 16px;
        max-width: 80%;
      }

      .auth-modal-content {
        padding: 16px;
      }

      .filter-btn {
        padding: 8px 14px;
        font-size: 14px;
      }

      .country-select {
        padding: 8px 12px;
        font-size: 14px;
      }

      .modal-button {
        width: 100%;
        padding: 12px 20px;
        font-size: 16px;
      }
    }

    /* ----------------------------------------------------------------- */
    /* 4. DESKTOP - Screen width greater than 991px                     */
    /* Optimized for large screens (desktop/laptop)                     */
    /* ----------------------------------------------------------------- */
    @media (min-width: 991px) {
      body {
        font-size: 16px;
      }

      #homeScreen {
        padding: 20px;
        gap: 16px;
        overflow-y: auto;
        overflow-x: hidden;
        height: 100vh;
        max-height: 100vh;
        /* Ensure it fits viewport but allows scrolling if needed */
      }

      #homeScreen h1 {
        font-size: 2rem;
        padding: 12px 28px;
        margin: 10px auto;
        max-width: 60%;
        letter-spacing: 2px;
      }

      .user-stats-card {
        max-width: 550px;
        min-width: 480px;
        padding: 18px;
        margin: 12px auto;
        min-height: 280px;
        max-height: 320px;
      }

      .stats-header {
        font-size: 1.05rem;
        margin-bottom: 12px;
      }

      .stats-grid {
        gap: 10px;
      }

      .stat-item {
        min-width: 85px;
      }

      .stat-label {
        font-size: 0.85rem;
      }

      .stat-value {
        font-size: 1.25rem;
      }

      .account-actions {
        gap: 10px;
        margin-top: 12px;
      }

      .account-actions button {
        font-size: 0.9rem;
        padding: 8px 14px;
        min-width: 95px;
      }

      #homeScreen .home-actions {
        grid-template-columns: repeat(2, 1fr);
        gap: 14px;
        max-width: 650px;
        width: 100%;
        margin: 0 auto;
      }

      #homeScreen .home-actions button {
        min-width: 160px;
        min-height: 90px;
        padding: 14px;
        font-size: 0.9rem;
      }

      #homeScreen .home-actions button .action-title {
        font-size: 1rem;
      }

      #homeScreen .home-actions button .action-subtitle {
        font-size: 0.7rem;
      }

      .gameContainer {
        padding: 10px 20px;
        gap: 6px;
        overflow-y: hidden;
        overflow-x: hidden;
        height: 100vh;
        max-height: 100vh;
        box-sizing: border-box;
        /* Ensure padding is included in height calculation */
      }

      #classicContainer,
      #timedContainer {
        padding-top: 50px;
        padding-bottom: 70px;
        gap: 3px;
        height: 100%;
        max-height: calc(100vh - 20px);
        /* Account for container padding */
        overflow: hidden;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
      }

      /* Increase board size for game modes */
      :root {
        --board-width: 420px;
        /* Slightly reduced to fit better */
      }

      .gameContainer h2 {
        font-size: 1.8rem;
        margin: 4px 0;
        letter-spacing: 1px;
        padding: 8px 20px;
        line-height: 1.2;
        /* Reduce line height to save space */
      }

      #scoreHsRow,
      #scoreHsRowTimed {
        font-size: 1rem;
        margin: 4px 0;
        line-height: 1.2;
      }

      .gameContainer .toolbar {
        max-width: 100%;
        width: var(--board-width);
        padding: 8px;
        gap: 8px;
        flex-wrap: nowrap;
        /* Keep all buttons in one row */
        justify-content: space-between;
        /* Distribute buttons evenly */
        margin-top: 2px;
        margin-bottom: 2px;
      }

      .gameContainer .toolbar button {
        font-size: 0.95rem;
        padding: 10px 16px;
        min-width: 90px;
        flex: 1;
        /* Make buttons equal width */
        max-width: none;
      }

      #scoreClassic,
      #scoreTimed,
      #timerDisplay {
        font-size: 1.3rem;
        padding: 8px 16px;
        font-weight: 600;
        line-height: 1.2;
      }

      .boardFrame {
        margin: 2px auto;
        transform: scale(1);
        /* Normal size to fit viewport */
        flex-shrink: 0;
      }

      #piecesClassic,
      #piecesTimed {
        gap: 80px;
        margin: 2px auto;
        overflow-x: visible;
        /* Remove scrollbar on desktop */
        overflow-y: visible;
        flex-wrap: wrap;
        /* Allow wrapping if needed but no scrollbar */
        justify-content: center;
        align-items: flex-start;
        height: auto;
        max-height: 120px;
        /* Reduced to fit better in viewport */
        width: var(--board-width);
        max-width: 100%;
        display: flex;
        flex-direction: row;
        /* Ensure horizontal layout */
        flex-shrink: 0;
      }

      /* Ensure pieces don't stretch in preview box */
      #piecesClassic .piece,
      #piecesTimed .piece {
        flex-shrink: 0;
        flex-grow: 0;
        width: auto;
        height: auto;
        min-width: auto;
        min-height: 0;
        max-width: none;
        max-height: none;
      }

      .piece {
        transform: scale(1);
        /* Normal size to fit viewport */
      }

      .banner {
        width: 75%;
        max-width: 650px;
        padding: 28px;
      }

      .banner h3 {
        font-size: 1.8rem;
        margin-bottom: 16px;
      }

      .banner p {
        font-size: 1.15rem;
        margin: 14px 0;
      }

      .banner button {
        font-size: 1.1rem;
        padding: 13px 24px;
        min-width: 140px;
      }

      .banner .btn-row {
        gap: 24px;
      }

      /* Increase spacing between buttons in all banner popups */
      .banner button {
        margin: 8px 10px;
      }

      /* Modal responsive adjustments */
      .modal-compact {
        width: 50vw !important;
        max-width: 550px !important;
        padding: 20px;
        padding-bottom: 75px;
      }

      .auth-modal {
        padding: 18px;
        max-width: 100%;
      }

      .auth-modal-content {
        padding: 18px;
      }

      .filter-btn {
        padding: 9px 16px;
        font-size: 15px;
      }

      .country-select {
        padding: 9px 14px;
        font-size: 15px;
      }

      .modal-button {
        width: 100%;
        padding: 13px 22px;
        font-size: 17px;
      }
    }

    /* ----------------------------------------------------------------- */
    /* LAPTOP/DESKTOP HEIGHT OPTIMIZATION                                */
    /* Reduce zoom for screens with limited height (laptops)            */
    /* ----------------------------------------------------------------- */
    @media (min-width: 991px) and (max-height: 800px) {
      :root {
        --board-width: 360px;
        /* Adjusted for small height laptops - not too small */
      }

      #homeScreen {
        padding: 12px;
        gap: 10px;
        overflow-y: auto;
        overflow-x: hidden;
        height: 100vh;
        max-height: 100vh;
      }

      #homeScreen h1 {
        font-size: 1.8rem;
        padding: 10px 18px;
        margin: 10px auto;
        letter-spacing: 2px;
      }

      .user-stats-card {
        max-width: 420px;
        min-width: 380px;
        padding: 12px;
        margin: 10px auto;
        min-height: 180px;
        max-height: 250px;
      }

      .stats-header {
        font-size: 0.95rem;
        margin-bottom: 10px;
      }

      .stats-grid {
        gap: 8px;
      }

      .stat-item {
        min-width: 75px;
      }

      .stat-label {
        font-size: 0.7rem;
      }

      .stat-value {
        font-size: 1.1rem;
      }

      .account-actions {
        gap: 8px;
        margin-top: 10px;
      }

      .account-actions button {
        font-size: 0.8rem;
        padding: 7px 12px;
        min-width: 85px;
      }

      #homeScreen .home-actions {
        gap: 12px;
        max-width: 600px;
      }

      #homeScreen .home-actions button {
        min-width: 150px;
        min-height: 90px;
        padding: 12px;
        font-size: 0.85rem;
      }

      #homeScreen .home-actions button .action-title {
        font-size: 0.95rem;
      }

      #homeScreen .home-actions button .action-subtitle {
        font-size: 0.68rem;
      }

      .gameContainer {
        padding: 10px 15px;
        gap: 4px;
        height: 100vh;
        max-height: 100vh;
        box-sizing: border-box;
      }

      #classicContainer,
      #timedContainer {
        padding-top: 50px;
        padding-bottom: 60px;
        gap: 4px;
        max-height: calc(100vh - 20px);
      }

      .gameContainer h2 {
        font-size: 1.6rem;
        margin: 6px 0;
        padding: 6px 15px;
        line-height: 1.2;
      }

      .gameContainer .toolbar {
        max-width: 80%;
        padding: 12px;
        gap: 12px;
      }

      .gameContainer .toolbar button {
        font-size: 0.9rem;
        padding: 10px 14px;
        min-width: 75px;
      }

      #scoreClassic,
      #scoreTimed,
      #timerDisplay {
        font-size: 1.2rem;
        padding: 7px 14px;
        line-height: 1.2;
      }

      .boardFrame {
        margin: 4px auto;
      }

      #piecesClassic,
      #piecesTimed {
        margin-top: 2px;
        gap: 12px;
        max-height: 100px;
      }

      .banner {
        width: 70%;
        max-width: 520px;
        padding: 20px;
      }

      .banner h3 {
        font-size: 1.4rem;
      }

      .banner button {
        font-size: 1rem;
        padding: 10px 18px;
      }
    }

    /* Extra compact for very small height laptops */
    @media (min-width: 991px) and (max-height: 700px) {
      :root {
        --board-width: 320px;
        /* Adjusted - not too small */
      }

      #homeScreen {
        padding: 50px 10px 10px 10px;
        gap: 8px;
        overflow-y: auto;
        overflow-x: hidden;
        height: 100vh;
        max-height: 100vh;
      }

      #homeScreen h1 {
        font-size: 1.4rem;
        padding: 6px 12px;
        margin: 6px auto;
        line-height: 1.2;
      }

      .user-stats-card {
        max-width: 340px;
        min-width: 300px;
        padding: 8px;
        margin: 6px auto;
        min-height: 160px;
        max-height: 220px;
      }

      #homeScreen .home-actions button {
        min-width: 120px;
        min-height: 70px;
        padding: 8px;
      }

      .gameContainer {
        padding: 8px 12px;
        gap: 3px;
        height: 100vh;
        max-height: 100vh;
        box-sizing: border-box;
      }

      #classicContainer,
      #timedContainer {
        padding-top: 50px;
        padding-bottom: 55px;
        gap: 3px;
        max-height: calc(100vh - 16px);
      }

      .gameContainer h2 {
        font-size: 1.4rem;
        margin: 4px 0;
        padding: 5px 12px;
        line-height: 1.2;
      }

      .gameContainer .toolbar {
        padding: 6px;
        gap: 6px;
        margin-top: 2px;
        margin-bottom: 2px;
      }

      .gameContainer .toolbar button {
        font-size: 0.8rem;
        padding: 7px 10px;
        min-width: 70px;
      }

      #scoreClassic,
      #scoreTimed,
      #timerDisplay {
        font-size: 1.1rem;
        padding: 6px 12px;
        line-height: 1.2;
      }

      .boardFrame {
        margin: 2px auto;
      }

      #piecesClassic,
      #piecesTimed {
        margin-top: 1px;
        margin-bottom: 1px;
        gap: 8px;
        max-height: 90px;
      }

      .banner {
        width: 65%;
        max-width: 460px;
        padding: 16px;
      }

      .banner h3 {
        font-size: 1.25rem;
      }
    }

    .picker-title {
      margin: 0;
    }

    .leaderboard-filter-label {
      margin-right: 10px;
      color: white;
    }

    /* Linter: moved from inline styles to avoid "CSS inline styles" warnings */
    .auth-modal-hint { font-size: 0.85rem; color: #1efeff; margin-top: 15px; }
    .auth-modal-p { text-align: center; margin-bottom: 20px; color: #9ca3af; }
    .auth-back-btn { margin-top: 10px; background-color: #80ecf2; color: #000000; }
    .auth-submit-full { width: 100%; margin-top: 10px; }
    .auth-back-full { margin-top: 10px; width: 100%; }
    .country-picker-trigger-block { display: block; }
    .user-stats-btn-hidden { display: none; }
    #exitConfirmPopup.exit-confirm-popup { display: none; z-index: 20000; }
    .exit-confirm-actions { display: flex; gap: 20px; justify-content: center; margin-top: 20px; flex-wrap: wrap; }
    .exit-confirm-yes { background: #ef4444; min-width: 120px; margin: 5px; }
    .exit-confirm-no { background: #10b981; min-width: 120px; margin: 5px; }
    .display-none { display: none; }
    .seo-content-wrapper { position: absolute; left: -9999px; top: 0; width: 1px; height: 1px; overflow: hidden; }
    .seo-content-inner { max-width: 900px; margin: 40px auto; padding: 20px; color: white; text-align: left; line-height: 1.7; }
  </style>
</head>

<body>
  <!-- Welcome Modal -->
  <div id="welcomeModal" class="auth-modal user-stats-hidden">
    <div class="auth-modal-content">
      <h3>🎉 Welcome to Block Puzzle Free Butterfly!</h3>
      <p>Choose how you want to play:</p>
      <div class="welcome-actions">
        <button id="welcomeGuestBtn" class="outline">🎮 Play as Guest</button>
        <button id="welcomeEmailBtn" class="primary">📧 Play with Email</button>
      </div>
      <p class="auth-modal-hint">
        💡 Email login: Recover data if you lose it
      </p>
    </div>
  </div>

  <!-- Guest Authentication Modal -->
  <div id="guestAuthModal" class="auth-modal user-stats-hidden">
    <div class="auth-modal-content">
      <h3 id="guestAuthTitle">🎮 Guest Account</h3>
      <p class="auth-modal-p">
        Choose an option to continue as guest
      </p>
      <div class="welcome-actions">
        <button type="button" id="guestLoginBtn" class="primary">🔑 Login</button>
        <button type="button" id="guestSignupBtn" class="outline">✨ Create Account</button>
      </div>
      <button type="button" id="guestAuthBackBtn" class="outline auth-back-btn">← Back</button>
    </div>
  </div>

  <!-- Email Authentication Modal -->
  <div id="emailAuthModal" class="auth-modal user-stats-hidden">
    <div class="auth-modal-content">
      <h3 id="emailAuthTitle">📧 Email Account</h3>
      <p class="auth-modal-p">
        Choose an option to continue with email
      </p>
      <div class="welcome-actions">
        <button type="button" id="emailLoginBtn" class="primary">🔑 Login</button>
        <button type="button" id="emailSignupBtn" class="outline">✨ Create Account</button>
      </div>
      <button type="button" id="emailAuthBackBtn" class="outline auth-back-btn">← Back</button>
    </div>
  </div>

  <!-- Guest Login Modal -->
  <div id="guestLoginModal" class="auth-modal user-stats-hidden">
    <div class="auth-modal-content">
      <h3>🔑 Guest Login</h3>
      <p class="auth-modal-p">
        Enter your username and password
      </p>
      <form id="guestLoginForm">
        <label>
          Username
          <input type="text" id="guestLoginUsername" placeholder="Enter username" required minlength="3" />
        </label>
        <label>
          Password
          <input type="password" id="guestLoginPassword" placeholder="Enter password" required minlength="4" />
        </label>
        <div id="guestLoginError" class="auth-error user-stats-hidden"></div>
        <button type="submit" id="guestLoginSubmitBtn" class="primary auth-submit-full">Login</button>
      </form>
      <button type="button" id="guestLoginBackBtn" class="outline auth-back-full">←
        Back</button>
    </div>
  </div>

  <!-- Guest Signup Modal - HIDDEN -->
  <div id="guestSignupModal" class="auth-modal user-stats-hidden">
    <div class="auth-modal-content">
      <h3>✨ Create Guest Account</h3>
      <p class="auth-modal-p">
        Create a new guest account to save your progress
      </p>
      <form id="guestSignupForm">
        <label>
          Username
          <input type="text" id="guestSignupUsername" placeholder="Choose username" required minlength="3"
            maxlength="18" />
        </label>
        <label>
          Password
          <input type="password" id="guestSignupPassword" placeholder="Choose password" required minlength="4" />
        </label>
        <label>
          Confirm Password
          <input type="password" id="guestSignupConfirmPassword" placeholder="Re-enter password" required
            minlength="4" />
        </label>
        <label>
          Country
          <span id="guestCountryPicker" class="country-picker-trigger country-picker-trigger-block">Select country…</span>
          <select id="guestCountry" class="user-stats-hidden"></select>
        </label>
        <div id="guestSignupError" class="auth-error user-stats-hidden"></div>
        <button type="submit" id="guestSignupSubmitBtn" class="primary auth-submit-full">Create
          Account</button>
      </form>
      <button type="button" id="guestSignupBackBtn" class="outline auth-back-full">←
        Back</button>
    </div>
  </div>

  <!-- Guest Country Picker Overlay (mobile-friendly) -->
  <div id="guestCountryPickerOverlay" class="country-picker-overlay user-stats-hidden">
    <div class="country-picker-panel">
      <div class="picker-header">
        <h4 class="picker-title">Select Your Country</h4>
        <button type="button" id="closeGuestCountryPicker" class="picker-close" aria-label="Close">✖</button>
      </div>
      <label for="guestCountrySearch" class="user-stats-hidden">Search country</label>
      <input type="text" id="guestCountrySearch" class="picker-search" placeholder="Search country..."
        aria-label="Search country" />
      <div id="guestCountryList" class="country-list"></div>
    </div>
  </div>


  <!-- Delete Account Confirmation Modal -->
  <div id="deleteAccountModal" class="auth-modal user-stats-hidden">
    <div class="auth-modal-content delete-confirm-modal">
      <h3>⚠️ Delete Account</h3>
      <p class="delete-warning">
        Are you sure you want to delete your account?
        <br><br>
        <strong>This will permanently delete:</strong>
      </p>
      <ul class="delete-list">
        <li>All your game progress and statistics</li>
        <li>Your high scores (Classic & Timed)</li>
        <li>All unlocked achievements</li>
        <li>Your guest ID or account data</li>
      </ul>
      <p class="delete-warning-final">
        <strong>⚠️ This action cannot be undone!</strong>
      </p>
      <div class="welcome-actions">
        <button id="confirmDeleteBtn" class="delete-btn">🗑️ Delete Account</button>
        <button id="cancelDeleteBtn" class="outline">Cancel</button>
      </div>
    </div>
  </div>


  <!-- Loading Popup -->
  <div id="loadingPopup" class="loading-popup user-stats-hidden">
    <div class="loading-content">
      <div class="loading-spinner">⏳</div>
      <div class="loading-text">Loading...</div>
    </div>
  </div>

  <!-- Home Screen -->
  <div id="homeScreen">
    <h1>
      <span class="emoji">🦋</span><span class="text-gradient"> Block Puzzle </span><span class="emoji">🦋</span>
      <br>
      <span class="emoji">🦋</span><span class="text-gradient">Free Butterfly </span><span class="emoji">🦋</span>
    </h1>

    <!-- User Stats Display -->
    <div id="userStatsDisplay" class="user-stats-card user-stats-hidden">
      <div class="stats-header">
        <h3 id="playerNameDisplay">🎮 Player</h3>
        <span id="syncStatusIcon">🔄</span>
      </div>
      <div class="stats-grid">
        <div class="stat-item">
          <span class="stat-value" id="totalGamesDisplay">0</span>
          <span class="stat-label">Games</span>
        </div>
        <div class="stat-item">
          <span class="stat-value" id="totalTimeDisplay">0m</span>
          <span class="stat-label">Play Time</span>
        </div>
        <div class="stat-item">
          <span class="stat-value" id="classicTimerDisplay">00:00:00</span>
          <span class="stat-label">Classic Timer</span>
        </div>
        <div class="stat-item">
          <span class="stat-value" id="timedTimerDisplay">00:00:00</span>
          <span class="stat-label">Timed Timer</span>
        </div>
        <div class="stat-item">
          <span class="stat-value" id="achievementsCountDisplay">0</span>
          <span class="stat-label">Achievements</span>
        </div>
        <div class="stat-item">
          <span class="stat-value" id="classicHighScoreDisplay">0</span>
          <span class="stat-label">Classic HS</span>
        </div>
        <div class="stat-item">
          <span class="stat-value" id="timedHighScoreDisplay">0</span>
          <span class="stat-label">Timed HS</span>
        </div>
      </div>
      <div class="account-actions">
        <button id="deleteAccountBtn" class="delete-account-btn user-stats-hidden" title="Delete Account"> 🗑️</button>
        <button id="signInBtn" class="user-stats-btn-hidden">🔑 Sign In</button>
        <button id="loginBtn" class="user-stats-btn-hidden">🔑 Login</button>
        <button id="signOutBtn" class="user-stats-btn-hidden">🚪 Sign Out</button>
      </div>
    </div>

    <div class="toolbar home-actions">
      <button id="classicBtn" data-sub-en="Endless chill mode" data-sub-gu="અવિરત મજા માટેનો મોડ">
        <span class="action-title">🎮 Classic Game 🎮</span>
        <span class="action-subtitle">Endless chill mode</span>
      </button>
      <button id="timedBtn" data-sub-en="Beat the clock challenge" data-sub-gu="ઘડિયાળ સામેનો પડકાર">
        <span class="action-title">⏱️ Timed Game ⏱️</span>
        <span class="action-subtitle">Beat the clock challenge</span>
      </button>
      <button id="toggleLangBtn" data-sub-en="Switch language" data-sub-gu="ભાષા બદલો">
        <span class="action-title">🌐 English</span>
        <span class="action-subtitle">Switch language</span>
      </button>
      <!-- Added: Sound button to open sound controls -->
      <button id="soundBtn" data-sub-en="Adjust music & effects" data-sub-gu="સંગીત અને અસર નિયંત્રિત કરો">
        <span class="action-title">🔊 Sound</span>
        <span class="action-subtitle">Adjust music & effects</span>
      </button>
      <!-- Added: Achievements button -->
      <button id="achievementsBtn" data-sub-en="View your achievements" data-sub-gu="તમારી સિદ્ધિઓ જુઓ">
        <span class="action-title">🏆 Achievements</span>
        <span class="action-subtitle">View your achievements</span>
      </button>
      <!-- Added: Leaderboard button -->
      <button id="leaderboardBtn" data-sub-en="View rankings" data-sub-gu="રેન્કિંગ જુઓ">
        <span class="action-title">📊 Leaderboard</span>
        <span class="action-subtitle">View rankings</span>
      </button>
      <!-- Added: How to Play button -->
      <button id="howToPlayBtn" data-sub-en="Learn how to play" data-sub-gu="કેવી રીતે રમવું તે શીખો">
        <span class="action-title">📖 How to Play</span>
        <span class="action-subtitle">Learn how to play</span>
      </button>
      <!-- Added: Privacy Policy button -->
      <button id="privacyPolicyBtn" data-sub-en="Privacy Policy" data-sub-gu="ગોપનીયતા નીતિ">
        <span class="action-title">🔒 Privacy Policy</span>
        <span class="action-subtitle">Privacy Policy</span>
      </button>
    </div>
  </div>

  <!-- Sound Control Popup -->
  <div id="soundPopup" class="banner">
    <h3>🔊 Sound Settings</h3>
    <div>
      <label>
        🎵 Music Volume
        <input type="range" id="musicVolume" min="0" max="100" value="3">
        <span id="musicVolumeValue">3%</span>
      </label>
      <label>
        🎮 Effects Volume
        <input type="range" id="effectsVolume" min="0" max="100" value="10">
        <span id="effectsVolumeValue">10%</span>
      </label>
    </div>
    <button id="closeSoundPopup">Close</button>
  </div>

  <!-- Achievement Unlock Popup -->
  <div id="achievementPopup" class="banner user-stats-hidden">
    <h3 id="achievementTitle">🏆 Achievement Unlocked!</h3>
    <p id="achievementMessage"></p>
    <button id="closeAchievementPopup">Close</button>
  </div>

  <!-- Achievement List Modal -->
  <div id="achievementListModal" class="auth-modal user-stats-hidden">
    <div class="auth-modal-content modal-compact">
      <h3>🏆 Achievements</h3>
      <div id="achievementsList"></div>
      <button id="closeAchievementList" class="modal-button">Close</button>
    </div>
  </div>

  <!-- How to Play Page -->
  <div id="howToPlayPage" class="info-page user-stats-hidden">
    <div class="info-page-header">
      <h2>📖 How to Play</h2>
    </div>
    <div id="howToPlayContent" class="info-page-content"></div>
  </div>

  <!-- Privacy Policy Page -->
  <div id="privacyPolicyPage" class="info-page user-stats-hidden">
    <div class="info-page-header">
      <h2>🔒 Privacy Policy</h2>
    </div>
    <div id="privacyPolicyContent" class="info-page-content"></div>
  </div>

  <!-- Exit Confirmation Popup -->
  <div id="exitConfirmPopup" class="banner user-stats-hidden exit-confirm-popup">
    <h3>🚪 Exit Game?</h3>
    <p id="exitConfirmMessage">Are you sure you want to exit the game?</p>
    <div class="exit-confirm-actions">
      <button id="exitConfirmYes" class="modal-button exit-confirm-yes">Yes,
        Exit</button>
      <button id="exitConfirmNo" class="modal-button exit-confirm-no">No,
        Stay</button>
    </div>
  </div>

  <!-- Leaderboard Modal -->
  <div id="leaderboardModal" class="auth-modal user-stats-hidden">
    <div class="auth-modal-content modal-compact">
      <h3>🏆 Leaderboard</h3>
      <div class="modal-filter-row">
        <button id="showClassicLeaderboard" class="filter-btn">Classic Mode</button>
        <button id="showTimedLeaderboard" class="filter-btn">Timed Mode</button>
      </div>
      <div class="modal-filter-row">
        <label for="leaderboardCountryFilter" class="leaderboard-filter-label">🌍 Filter:</label>
        <div id="leaderboardCountryPicker" class="country-picker-trigger">🌍 Global</div>
        <select id="leaderboardCountryFilter" class="user-stats-hidden"></select>
      </div>
      <div id="leaderboardPickerOverlay" class="country-picker-overlay user-stats-hidden">
        <div class="country-picker-panel">
          <div class="picker-header">
            <h4 class="picker-title">Filter by Country</h4>
            <button type="button" id="closeLeaderboardPicker" class="picker-close" aria-label="Close">✖</button>
          </div>
          <label for="leaderboardCountrySearch" class="user-stats-hidden">Search country</label>
          <input type="text" id="leaderboardCountrySearch" class="picker-search" placeholder="Search country..."
            aria-label="Search country" />
          <div id="leaderboardCountryList" class="country-list"></div>
        </div>
      </div>
      <div id="leaderboardContent"></div>
      <button id="closeLeaderboard" class="modal-button">Close</button>
    </div>
  </div>

  <!-- Classic Game -->
  <div id="classicContainer" class="gameContainer">
    <h2><span class="emoji">🎮</span><span class="text-gradient"> Classic Mode </span><span class="emoji">🎮</span></h2>
    <div id="scoreHsRow" aria-live="polite">
      <p id="scoreClassic">Score: 0</p>
      <p id="hsSmall" class="hs">🏆 0</p>
    </div>
    <!-- Game Play Timer - Above Board -->
    <div class="game-timer-container">
      <div id="intervalAdCountdownClassic" class="interval-ad-countdown display-none">
        <span class="countdown-time" id="intervalAdCountdownTimeClassic">00:00</span>
      </div>
    </div>
    <div class="boardFrame">
      <div id="gridClassic"></div>
    </div>
    <!-- Added: pieces tray for Classic -->
    <div id="piecesClassic"></div>
    <div class="toolbar">
      <button id="undoClassicBtn">↶ Undo</button>
      <button id="pauseClassicBtn">⏸️ Pause</button>
      <button id="musicToggleClassicBtn">🔊 Music</button>
      <button id="goHomeClassicBtn">🏠 Home</button>
    </div>
    <!-- Pause Overlay -->
    <div id="pauseOverlayClassic" class="banner">
      <h3>⏸️ Classic Paused</h3>
      <button id="resumeClassicBtn">▶️ Resume</button>
      <button id="restartPauseOverlayClassicBtn">🔄 Restart</button>
    </div>
    <!-- Pause Popup -->
    <div id="pausePopupClassic" class="banner pause-popup display-none">
      <h3>⏸️ Classic Paused</h3>
      <p>Game paused. You switched tabs or minimized the app. Press resume to continue your classic game.</p>
      <button id="pausePopupClassicResume">▶️ Resume</button>
      <button id="pausePopupClassicRestart">🔄 Restart</button>
    </div>
    <!-- Game Over -->
    <div id="gameOverClassic" class="banner">
      <h3>❌ Classic Over</h3>
      <p id="finalScoreClassic"></p>
      <button id="restartClassicBtn">🔄 Restart</button>
      <button id="goHomeClassicOverBtn">🏠 Home</button>
    </div>
  </div>

  <!-- Timed Game -->
  <div id="timedContainer" class="gameContainer">
    <h2><span class="emoji">⏱️</span><span class="text-gradient"> Timed Mode </span><span class="emoji">⏱️</span></h2>
    <div id="scoreHsRowTimed" aria-live="polite">
      <p id="scoreTimed">Score: 0</p>
      <p id="hsSmallTimed" class="hs">🏆 0</p>
    </div>
    <p id="timerDisplay">Time: 300</p>
    <!-- Game Play Timer - Above Board -->
    <div class="game-timer-container">
      <div id="intervalAdCountdownTimed" class="interval-ad-countdown display-none">
        <span class="countdown-time" id="intervalAdCountdownTimeTimed">00:00</span>
      </div>
    </div>
    <div class="boardFrame">
      <div id="gridTimed"></div>
    </div>
    <!-- Added: pieces tray for Timed -->
    <div id="piecesTimed"></div>
    <div class="toolbar">
      <button id="undoTimedBtn">↶ Undo</button>
      <button id="pauseTimedBtn">⏸️ Pause</button>
      <button id="musicToggleTimedBtn">🔊 Music</button>
      <button id="goHomeTimedBtn">🏠 Home</button>
    </div>
    <!-- Pause Overlay -->
    <div id="pauseOverlayTimed" class="banner">
      <h3>⏸️ Timed Paused</h3>
      <button id="resumeTimedBtn">▶️ Resume</button>
      <button id="restartPauseOverlayTimedBtn">🔄 Restart</button>
    </div>
    <!-- Pause Popup -->
    <div id="pausePopupTimed" class="banner pause-popup display-none">
      <h3>⏸️ Timed Paused</h3>
      <p>Game paused. You switched tabs or minimized the app. Press resume to continue your timed game.</p>
      <button id="pausePopupTimedResume">▶️ Resume</button>
      <button id="pausePopupTimedRestart">🔄 Restart</button>
    </div>
    <!-- Game Over -->
    <div id="gameOverTimed" class="banner">
      <h3>❌ Timed Over</h3>
      <p id="finalScoreTimed"></p>
      <button id="restartTimedBtn">🔄 Restart</button>
      <button id="goHomeTimedOverBtn">🏠 Home</button>
    </div>
  </div>

  <!-- Authentication Modal -->
  <div id="authModal" class="auth-modal user-stats-hidden">
    <div class="auth-modal-content">
      <button id="authCloseBtn" class="auth-close-btn" type="button" aria-label="Close">×</button>
      <h3 id="authModalTitle">Create Account</h3>
      <p id="authModalMessage">Create an account to keep your progress safe forever.</p>
      <div id="authError" class="auth-error user-stats-hidden"></div>
      <div id="authMessage" class="auth-message user-stats-hidden"></div>
      <form id="authForm">
        <label id="displayNameGroup" class="user-stats-hidden">
          User name
          <input type="text" id="authDisplayName" minlength="3" maxlength="18" autocomplete="name" />
        </label>
        <label>
          Email address
          <input type="email" id="authEmail" required autocomplete="email" />
        </label>
        <label>
          Password
          <input type="password" id="authPassword" required minlength="6" autocomplete="current-password" />
        </label>
        <label id="confirmPasswordGroup" class="user-stats-hidden">
          Confirm password
          <input type="password" id="authConfirmPassword" minlength="6" autocomplete="new-password" />
        </label>
        <label id="countryGroup" class="user-stats-hidden">
          Country
          <span id="authCountryPicker" class="country-picker-trigger country-picker-trigger-block">Select country…</span>
          <select id="authCountry" class="user-stats-hidden"></select>
        </label>
        <button type="submit" id="authSubmitBtn">Save Progress</button>
      </form>
      <div class="auth-switch">
        <button type="button" id="authForgotPasswordBtn">Forgot password?</button>
      </div>
      <div class="auth-switch">
        <button type="button" id="switchAuthModeBtn">Already have an account? Sign In</button>
      </div>
    </div>
    <!-- Auth Country Picker Overlay (mobile-friendly) -->
    <div id="authCountryPickerOverlay" class="country-picker-overlay user-stats-hidden">
      <div class="country-picker-panel">
        <div class="picker-header">
          <h4 class="picker-title">Select Your Country</h4>
          <button type="button" id="closeAuthCountryPicker" class="picker-close" aria-label="Close">✖</button>
        </div>
        <label for="authCountrySearch" class="user-stats-hidden">Search country</label>
        <input type="text" id="authCountrySearch" class="picker-search" placeholder="Search country..."
          aria-label="Search country" />
        <div id="authCountryList" class="country-list"></div>
      </div>
    </div>
  </div>

  <script>
    // ===== GLOBAL GAME STATE FLAGS (Must be declared first) =====
    let isGameActive = false; // Track if player is currently playing a game
    let isStartupLoad = true; // Prevent achievement popups on startup
    let isManuallyPaused = false; // Track if game was manually paused/exited to prevent game over
    let isGameRestoring = false; // Track if game is being restored to prevent game over checks
    let isDrawingOnly = false; // Track if we're just drawing pieces without game logic
    let gameOverGloballyDisabled = false; // Nuclear option - disable all game over completely
    let isLegitimateGameOver = false; // Track if game over was legitimately shown (should not be hidden)
    let boardFillSequence = []; // Store the random fill sequence for matching clear animation
    let totalLinesEarned = 0; // Track total lines for achievements
    let totalExtraTimeEarned = 0; // Track extra time for achievements

    // ===== GAME STATE VARIABLES =====
    /* Classic state */
    let scoreClassic = 0, boardClassic = [], pausedClassic = null;
    let currentThreeClassic = [], selectedClassic = null, selectedIdxClassic = null;

    /* Timed state */
    let scoreTimed = 0, boardTimed = [], timer = 300, timerInterval = null, pausedTimed = null;
    let currentThreeTimed = [], selectedTimed = null, selectedIdxTimed = null;
    let bonusCellInterval = null;

    /* Game tracking variables */
    let gameStartTime = Date.now();
    let totalLinesClassic = 0;
    let totalLinesTimed = 0;
    let totalBlocksPlaced = 0;
    let totalBlocksPlacedTimed = 0;
    let currentLevelTimed = 1;
    let extraTimeEarnedInGame = 0;

    /* Game play time tracking - Separate timers for Classic and Timed modes */
    let gamePlayTimerClassic = null;
    let gamePlayTimerTimed = null;
    let gamePlayStartTimeClassic = 0; // When Classic mode timer started
    let gamePlayStartTimeTimed = 0; // When Timed mode timer started
    let gamePlayPausedTimeClassic = 0; // When Classic timer was paused
    let gamePlayPausedTimeTimed = 0; // When Timed timer was paused
    let gamePlayPausedElapsedClassic = 0; // Elapsed time when Classic paused
    let gamePlayPausedElapsedTimed = 0; // Elapsed time when Timed paused
    let isGamePlayPausedClassic = false;
    let isGamePlayPausedTimed = false;
    // ===== INACTIVITY TRACKING FOR TIMER PAUSE =====
    let lastActivityTimeClassic = Date.now(); // Last user activity in Classic mode
    let lastActivityTimeTimed = Date.now(); // Last user activity in Timed mode
    let isInactivityPausedClassic = false; // Timer paused due to inactivity
    let isInactivityPausedTimed = false; // Timer paused due to inactivity
    const INACTIVITY_THRESHOLD = 30 * 1000; // 30 seconds in milliseconds
    let inactivityCheckInterval = null; // Interval to check for inactivity

    // ===== WEIGHTED RANDOM SHAPE SYSTEM =====
    // Track shape distribution over 10-session cycles
    let shapeSessionCounter = 0; // Current session in 10-session cycle (0-9)
    let shapePool = []; // Pool of shapes for current 10-session cycle

    // Shape groups based on requirements:
    // Group 1: Shape 1 (index 0) - 1 time per 10 sessions
    // Group 2: Shapes 2,3,4,6,7,8 (indices 1,2,3,5,6,7) - pick 2 randomly, each appears 1 time
    // Group 3: Shapes 5,9,10,11,12,13 (indices 4,8,9,10,11,12) - pick 2 randomly, each appears 1 time
    // Group 4: Shapes 14-33 (indices 13-32) - pick 3 randomly, each appears 1 time
    // Group 5: Shapes 34-39 (indices 33-38) - pick 1 randomly, appears 1 time
    // Group 6: Shapes 40-53 (indices 39-52) - pick 1 randomly, appears 1 time

    function initializeShapePool() {
      shapePool = [];

      // Group 1: Shape 1 (index 0) - 1 time
      shapePool.push(0);

      // Group 2: Shapes 2,3,4,6,7,8 (indices 1,2,3,5,6,7) - pick 2 randomly, each appears 1 time
      const group2 = [1, 2, 3, 5, 6, 7];
      const shuffledGroup2 = [...group2].sort(() => Math.random() - 0.5);
      shapePool.push(shuffledGroup2[0], shuffledGroup2[1]);

      // Group 3: Shapes 5,9,10,11,12,13 (indices 4,8,9,10,11,12) - pick 2 randomly, each appears 1 time
      const group3 = [4, 8, 9, 10, 11, 12];
      const shuffledGroup3 = [...group3].sort(() => Math.random() - 0.5);
      shapePool.push(shuffledGroup3[0], shuffledGroup3[1]);

      // Group 4: Shapes 14-33 (indices 13-32) - pick 3 randomly, each appears 1 time
      const group4 = Array.from({ length: 20 }, (_, i) => i + 13);
      const shuffledGroup4 = [...group4].sort(() => Math.random() - 0.5);
      shapePool.push(shuffledGroup4[0], shuffledGroup4[1], shuffledGroup4[2]);

      // Group 5: Shapes 34-39 (indices 33-38) - pick 1 randomly, appears 1 time
      const group5 = Array.from({ length: 6 }, (_, i) => i + 33);
      const shuffledGroup5 = [...group5].sort(() => Math.random() - 0.5);
      shapePool.push(shuffledGroup5[0]);

      // Group 6: Shapes 40-53 (indices 39-52) - pick 1 randomly, appears 1 time
      const group6 = Array.from({ length: 14 }, (_, i) => i + 39);
      const shuffledGroup6 = [...group6].sort(() => Math.random() - 0.5);
      shapePool.push(shuffledGroup6[0]);

      // Shuffle the entire pool to randomize order
      shapePool = shapePool.sort(() => Math.random() - 0.5);

      console.log("🎲 Shape pool initialized for 10-session cycle:", shapePool);
    }

    // Initialize pool on first load
    initializeShapePool();

    // Function to format elapsed time dynamically: MM:SS -> HH:MM:SS -> DD:HH:MM:SS
    function formatElapsedTime(milliseconds) {
      const totalSeconds = Math.floor(milliseconds / 1000);
      const days = Math.floor(totalSeconds / 86400);
      const hours = Math.floor((totalSeconds % 86400) / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;

      if (days > 0) {
        // Format: DD:HH:MM:SS
        return `${days.toString().padStart(2, '0')}:${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      } else if (hours > 0) {
        // Format: HH:MM:SS
        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      } else {
        // Format: MM:SS
        return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }
    }

    // Function to format elapsed time always as DD:HH:MM:SS (for Firebase storage)
    function formatElapsedTimeForFirebase(milliseconds) {
      const totalSeconds = Math.floor(milliseconds / 1000);
      const days = Math.floor(totalSeconds / 86400);
      const hours = Math.floor((totalSeconds % 86400) / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;

      // Always return DD:HH:MM:SS format
      return `${days.toString().padStart(2, '0')}:${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

    // Function to format timestamp as "Nov 28, 2025 11:30:02 PM IST" (for Firebase storage)
    function formatTimestampForFirebase(timestampMs) {
      if (!timestampMs || timestampMs === 0) return '';

      const date = new Date(timestampMs);
      const options = {
        month: 'short',
        day: 'numeric',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: true,
        timeZone: 'Asia/Kolkata'
      };

      const formatted = date.toLocaleString('en-IN', options);
      // Add IST suffix
      return formatted + ' IST';
    }

    // Function to parse elapsed time from Firebase format "00:00:00:00" back to milliseconds
    function parseElapsedTimeFromFirebase(timeString) {
      if (!timeString || typeof timeString !== 'string') return 0;

      const parts = timeString.split(':');
      if (parts.length === 4) {
        const days = parseInt(parts[0]) || 0;
        const hours = parseInt(parts[1]) || 0;
        const minutes = parseInt(parts[2]) || 0;
        const seconds = parseInt(parts[3]) || 0;

        const totalSeconds = (days * 86400) + (hours * 3600) + (minutes * 60) + seconds;
        return totalSeconds * 1000; // Convert to milliseconds
      }
      return 0;
    }

    // Function to parse timestamp from Firebase format back to milliseconds
    function parseTimestampFromFirebase(dateString) {
      if (!dateString || typeof dateString !== 'string') return 0;

      // Try to parse the date string (remove IST suffix if present)
      const cleanDateString = dateString.replace(' IST', '').trim();
      const date = new Date(cleanDateString);

      if (!isNaN(date.getTime())) {
        return date.getTime();
      }

      return 0;
    }

    // Timer state is now saved in Firebase with game state, not localStorage
    // This function is kept for backward compatibility but doesn't use localStorage
    function loadGamePlayTimerState(mode) {
      // Timer state is loaded from Firebase game state, not localStorage
      // Return default state if not found
      return { startTime: 0, pausedElapsed: 0, isPaused: false, pausedTime: 0 };
    }

    // Timer state is now saved in Firebase with game state, not localStorage
    // This function is kept for backward compatibility but doesn't save to localStorage
    function saveGamePlayTimerState(mode, state) {
      // Timer state is saved to Firebase via saveClassicGameState/saveTimedGameState
      // No need to save to localStorage
    }

    // Function to update game play timer display
    function updateGamePlayTimer(mode) {
      const isClassic = mode === 'classic';
      const container = isClassic ?
        document.getElementById('classicContainer') :
        document.getElementById('timedContainer');
      const isVisible = container && container.style.display !== 'none';

      if (!isVisible) {
        const countdown = document.getElementById(isClassic ? 'intervalAdCountdownClassic' : 'intervalAdCountdownTimed');
        if (countdown) countdown.style.display = 'none';
        return;
      }

      // Calculate elapsed time
      let elapsedTime = 0;
      if (isClassic) {
        if (!isGamePlayPausedClassic && gamePlayStartTimeClassic > 0) {
          elapsedTime = Date.now() - gamePlayStartTimeClassic;
        } else if (isGamePlayPausedClassic && gamePlayPausedElapsedClassic > 0) {
          elapsedTime = gamePlayPausedElapsedClassic;
        }
      } else {
        if (!isGamePlayPausedTimed && gamePlayStartTimeTimed > 0) {
          elapsedTime = Date.now() - gamePlayStartTimeTimed;
        } else if (isGamePlayPausedTimed && gamePlayPausedElapsedTimed > 0) {
          elapsedTime = gamePlayPausedElapsedTimed;
        }
      }

      const formattedTime = formatElapsedTime(elapsedTime);
      const countdownId = isClassic ? 'intervalAdCountdownClassic' : 'intervalAdCountdownTimed';
      const timeId = isClassic ? 'intervalAdCountdownTimeClassic' : 'intervalAdCountdownTimeTimed';

      const countdown = document.getElementById(countdownId);
      const timeElement = document.getElementById(timeId);

      if (countdown && timeElement) {
        countdown.style.display = 'flex';
        timeElement.textContent = formattedTime;
      }
    }

    // Function to record user activity
    function recordUserActivity(mode) {
      const isClassic = mode === 'classic';
      if (isClassic) {
        lastActivityTimeClassic = Date.now();
        // Resume timer if it was paused due to inactivity
        if (isInactivityPausedClassic && isGamePlayPausedClassic) {
          console.log("✅ User activity detected - resuming Classic timer from inactivity pause");
          isInactivityPausedClassic = false;
          resumeGamePlayTimer('classic');
        }
      } else {
        lastActivityTimeTimed = Date.now();
        // Resume timer if it was paused due to inactivity
        if (isInactivityPausedTimed && isGamePlayPausedTimed) {
          console.log("✅ User activity detected - resuming Timed timer from inactivity pause");
          isInactivityPausedTimed = false;
          resumeGamePlayTimer('timed');
        }
      }
    }

    // Function to pause game play timer
    function pauseGamePlayTimer(mode, dueToInactivity = false) {
      // Save timer state before pausing
      saveTimerStateToStorage(mode);
      const isClassic = mode === 'classic';

      if (isClassic) {
        if (isGamePlayPausedClassic && !dueToInactivity) return;
        if (gamePlayStartTimeClassic > 0) {
          gamePlayPausedElapsedClassic = Date.now() - gamePlayStartTimeClassic;
          gamePlayPausedTimeClassic = Date.now();
          isGamePlayPausedClassic = true;
          if (dueToInactivity) {
            isInactivityPausedClassic = true;
            console.log("⏸️ Classic timer paused due to inactivity");
          }
          // Timer state will be saved to Firebase via saveClassicGameState
        }
      } else {
        if (isGamePlayPausedTimed && !dueToInactivity) return;
        if (gamePlayStartTimeTimed > 0) {
          gamePlayPausedElapsedTimed = Date.now() - gamePlayStartTimeTimed;
          gamePlayPausedTimeTimed = Date.now();
          isGamePlayPausedTimed = true;
          if (dueToInactivity) {
            isInactivityPausedTimed = true;
            console.log("⏸️ Timed timer paused due to inactivity");
          }
          // Timer state will be saved to Firebase via saveTimedGameState
        }
      }
    }

    // Function to resume game play timer
    function resumeGamePlayTimer(mode) {
      const isClassic = mode === 'classic';

      if (isClassic) {
        if (!isGamePlayPausedClassic) return;
        if (gamePlayPausedElapsedClassic > 0) {
          gamePlayStartTimeClassic = Date.now() - gamePlayPausedElapsedClassic;
          gamePlayPausedElapsedClassic = 0;
          gamePlayPausedTimeClassic = 0;
          isGamePlayPausedClassic = false;
          isInactivityPausedClassic = false; // Clear inactivity flag
          // Timer state will be saved to Firebase via saveClassicGameState
        }
      } else {
        if (!isGamePlayPausedTimed) return;
        if (gamePlayPausedElapsedTimed > 0) {
          gamePlayStartTimeTimed = Date.now() - gamePlayPausedElapsedTimed;
          gamePlayPausedElapsedTimed = 0;
          gamePlayPausedTimeTimed = 0;
          isGamePlayPausedTimed = false;
          isInactivityPausedTimed = false; // Clear inactivity flag
          // Timer state will be saved to Firebase via saveTimedGameState
        }
      }
    }

    // Function to load timer state from persistent storage
    function loadTimerStateFromStorage(mode) {
      const isClassic = mode === 'classic';
      const storageKey = isClassic ? 'blockPuzzle_timerStateClassic' : 'blockPuzzle_timerStateTimed';

      try {
        // Check if SafeStorage is available
        if (typeof SafeStorage === 'undefined' || !SafeStorage.getItem) {
          // Fallback to localStorage directly
          const saved = localStorage.getItem(storageKey);
          if (saved) {
            const state = JSON.parse(saved);
            if (state.startTime > 0) {
              if (isClassic) {
                gamePlayStartTimeClassic = state.startTime;
                gamePlayPausedElapsedClassic = state.pausedElapsed || 0;
                isGamePlayPausedClassic = state.isPaused || false;
                gamePlayPausedTimeClassic = state.pausedTime || 0;
              } else {
                gamePlayStartTimeTimed = state.startTime;
                gamePlayPausedElapsedTimed = state.pausedElapsed || 0;
                isGamePlayPausedTimed = state.isPaused || false;
                gamePlayPausedTimeTimed = state.pausedTime || 0;
              }
              console.log(`✅ ${mode} timer state loaded from storage - startTime:`, state.startTime);
              return true;
            }
          }
        } else {
          const saved = SafeStorage.getItem(storageKey);
          if (saved) {
            const state = JSON.parse(saved);
            if (state.startTime > 0) {
              if (isClassic) {
                gamePlayStartTimeClassic = state.startTime;
                gamePlayPausedElapsedClassic = state.pausedElapsed || 0;
                isGamePlayPausedClassic = state.isPaused || false;
                gamePlayPausedTimeClassic = state.pausedTime || 0;
              } else {
                gamePlayStartTimeTimed = state.startTime;
                gamePlayPausedElapsedTimed = state.pausedElapsed || 0;
                isGamePlayPausedTimed = state.isPaused || false;
                gamePlayPausedTimeTimed = state.pausedTime || 0;
              }
              console.log(`✅ ${mode} timer state loaded from storage - startTime:`, state.startTime);
              return true;
            }
          }
        }
      } catch (e) {
        console.warn(`Failed to load timer state from storage for ${mode}:`, e);
      }
      return false;
    }

    // Function to save timer state to persistent storage
    function saveTimerStateToStorage(mode) {
      const isClassic = mode === 'classic';
      const storageKey = isClassic ? 'blockPuzzle_timerStateClassic' : 'blockPuzzle_timerStateTimed';

      try {
        const state = {
          startTime: isClassic ? gamePlayStartTimeClassic : gamePlayStartTimeTimed,
          pausedElapsed: isClassic ? gamePlayPausedElapsedClassic : gamePlayPausedElapsedTimed,
          isPaused: isClassic ? isGamePlayPausedClassic : isGamePlayPausedTimed,
          pausedTime: isClassic ? gamePlayPausedTimeClassic : gamePlayPausedTimeTimed
        };

        if (state.startTime > 0) {
          // Check if SafeStorage is available
          if (typeof SafeStorage !== 'undefined' && SafeStorage.setItem) {
            SafeStorage.setItem(storageKey, JSON.stringify(state));
          } else {
            // Fallback to localStorage directly
            try {
              localStorage.setItem(storageKey, JSON.stringify(state));
            } catch (e) {
              console.warn(`localStorage unavailable for ${mode} timer state`);
            }
          }
        }
      } catch (e) {
        console.warn(`Failed to save timer state to storage for ${mode}:`, e);
      }
    }

    // Function to start game play timer (automatically starts on first entry, restores from Firebase if exists)
    function startGamePlayTimer(mode) {
      const isClassic = mode === 'classic';

      if (isClassic) {
        clearInterval(gamePlayTimerClassic);

        // IMPORTANT: Timer should NEVER reset once started
        // First, try to load timer state from persistent storage
        if (gamePlayStartTimeClassic === 0) {
          loadTimerStateFromStorage('classic');
        }

        // Only start timer if it was never started before (first time entering game mode)
        // If timer was already started, just resume it if paused, but NEVER reset it
        if (gamePlayStartTimeClassic === 0) {
          // First time entering Classic mode - start timer
          gamePlayStartTimeClassic = Date.now();
          lastActivityTimeClassic = Date.now(); // Initialize activity time
          saveTimerStateToStorage('classic');
          console.log("✅ Classic timer started automatically (first time)");
        } else if (isGamePlayPausedClassic) {
          // Timer was already started but is paused (e.g. user came from home) - do NOT resume
          // Timer will only resume when user clicks Resume button
          lastActivityTimeClassic = Date.now();
          console.log("✅ Classic timer is paused - will run only when user clicks Resume");
        } else {
          // Timer is already running - just update display, don't reset
          console.log("✅ Classic timer already running - continuing from:", gamePlayStartTimeClassic);
          lastActivityTimeClassic = Date.now(); // Update activity time
        }

        // Update timer display immediately
        updateGamePlayTimer('classic');

        // Start update interval
        gamePlayTimerClassic = setInterval(() => {
          // Check if page is hidden or not in focus
          if (document.hidden || !document.hasFocus()) {
            if (!isGamePlayPausedClassic) {
              pauseGamePlayTimer('classic', true);
            }
            return; // Don't update timer if paused
          }

          // Check for inactivity (30 seconds threshold) - only pause if not already paused
          const timeSinceLastActivity = Date.now() - lastActivityTimeClassic;
          if (timeSinceLastActivity > INACTIVITY_THRESHOLD) {
            if (!isGamePlayPausedClassic) {
              pauseGamePlayTimer('classic', true);
            }
            return; // Don't update timer if paused due to inactivity
          }

          // Only update timer if not paused
          if (isGamePlayPausedClassic) {
            return; // Don't update if paused (will be resumed by recordUserActivity when user interacts)
          }

          updateGamePlayTimer('classic');

          // Save timer state periodically to persistent storage and Firebase (every 10 seconds)
          if (Date.now() % 10000 < 1000) {
            saveTimerStateToStorage('classic');
            // Also save to Firebase if user is logged in
            if (typeof currentFirebaseUser !== 'undefined' && currentFirebaseUser && isUserDataLoaded) {
              saveUserDataToFirebase(currentFirebaseUser.uid).catch(err => {
                console.warn('Failed to save timer to Firebase:', err);
              });
            }
          }
        }, 1000);
      } else {
        clearInterval(gamePlayTimerTimed);

        // IMPORTANT: Timer should NEVER reset once started
        // First, try to load timer state from persistent storage
        if (gamePlayStartTimeTimed === 0) {
          loadTimerStateFromStorage('timed');
        }

        // Only start timer if it was never started before (first time entering game mode)
        // If timer was already started, just resume it if paused, but NEVER reset it
        if (gamePlayStartTimeTimed === 0) {
          // First time entering Timed mode - start timer
          gamePlayStartTimeTimed = Date.now();
          lastActivityTimeTimed = Date.now(); // Initialize activity time
          saveTimerStateToStorage('timed');
          console.log("✅ Timed timer started automatically (first time)");
        } else if (isGamePlayPausedTimed) {
          // Timer was already started but is paused (e.g. user came from home) - do NOT resume
          // Timer will only resume when user clicks Resume button
          lastActivityTimeTimed = Date.now();
          console.log("✅ Timed timer is paused - will run only when user clicks Resume");
        } else {
          // Timer is already running - just update display, don't reset
          console.log("✅ Timed timer already running - continuing from:", gamePlayStartTimeTimed);
          lastActivityTimeTimed = Date.now(); // Update activity time
        }

        // Update timer display immediately
        updateGamePlayTimer('timed');

        // Start update interval
        gamePlayTimerTimed = setInterval(() => {
          // Check if page is hidden or not in focus
          if (document.hidden || !document.hasFocus()) {
            if (!isGamePlayPausedTimed) {
              pauseGamePlayTimer('timed', true);
            }
            return; // Don't update timer if paused
          }

          // Check for inactivity (30 seconds threshold) - only pause if not already paused
          const timeSinceLastActivity = Date.now() - lastActivityTimeTimed;
          if (timeSinceLastActivity > INACTIVITY_THRESHOLD) {
            if (!isGamePlayPausedTimed) {
              pauseGamePlayTimer('timed', true);
            }
            return; // Don't update timer if paused due to inactivity
          }

          // Only update timer if not paused
          if (isGamePlayPausedTimed) {
            return; // Don't update if paused (will be resumed by recordUserActivity when user interacts)
          }

          updateGamePlayTimer('timed');

          // Save timer state periodically to persistent storage and Firebase (every 10 seconds)
          if (Date.now() % 10000 < 1000) {
            saveTimerStateToStorage('timed');
            // Also save to Firebase if user is logged in
            if (typeof currentFirebaseUser !== 'undefined' && currentFirebaseUser && isUserDataLoaded) {
              saveUserDataToFirebase(currentFirebaseUser.uid).catch(err => {
                console.warn('Failed to save timer to Firebase:', err);
              });
            }
          }
        }, 1000);
      }

      // Update display immediately
      updateGamePlayTimer(mode);
    }

    // Track last clear timestamps
    let lastClearTimeClassic = 0;
    let lastClearTimeTimed = 0;
    const COMBO_TIME_WINDOW = 12000;
    let comboCountClassic = 0;
    let comboCountTimed = 0;
    let lastPlacedColorClassic = '#fbbf24';
    let lastPlacedColorTimed = '#fbbf24';

    // Undo system variables
    let undoRechargeIntervalClassic = null;
    let undoRechargeIntervalTimed = null;

    // ===== MOBILE OPTIMIZATION - Prevent zoom/pinch on touch =====
    document.addEventListener('touchmove', (e) => {
      if (e.touches.length > 1) {
        e.preventDefault(); // Prevent pinch zoom
      }
    }, { passive: false });

    // Prevent double-tap zoom
    let lastTouchEnd = 0;
    document.addEventListener('touchend', (e) => {
      const now = Date.now();
      if (now - lastTouchEnd <= 300) {
        e.preventDefault();
      }
      lastTouchEnd = now;
    }, false);

    // Prevent page refresh/reload during active gameplay
    window.addEventListener('beforeunload', (e) => {
      // If game is active, save state before page unloads
      if (isGameActive) {
        console.log("⚠️ Page unloading during active game - saving state");
        const classicContainer = document.getElementById('classicContainer');
        const timedContainer = document.getElementById('timedContainer');

        if (classicContainer && classicContainer.style.display !== 'none') {
          saveClassicGameState();
        } else if (timedContainer && timedContainer.style.display !== 'none') {
          saveTimedGameState();
        }
      }
      // Don't prevent the unload, just save state
    });

    document.addEventListener("DOMContentLoaded", () => {
      // Don't start timer on app load - only when player enters game mode

      // ===== NAVIGATION HISTORY AND BACK BUTTON HANDLING =====
      let navigationStack = [];
      let currentScreen = 'home'; // 'home', 'classic', 'timed', 'howToPlay', 'privacyPolicy'

      // Track screen changes
      function pushToNavigationStack(screen) {
        navigationStack.push(currentScreen);
        currentScreen = screen;
        console.log('Navigation stack:', navigationStack, 'Current:', currentScreen);
      }

      function popFromNavigationStack() {
        if (navigationStack.length > 0) {
          const previousScreen = navigationStack.pop();
          currentScreen = previousScreen;
          console.log('Navigation stack:', navigationStack, 'Current:', currentScreen);
          return previousScreen;
        }
        return 'home';
      }

      // Handle back button navigation - returns true if handled, false otherwise
      function handleBackButton() {
        console.log('Back button pressed, current screen:', currentScreen);

        // Check if any modal is open
        const leaderboardModal = document.getElementById('leaderboardModal');
        const achievementListModal = document.getElementById('achievementListModal');
        const soundPopup = document.getElementById('soundPopup');
        const exitConfirmPopup = document.getElementById('exitConfirmPopup');

        if (leaderboardModal && leaderboardModal.style.display === 'block') {
          document.getElementById('closeLeaderboard').click();
          return true;
        }

        if (achievementListModal && achievementListModal.style.display === 'block') {
          document.getElementById('closeAchievementList').click();
          return true;
        }

        if (soundPopup && soundPopup.style.display === 'block') {
          document.getElementById('closeSoundPopup').click();
          return true;
        }

        if (exitConfirmPopup && exitConfirmPopup.style.display !== 'none' && !exitConfirmPopup.classList.contains('user-stats-hidden')) {
          // Hide exit popup
          exitConfirmPopup.style.display = 'none';
          exitConfirmPopup.classList.add('user-stats-hidden');
          return true;
        }

        // Handle info pages
        const howToPlayPage = document.getElementById('howToPlayPage');
        const privacyPolicyPage = document.getElementById('privacyPolicyPage');

        if (howToPlayPage && !howToPlayPage.classList.contains('user-stats-hidden')) {
          hideInfoPage('howToPlayPage');
          popFromNavigationStack();
          return true;
        }

        if (privacyPolicyPage && !privacyPolicyPage.classList.contains('user-stats-hidden')) {
          hideInfoPage('privacyPolicyPage');
          popFromNavigationStack();
          return true;
        }

        // Handle game screens
        const classicContainer = document.getElementById('classicContainer');
        const timedContainer = document.getElementById('timedContainer');

        if (classicContainer && classicContainer.style.display !== 'none') {
          // Check if pause popup is open
          const pausePopup = document.getElementById('pausePopupClassic');
          if (pausePopup && pausePopup.style.display !== 'none') {
            hidePausePopup('classic');
            return true;
          }

          // Check if game over popup is open
          const gameOver = document.getElementById('gameOverClassic');
          if (gameOver && gameOver.style.display !== 'none') {
            // Close game over and go to home
            gameOver.style.display = 'none';
            transitionToScreen('classicContainer', 'homeScreen');
            popFromNavigationStack();
            return true;
          }

          // Go to home from classic game
          // Note: goHomeClassicBtn handler will call popFromNavigationStack()
          document.getElementById('goHomeClassicBtn').click();
          return true;
        }

        if (timedContainer && timedContainer.style.display !== 'none') {
          // Check if pause popup is open
          const pausePopup = document.getElementById('pausePopupTimed');
          if (pausePopup && pausePopup.style.display !== 'none') {
            hidePausePopup('timed');
            return true;
          }

          // Check if game over popup is open
          const gameOver = document.getElementById('gameOverTimed');
          if (gameOver && gameOver.style.display !== 'none') {
            // Close game over and go to home
            gameOver.style.display = 'none';
            transitionToScreen('timedContainer', 'homeScreen');
            popFromNavigationStack();
            return true;
          }

          // Go to home from timed game
          // Note: goHomeTimedBtn handler will call popFromNavigationStack()
          document.getElementById('goHomeTimedBtn').click();
          return true;
        }

        // If on home screen: Android = show exit popup; Web = go back to site home
        const homeScreen = document.getElementById('homeScreen');
        if (homeScreen && homeScreen.style.display !== 'none') {
          // Show exit popup ONLY in Android WebView (window.Android). Never in web browser.
          const isAndroidApp = !!(typeof window !== 'undefined' && window.Android);
          if (isAndroidApp) {
            showExitConfirmation();
            return true;
          }
          // Web browser (desktop/mobile browser): back button = go to website home (history)
          if (window.history && window.history.length > 1) {
            window.history.back();
          }
          return false;
        }

        return false;
      }

      // Show exit confirmation popup
      function showExitConfirmation() {
        const exitPopup = document.getElementById('exitConfirmPopup');
        if (exitPopup) {
          exitPopup.style.display = 'block';
          exitPopup.classList.remove('user-stats-hidden');
        }
      }

      // Hide exit confirmation popup
      function hideExitConfirmation() {
        const exitPopup = document.getElementById('exitConfirmPopup');
        if (exitPopup) {
          exitPopup.style.display = 'none';
          exitPopup.classList.add('user-stats-hidden');
        }
      }

      // Make handleBackButton available globally for Android to call
      window.handleBackButton = handleBackButton;

      // Handle browser back button (popstate event)
      window.addEventListener('popstate', (e) => {
        console.log('Browser back button/popstate event');
        const isAndroidApp = !!(typeof window !== 'undefined' && window.Android);
        const handled = handleBackButton();
        if (!handled && isAndroidApp) {
          // Android WebView only: prevent default navigation if not handled
          e.preventDefault();
        }
        // Web browser: allow default (back goes to previous page / site home)
      });

      // Push initial state to history
      if (window.history && window.history.pushState) {
        window.history.pushState({ screen: 'home' }, '', window.location.href);
      }

      // ===== IMMEDIATE POPUP PROTECTION =====
      // Hide achievement popup immediately on page load
      setTimeout(() => {
        const achievementPopup = document.getElementById('achievementPopup');
        if (achievementPopup) {
          achievementPopup.style.display = 'none';
          achievementPopup.classList.add('user-stats-hidden');
          console.log("Achievement popup immediately hidden on DOM load");
        }
      }, 50);

      // ===== AUTO-PAUSE AND STATE PERSISTENCE =====

      // Periodic check to force hide unwanted game over popups
      // Reduced frequency to prevent performance issues
      setInterval(() => {
        forceHideGameOverIfNeeded();
      }, 2000); // Check every 2 seconds (reduced from 500ms)

      // ===== AUTO-PAUSE SYSTEM - Re-enabled for tab switching and minimizing =====
      // Auto-pause when page becomes hidden (tab switch, minimize, etc.)
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          // Only auto-pause if game is active and not already manually paused
          if (isGameActive && !isManuallyPaused && !isGameRestoring) {
            console.log("📱 Page hidden - auto-pausing game and saving state");
            autoPauseCurrentGame();
          }
          // Pause timers when page is hidden
          const classicContainer = document.getElementById('classicContainer');
          const timedContainer = document.getElementById('timedContainer');
          if (classicContainer && classicContainer.style.display !== 'none' && gamePlayStartTimeClassic > 0 && !isGamePlayPausedClassic) {
            pauseGamePlayTimer('classic', true);
            console.log("⏸️ Classic timer paused - page hidden");
          }
          if (timedContainer && timedContainer.style.display !== 'none' && gamePlayStartTimeTimed > 0 && !isGamePlayPausedTimed) {
            pauseGamePlayTimer('timed', true);
            console.log("⏸️ Timed timer paused - page hidden");
          }
        } else {
          // Page became visible again - don't auto-resume, let user click Resume button
          console.log("📱 Page visible again - game remains paused until user resumes");
          // Update activity time when page becomes visible (user might interact)
          const classicContainer = document.getElementById('classicContainer');
          const timedContainer = document.getElementById('timedContainer');
          if (classicContainer && classicContainer.style.display !== 'none') {
            lastActivityTimeClassic = Date.now();
          }
          if (timedContainer && timedContainer.style.display !== 'none') {
            lastActivityTimeTimed = Date.now();
          }
        }
      });

      // Auto-pause on window blur (when app loses focus)
      window.addEventListener('blur', () => {
        if (isGameActive && !isManuallyPaused && !isGameRestoring) {
          console.log("📱 Window lost focus - auto-pausing game");
          autoPauseCurrentGame();
        }
        // Pause timers when window loses focus
        const classicContainer = document.getElementById('classicContainer');
        const timedContainer = document.getElementById('timedContainer');
        if (classicContainer && classicContainer.style.display !== 'none' && gamePlayStartTimeClassic > 0 && !isGamePlayPausedClassic) {
          pauseGamePlayTimer('classic', true);
          console.log("⏸️ Classic timer paused - window lost focus");
        }
        if (timedContainer && timedContainer.style.display !== 'none' && gamePlayStartTimeTimed > 0 && !isGamePlayPausedTimed) {
          pauseGamePlayTimer('timed', true);
          console.log("⏸️ Timed timer paused - window lost focus");
        }
      });

      // Activity tracking for timer pause on inactivity
      function setupActivityTracking() {
        // Determine current game mode
        function getCurrentMode() {
          const classicContainer = document.getElementById('classicContainer');
          const timedContainer = document.getElementById('timedContainer');
          if (classicContainer && classicContainer.style.display !== 'none') {
            return 'classic';
          } else if (timedContainer && timedContainer.style.display !== 'none') {
            return 'timed';
          }
          return null;
        }

        // Track mouse activity
        document.addEventListener('mousedown', () => {
          const mode = getCurrentMode();
          if (mode) recordUserActivity(mode);
        });
        document.addEventListener('mousemove', () => {
          const mode = getCurrentMode();
          if (mode) recordUserActivity(mode);
        });
        document.addEventListener('mouseup', () => {
          const mode = getCurrentMode();
          if (mode) recordUserActivity(mode);
        });

        // Track touch activity
        document.addEventListener('touchstart', () => {
          const mode = getCurrentMode();
          if (mode) recordUserActivity(mode);
        });
        document.addEventListener('touchmove', () => {
          const mode = getCurrentMode();
          if (mode) recordUserActivity(mode);
        });
        document.addEventListener('touchend', () => {
          const mode = getCurrentMode();
          if (mode) recordUserActivity(mode);
        });

        // Track keyboard activity
        document.addEventListener('keydown', () => {
          const mode = getCurrentMode();
          if (mode) recordUserActivity(mode);
        });
        document.addEventListener('keyup', () => {
          const mode = getCurrentMode();
          if (mode) recordUserActivity(mode);
        });

        console.log("✅ Activity tracking ENABLED for timer pause on inactivity");
      }

      // Initialize activity tracking
      setupActivityTracking();

      // Save game state before page unloads
      window.addEventListener('beforeunload', () => {
        if (isGameActive) {
          console.log("📱 Page unloading - saving game state");
          autoPauseCurrentGame();
        }
      });

      console.log("✅ Auto-pause system ENABLED for tab switching and minimizing");

      // Periodic backup save (every 10 seconds) - saves to Firebase only
      // This ensures data is saved even if page refreshes unexpectedly
      setInterval(() => {
        if (isGameActive && !isGameRestoring) {
          const classicContainer = document.getElementById('classicContainer');
          const timedContainer = document.getElementById('timedContainer');

          if (classicContainer && classicContainer.style.display !== 'none') {
            saveClassicGameState();
          } else if (timedContainer && timedContainer.style.display !== 'none') {
            saveTimedGameState();
          }
        }
      }, 10000); // Save every 10 seconds to Firebase

      // ===== FIREBASE USER MANAGEMENT =====
      let currentFirebaseUser = null;
      let isUserDataLoaded = false;

      // ===== SESSION TIME TRACKING =====
      let sessionStartTime = null;
      let isGameSessionActive = false;

      // Save session time when returning to home
      function endGameSession() {
        if (isGameSessionActive && sessionStartTime) {
          const sessionDuration = Math.floor((Date.now() - sessionStartTime) / 1000); // in seconds
          userData.gameStats.totalTime += sessionDuration;
          console.log(`Session ended. Duration: ${sessionDuration}s, Total: ${userData.gameStats.totalTime}s`);

          // Save to Firebase only
          if (currentFirebaseUser) {
            saveUserDataToFirebase(currentFirebaseUser.uid);
          }

          // Reset session tracking
          sessionStartTime = null;
          isGameSessionActive = false;
        }
      }

      // ===== SAFE STORAGE WRAPPER (Works in Flutter WebView) =====
      const SafeStorage = {
        // In-memory fallback storage
        _memoryStore: {},

        // Get current user ID for prefixing keys
        _getUserPrefix: function () {
          try {
            const user = window.firebaseAuth?.currentUser;
            return user ? `user_${user.uid}_` : 'guest_';
          } catch (error) {
            return 'guest_';
          }
        },

        // Try localStorage first, fall back to memory (with user-specific keys)
        setItem: function (key, value) {
          const userKey = this._getUserPrefix() + key;
          try {
            localStorage.setItem(userKey, value);
          } catch (error) {
            // localStorage failed (WebView), use memory storage
            this._memoryStore[userKey] = value;
            console.warn('localStorage unavailable, using memory storage for:', userKey);
          }
        },

        getItem: function (key) {
          const userKey = this._getUserPrefix() + key;
          try {
            return localStorage.getItem(userKey);
          } catch (error) {
            // localStorage failed (WebView), use memory storage
            return this._memoryStore[userKey] || null;
          }
        },

        removeItem: function (key) {
          const userKey = this._getUserPrefix() + key;
          try {
            localStorage.removeItem(userKey);
          } catch (error) {
            // localStorage failed (WebView), use memory storage
            delete this._memoryStore[userKey];
          }
        },

        clear: function () {
          try {
            localStorage.clear();
          } catch (error) {
            // localStorage failed (WebView), use memory storage
            this._memoryStore = {};
          }
        },

        // Clear all data for current user only
        clearUserData: function () {
          const prefix = this._getUserPrefix();
          try {
            // Clear localStorage items with user prefix
            const keysToRemove = [];
            for (let i = 0; i < localStorage.length; i++) {
              const key = localStorage.key(i);
              if (key && key.startsWith(prefix)) {
                keysToRemove.push(key);
              }
            }
            keysToRemove.forEach(key => localStorage.removeItem(key));

            // Clear memory store items with user prefix
            Object.keys(this._memoryStore).forEach(key => {
              if (key.startsWith(prefix)) {
                delete this._memoryStore[key];
              }
            });

            console.log(`Cleared all data for user prefix: ${prefix}`);
          } catch (error) {
            console.error('Error clearing user data:', error);
          }
        }
      };

      // ===== RESTORE MANUAL PAUSE STATUS ON PAGE LOAD =====
      // Restore manual pause status that was saved before page reload
      // (SafeStorage is now initialized, so this is safe to call)
      try {
        // Check if manual pause status exists and restore it
        const data = SafeStorage.getItem('blockPuzzle_manualPauseStatus');
        if (data) {
          const status = JSON.parse(data);
          if (status.isManuallyPaused) {
            console.log("Restoring manual pause status from previous session");
            isManuallyPaused = true;
          }
        }
      } catch (error) {
        console.error("Error restoring manual pause status:", error);
      }

      // User Data Structure
      const defaultUserData = {
        profile: {
          displayName: '',
          email: '',
          country: '',
          createdAt: null,           // Unix timestamp in milliseconds
          createdAtReadable: '',      // Readable format: "Nov 28, 2025 11:30:02 PM IST"
          lastLogin: null,
          accountMode: 'guest'
        },
        gameStats: {
          highScore: 0,
          classicHighScore: 0,
          timedHighScore: 0,
          totalGames: 0,
          totalTime: 0,
          bestLines: 0,
          currentLevel: 1
        },
        gamePlayTimers: {
          classic: {
            startTime: '',           // Readable format: "Nov 28, 2025 11:23:57 PM IST"
            startTimeMs: 0,          // Unix timestamp in milliseconds (for calculations)
            pausedElapsed: '00:00:00:00',  // Readable format: "DD:HH:MM:SS"
            pausedElapsedMs: 0,      // Elapsed time in milliseconds (for calculations)
            isPaused: false,
            pausedTime: '',           // Readable format: "Nov 28, 2025 11:30:02 PM IST"
            pausedTimeMs: 0          // Unix timestamp in milliseconds (for calculations)
          },
          timed: {
            startTime: '',           // Readable format: "Nov 28, 2025 11:23:57 PM IST"
            startTimeMs: 0,          // Unix timestamp in milliseconds (for calculations)
            pausedElapsed: '00:00:00:00',  // Readable format: "DD:HH:MM:SS"
            pausedElapsedMs: 0,      // Elapsed time in milliseconds (for calculations)
            isPaused: false,
            pausedTime: '',           // Readable format: "Nov 28, 2025 11:30:02 PM IST"
            pausedTimeMs: 0          // Unix timestamp in milliseconds (for calculations)
          }
        },
        achievements: {
          // Classic Score Milestones (15 levels)
          scoreClassic5000: false,
          scoreClassic9000: false,
          scoreClassic18000: false,
          scoreClassic27000: false,
          scoreClassic36000: false,
          scoreClassic45000: false,
          scoreClassic54000: false,
          scoreClassic63000: false,
          scoreClassic81000: false,
          scoreClassic108000: false,
          scoreClassic163000: false,
          scoreClassic252000: false,
          scoreClassic504000: false,
          scoreClassic756000: false,
          scoreClassic1100000: false,

          // Timed Score Milestones (15 levels)
          scoreTimed5000: false,
          scoreTimed9000: false,
          scoreTimed18000: false,
          scoreTimed27000: false,
          scoreTimed36000: false,
          scoreTimed45000: false,
          scoreTimed54000: false,
          scoreTimed63000: false,
          scoreTimed81000: false,
          scoreTimed108000: false,
          scoreTimed163000: false,
          scoreTimed252000: false,
          scoreTimed504000: false,
          scoreTimed756000: false,
          scoreTimed1100000: false,

          // Classic Line Clear Milestones (15 levels)
          linesClassic50: false,
          linesClassic100: false,
          linesClassic175: false,
          linesClassic250: false,
          linesClassic375: false,
          linesClassic500: false,
          linesClassic750: false,
          linesClassic1250: false,
          linesClassic2000: false,
          linesClassic2750: false,
          linesClassic3750: false,
          linesClassic5000: false,
          linesClassic6250: false,
          linesClassic7500: false,
          linesClassic10000: false,

          // Timed Line Clear Milestones (15 levels)
          linesTimed50: false,
          linesTimed100: false,
          linesTimed175: false,
          linesTimed250: false,
          linesTimed375: false,
          linesTimed500: false,
          linesTimed750: false,
          linesTimed1250: false,
          linesTimed2000: false,
          linesTimed2750: false,
          linesTimed3750: false,
          linesTimed5000: false,
          linesTimed6250: false,
          linesTimed7500: false,
          linesTimed10000: false,

          // Timed Mode - Extra Time (15 levels)
          extraTime500: false,
          extraTime800: false,
          extraTime1100: false,
          extraTime1400: false,
          extraTime1700: false,
          extraTime2000: false,
          extraTime2400: false,
          extraTime2800: false,
          extraTime3200: false,
          extraTime4000: false,
          extraTime5000: false,
          extraTime6000: false,
          extraTime8000: false,
          extraTime10000: false,
          extraTime12000: false
        },
        settings: {
          sound: true,
          vibration: true,
          theme: 'default',
          language: 'en'
        }
      };

      // Current user data (merged with defaults)
      let userData = { ...defaultUserData };

      // Auth modal elements & state
      const authModal = document.getElementById('authModal');
      const authCloseBtn = document.getElementById('authCloseBtn');
      const authForm = document.getElementById('authForm');
      const authDisplayNameInput = document.getElementById('authDisplayName');
      const authEmailInput = document.getElementById('authEmail');
      const authPasswordInput = document.getElementById('authPassword');
      const authConfirmPasswordInput = document.getElementById('authConfirmPassword');
      const authCountryInput = document.getElementById('authCountry');
      const authSubmitBtn = document.getElementById('authSubmitBtn');
      const authModalTitle = document.getElementById('authModalTitle');
      const authModalMessage = document.getElementById('authModalMessage');
      const authErrorBox = document.getElementById('authError');
      const authMessageBox = document.getElementById('authMessage');
      const authSwitchModeBtn = document.getElementById('switchAuthModeBtn');
      const displayNameGroup = document.getElementById('displayNameGroup');
      const confirmPasswordGroup = document.getElementById('confirmPasswordGroup');
      const authForgotPasswordBtn = document.getElementById('authForgotPasswordBtn');
      // Welcome modal and old auth buttons removed - using auto anonymous auth
      const userStatsDisplay = document.getElementById('userStatsDisplay');
      const syncStatusIcon = document.getElementById('syncStatusIcon');
      const deleteAccountBtn = document.getElementById('deleteAccountBtn');
      const deleteAccountModal = document.getElementById('deleteAccountModal');
      const confirmDeleteBtn = document.getElementById('confirmDeleteBtn');
      const cancelDeleteBtn = document.getElementById('cancelDeleteBtn');
      const loadingPopup = document.getElementById('loadingPopup');

      const ACCOUNT_MODE_KEY = 'blockPuzzleAccountMode';
      const GUEST_ID_KEY = 'blockPuzzleGuestId';
      const GAME_STATE_KEY = 'blockPuzzleGameState';
      const LOCAL_USERS_DB_KEY = 'blockPuzzleUsersDB'; // New: Local users database
      const CURRENT_USER_KEY = 'blockPuzzleCurrentUser'; // New: Currently logged in user

      let authModalMode = 'signup'; // 'signup', 'upgrade', 'login'
      let enforceWelcomeUntilAuth = true; // Always show welcome modal on load
      const USER_STATS_SIZE_KEY = 'blockPuzzleUserStatsSize';

      // ===== LOCAL USER DATABASE SYSTEM =====
      const LocalUserDB = {
        // Get all users from localStorage
        getAllUsers: function () {
          try {
            const data = localStorage.getItem(LOCAL_USERS_DB_KEY);
            return data ? JSON.parse(data) : [];
          } catch (error) {
            console.error('Error reading users DB:', error);
            return [];
          }
        },

        // Save all users to localStorage
        saveAllUsers: function (users) {
          try {
            localStorage.setItem(LOCAL_USERS_DB_KEY, JSON.stringify(users));
            return true;
          } catch (error) {
            console.error('Error saving users DB:', error);
            return false;
          }
        },

        // Find user by username (guest) or email
        findUser: function (identifier, type = 'guest') {
          const users = this.getAllUsers();
          if (type === 'guest') {
            return users.find(u => u.type === 'guest' && u.username === identifier);
          } else {
            return users.find(u => u.type === 'email' && u.email === identifier);
          }
        },

        // Find user by ID
        findUserById: function (userId) {
          const users = this.getAllUsers();
          return users.find(u => u.id === userId);
        },

        // Create new guest user
        createGuestUser: function (username, password, firebaseUid = null) {
          const users = this.getAllUsers();

          // Check if username already exists
          if (this.findUser(username, 'guest')) {
            return { success: false, error: 'Username already exists' };
          }

          const newUser = {
            id: 'guest_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
            type: 'guest',
            username: username,
            password: password, // In production, hash this!
            firebaseUid: firebaseUid, // Store Firebase UID immediately
            createdAt: Date.now(),
            createdAtReadable: formatTimestampForFirebase(Date.now()),
            lastLogin: Date.now(),
            userData: JSON.parse(JSON.stringify(defaultUserData))
          };

          newUser.userData.profile.displayName = username;
          newUser.userData.profile.accountMode = 'guest';

          users.push(newUser);
          this.saveAllUsers(users);

          return { success: true, user: newUser };
        },

        // Verify guest login
        verifyGuestLogin: function (username, password) {
          const user = this.findUser(username, 'guest');
          if (!user) {
            return { success: false, error: 'Username not found' };
          }
          if (user.password !== password) {
            return { success: false, error: 'Incorrect password' };
          }

          // Update last login
          user.lastLogin = Date.now();
          const users = this.getAllUsers();
          const index = users.findIndex(u => u.id === user.id);
          if (index !== -1) {
            users[index] = user;
            this.saveAllUsers(users);
          }

          return { success: true, user: user };
        },

        // Update user data
        updateUserData: function (userId, newUserData) {
          const users = this.getAllUsers();
          const index = users.findIndex(u => u.id === userId);
          if (index === -1) return false;

          users[index].userData = newUserData;
          users[index].lastLogin = Date.now();
          this.saveAllUsers(users);
          return true;
        },

        // Delete user
        deleteUser: function (userId) {
          const users = this.getAllUsers();
          const filtered = users.filter(u => u.id !== userId);
          this.saveAllUsers(filtered);
          return true;
        },

        // Get current logged-in user
        getCurrentUser: function () {
          try {
            const data = localStorage.getItem(CURRENT_USER_KEY);
            return data ? JSON.parse(data) : null;
          } catch (error) {
            return null;
          }
        },

        // Set current logged-in user
        setCurrentUser: function (user) {
          try {
            if (user) {
              localStorage.setItem(CURRENT_USER_KEY, JSON.stringify({
                id: user.id,
                type: user.type,
                username: user.username || user.email,
                loginTime: Date.now()
              }));
            } else {
              localStorage.removeItem(CURRENT_USER_KEY);
            }
            return true;
          } catch (error) {
            console.error('Error setting current user:', error);
            return false;
          }
        },

        // Clear current user (logout)
        clearCurrentUser: function () {
          localStorage.removeItem(CURRENT_USER_KEY);
        },

        // Find user by username (helper function)
        findUserByUsername: function (username) {
          const users = this.getAllUsers();
          return users.find(u => u.username === username && u.type === 'guest');
        }
      };

      // Apply saved size for user stats card (if any)
      function applySavedUserStatsSize() {
        try {
          const raw = localStorage.getItem(USER_STATS_SIZE_KEY);
          if (!raw) return;
          const parsed = JSON.parse(raw);
          if (!parsed) return;
          const { width, height } = parsed;
          if (userStatsDisplay) {
            if (Number.isFinite(width)) userStatsDisplay.style.width = `${width}px`;
            if (Number.isFinite(height)) userStatsDisplay.style.height = `${height}px`;
          }
        } catch (e) {
          console.warn('Failed to apply saved user stats size:', e);
        }
      }

      applySavedUserStatsSize();

      // Observe size changes and persist them
      if (window.ResizeObserver && userStatsDisplay) {
        let saveTimer = null;
        const ro = new ResizeObserver((entries) => {
          for (const entry of entries) {
            if (entry.target !== userStatsDisplay) continue;
            const rect = entry.target.getBoundingClientRect();
            const size = { width: Math.round(rect.width), height: Math.round(rect.height) };
            try {
              // debounce a little to avoid thrashing
              if (saveTimer) clearTimeout(saveTimer);
              saveTimer = setTimeout(() => {
                localStorage.setItem(USER_STATS_SIZE_KEY, JSON.stringify(size));
              }, 150);
            } catch (e) {
              console.warn('Failed to persist user stats size:', e);
            }
          }
        });
        ro.observe(userStatsDisplay);
      }

      // ===== COUNTRY DATA & PICKER =====
      const countryData = [
        { code: "", name: "🌍 Global" },
        { code: "other", name: "🌐 Other" },
        { code: "af", name: "Afghanistan" },
        { code: "al", name: "Albania" },
        { code: "dz", name: "Algeria" },
        { code: "as", name: "American Samoa" },
        { code: "ad", name: "Andorra" },
        { code: "ao", name: "Angola" },
        { code: "ai", name: "Anguilla" },
        { code: "aq", name: "Antarctica" },
        { code: "ag", name: "Antigua and Barbuda" },
        { code: "ar", name: "Argentina" },
        { code: "am", name: "Armenia" },
        { code: "aw", name: "Aruba" },
        { code: "ac", name: "Ascension Island" },
        { code: "au", name: "Australia" },
        { code: "at", name: "Austria" },
        { code: "az", name: "Azerbaijan" },
        { code: "bs", name: "Bahamas" },
        { code: "bh", name: "Bahrain" },
        { code: "bd", name: "Bangladesh" },
        { code: "bb", name: "Barbados" },
        { code: "by", name: "Belarus" },
        { code: "be", name: "Belgium" },
        { code: "bz", name: "Belize" },
        { code: "bj", name: "Benin" },
        { code: "bm", name: "Bermuda" },
        { code: "bt", name: "Bhutan" },
        { code: "bo", name: "Bolivia" },
        { code: "ba", name: "Bosnia and Herzegovina" },
        { code: "bw", name: "Botswana" },
        { code: "br", name: "Brazil" },
        { code: "vg", name: "British Virgin Islands" },
        { code: "bn", name: "Brunei" },
        { code: "bg", name: "Bulgaria" },
        { code: "bf", name: "Burkina Faso" },
        { code: "mm", name: "Burma (Myanmar)" },
        { code: "bi", name: "Burundi" },
        { code: "kh", name: "Cambodia" },
        { code: "cm", name: "Cameroon" },
        { code: "ca", name: "Canada" },
        { code: "cv", name: "Cape Verde" },
        { code: "ky", name: "Cayman Islands" },
        { code: "cf", name: "Central African Republic" },
        { code: "td", name: "Chad" },
        { code: "cl", name: "Chile" },
        { code: "cn", name: "China" },
        { code: "cx", name: "Christmas Island" },
        { code: "cc", name: "Cocos (Keeling) Islands" },
        { code: "co", name: "Colombia" },
        { code: "km", name: "Comoros" },
        { code: "cg", name: "Congo" },
        { code: "ck", name: "Cook Islands" },
        { code: "cr", name: "Costa Rica" },
        { code: "hr", name: "Croatia" },
        { code: "cu", name: "Cuba" },
        { code: "cy", name: "Cyprus" },
        { code: "cz", name: "Czech Republic" },
        { code: "cd", name: "Democratic Republic of the Congo" },
        { code: "dk", name: "Denmark" },
        { code: "dg", name: "Diego Garcia" },
        { code: "dj", name: "Djibouti" },
        { code: "dm", name: "Dominica" },
        { code: "do", name: "Dominican Republic" },
        { code: "ec", name: "Ecuador" },
        { code: "eg", name: "Egypt" },
        { code: "sv", name: "El Salvador" },
        { code: "gq", name: "Equatorial Guinea" },
        { code: "er", name: "Eritrea" },
        { code: "ee", name: "Estonia" },
        { code: "et", name: "Ethiopia" },
        { code: "fk", name: "Falkland Islands" },
        { code: "fo", name: "Faroe Islands" },
        { code: "fj", name: "Fiji" },
        { code: "fi", name: "Finland" },
        { code: "fr", name: "France" },
        { code: "gf", name: "French Guiana" },
        { code: "pf", name: "French Polynesia" },
        { code: "ga", name: "Gabon" },
        { code: "gm", name: "Gambia" },
        { code: "ge", name: "Georgia" },
        { code: "de", name: "Germany" },
        { code: "gh", name: "Ghana" },
        { code: "gi", name: "Gibraltar" },
        { code: "gr", name: "Greece" },
        { code: "gl", name: "Greenland" },
        { code: "gd", name: "Grenada" },
        { code: "gp", name: "Guadeloupe" },
        { code: "gu", name: "Guam" },
        { code: "gt", name: "Guatemala" },
        { code: "gn", name: "Guinea" },
        { code: "gw", name: "Guinea-Bissau" },
        { code: "gy", name: "Guyana" },
        { code: "ht", name: "Haiti" },
        { code: "va", name: "Holy See (Vatican City)" },
        { code: "hn", name: "Honduras" },
        { code: "hk", name: "Hong Kong" },
        { code: "hu", name: "Hungary" },
        { code: "is", name: "Iceland" },
        { code: "in", name: "India" },
        { code: "id", name: "Indonesia" },
        { code: "ir", name: "Iran" },
        { code: "iq", name: "Iraq" },
        { code: "ie", name: "Ireland" },
        { code: "im", name: "Isle of Man" },
        { code: "il", name: "Israel" },
        { code: "it", name: "Italy" },
        { code: "ci", name: "Ivory Coast (Côte d'Ivoire)" },
        { code: "jm", name: "Jamaica" },
        { code: "jp", name: "Japan" },
        { code: "je", name: "Jersey" },
        { code: "jo", name: "Jordan" },
        { code: "kz", name: "Kazakhstan" },
        { code: "ke", name: "Kenya" },
        { code: "ki", name: "Kiribati" },
        { code: "kw", name: "Kuwait" },
        { code: "kg", name: "Kyrgyzstan" },
        { code: "la", name: "Laos" },
        { code: "lv", name: "Latvia" },
        { code: "lb", name: "Lebanon" },
        { code: "ls", name: "Lesotho" },
        { code: "lr", name: "Liberia" },
        { code: "ly", name: "Libya" },
        { code: "li", name: "Liechtenstein" },
        { code: "lt", name: "Lithuania" },
        { code: "lu", name: "Luxembourg" },
        { code: "mo", name: "Macau" },
        { code: "mk", name: "Macedonia" },
        { code: "mg", name: "Madagascar" },
        { code: "mw", name: "Malawi" },
        { code: "my", name: "Malaysia" },
        { code: "mv", name: "Maldives" },
        { code: "ml", name: "Mali" },
        { code: "mt", name: "Malta" },
        { code: "mh", name: "Marshall Islands" },
        { code: "mq", name: "Martinique" },
        { code: "mr", name: "Mauritania" },
        { code: "mu", name: "Mauritius" },
        { code: "yt", name: "Mayotte" },
        { code: "mx", name: "Mexico" },
        { code: "fm", name: "Micronesia" },
        { code: "md", name: "Moldova" },
        { code: "mc", name: "Monaco" },
        { code: "mn", name: "Mongolia" },
        { code: "me", name: "Montenegro" },
        { code: "ms", name: "Montserrat" },
        { code: "ma", name: "Morocco" },
        { code: "mz", name: "Mozambique" },
        { code: "na", name: "Namibia" },
        { code: "nr", name: "Nauru" },
        { code: "np", name: "Nepal" },
        { code: "nl", name: "Netherlands" },
        { code: "an", name: "Netherlands Antilles" },
        { code: "nc", name: "New Caledonia" },
        { code: "nz", name: "New Zealand" },
        { code: "ni", name: "Nicaragua" },
        { code: "ne", name: "Niger" },
        { code: "ng", name: "Nigeria" },
        { code: "nu", name: "Niue" },
        { code: "nf", name: "Norfolk Island" },
        { code: "kp", name: "North Korea" },
        { code: "mp", name: "Northern Mariana Islands" },
        { code: "no", name: "Norway" },
        { code: "om", name: "Oman" },
        { code: "pk", name: "Pakistan" },
        { code: "pw", name: "Palau" },
        { code: "ps", name: "Palestine" },
        { code: "pa", name: "Panama" },
        { code: "pg", name: "Papua New Guinea" },
        { code: "py", name: "Paraguay" },
        { code: "pe", name: "Peru" },
        { code: "ph", name: "Philippines" },
        { code: "pn", name: "Pitcairn Islands" },
        { code: "pl", name: "Poland" },
        { code: "pt", name: "Portugal" },
        { code: "pr", name: "Puerto Rico" },
        { code: "qa", name: "Qatar" },
        { code: "re", name: "Reunion Island" },
        { code: "ro", name: "Romania" },
        { code: "ru", name: "Russia" },
        { code: "rw", name: "Rwanda" },
        { code: "bl", name: "Saint Barthelemy" },
        { code: "sh", name: "Saint Helena" },
        { code: "kn", name: "Saint Kitts and Nevis" },
        { code: "lc", name: "Saint Lucia" },
        { code: "mf", name: "Saint Martin" },
        { code: "pm", name: "Saint Pierre and Miquelon" },
        { code: "vc", name: "Saint Vincent and the Grenadines" },
        { code: "ws", name: "Samoa" },
        { code: "sm", name: "San Marino" },
        { code: "st", name: "Sao Tome and Principe" },
        { code: "sa", name: "Saudi Arabia" },
        { code: "sn", name: "Senegal" },
        { code: "rs", name: "Serbia" },
        { code: "sc", name: "Seychelles" },
        { code: "sl", name: "Sierra Leone" },
        { code: "sg", name: "Singapore" },
        { code: "sx", name: "Sint Maarten" },
        { code: "sk", name: "Slovakia" },
        { code: "si", name: "Slovenia" },
        { code: "sb", name: "Solomon Islands" },
        { code: "so", name: "Somalia" },
        { code: "za", name: "South Africa" },
        { code: "kr", name: "South Korea" },
        { code: "ss", name: "South Sudan" },
        { code: "es", name: "Spain" },
        { code: "lk", name: "Sri Lanka" },
        { code: "sd", name: "Sudan" },
        { code: "sr", name: "Suriname" },
        { code: "sj", name: "Svalbard" },
        { code: "sz", name: "Swaziland" },
        { code: "se", name: "Sweden" },
        { code: "ch", name: "Switzerland" },
        { code: "sy", name: "Syria" },
        { code: "tw", name: "Taiwan" },
        { code: "tj", name: "Tajikistan" },
        { code: "tz", name: "Tanzania" },
        { code: "th", name: "Thailand" },
        { code: "tl", name: "Timor-Leste (East Timor)" },
        { code: "tg", name: "Togo" },
        { code: "tk", name: "Tokelau" },
        { code: "to", name: "Tonga Islands" },
        { code: "tt", name: "Trinidad and Tobago" },
        { code: "tn", name: "Tunisia" },
        { code: "tr", name: "Turkey" },
        { code: "tm", name: "Turkmenistan" },
        { code: "tc", name: "Turks and Caicos Islands" },
        { code: "tv", name: "Tuvalu" },
        { code: "ug", name: "Uganda" },
        { code: "ua", name: "Ukraine" },
        { code: "ae", name: "United Arab Emirates" },
        { code: "gb", name: "United Kingdom" },
        { code: "us", name: "United States" },
        { code: "uy", name: "Uruguay" },
        { code: "vi", name: "US Virgin Islands" },
        { code: "uz", name: "Uzbekistan" },
        { code: "vu", name: "Vanuatu" },
        { code: "ve", name: "Venezuela" },
        { code: "vn", name: "Vietnam" },
        { code: "wf", name: "Wallis and Futuna" },
        { code: "eh", name: "Western Sahara" },
        { code: "ye", name: "Yemen" },
        { code: "zm", name: "Zambia" },
        { code: "zw", name: "Zimbabwe" }
      ];

      function getFlagEmoji(countryCode) {
        if (!countryCode) return '—';
        const code = countryCode.toUpperCase();
        if (code === 'OTHER') return '🌐';
        // Simple fallback for invalid codes
        if (code.length !== 2) return '—';
        // Offset between ASCII 'A' and regional indicator symbol 'A'
        const OFFSET = 127397;
        const [first, second] = [...code].map(char => char.charCodeAt(0) + OFFSET);
        return String.fromCodePoint(first, second);
      }

      function populateCountrySelect(selectEl) {
        if (!selectEl) return;
        selectEl.innerHTML = '';
        countryData.forEach(country => {
          const option = document.createElement('option');
          option.value = country.code;
          option.textContent = `${getFlagEmoji(country.code)} ${country.name}`;
          selectEl.appendChild(option);
        });
      }
      function updatePickerDisplay(pickerEl, selectEl) {
        if (!pickerEl || !selectEl) return;
        const opt = selectEl.selectedOptions && selectEl.selectedOptions[0]
          ? selectEl.selectedOptions[0]
          : selectEl.options[0];
        if (opt) pickerEl.textContent = opt.textContent;
      }

      function initializeCountryPicker(pickerEl, selectEl, overlayEl, searchEl, listEl) {
        if (!pickerEl || !selectEl || !overlayEl || !searchEl || !listEl) return;

        // Detect Android version for older device optimization
        const ua = navigator.userAgent || '';
        const androidMatch = ua.match(/android\s+(\d+)/i);
        const androidVersion = androidMatch ? parseInt(androidMatch[1]) : 0;
        const isOldAndroid = androidVersion > 0 && androidVersion <= 12; // Android 12 and below

        if (isOldAndroid) {
          console.log(`📱 Android ${androidVersion} detected - Applying aggressive flashing prevention`);
          // Disable animations on overlay for old Android
          overlayEl.style.transition = 'none';
          overlayEl.style.webkitTransition = 'none';
          // Disable gradient animation on panel for old Android
          const panel = overlayEl.querySelector('.country-picker-panel');
          if (panel) {
            panel.classList.add('old-android');
            panel.style.animation = 'none';
            panel.style.webkitAnimation = 'none';
          }
        }

        const buildList = (filterText = '') => {
          const q = (filterText || '').toLowerCase();
          listEl.innerHTML = '';
          countryData.forEach((country) => {
            const label = `${getFlagEmoji(country.code)} ${country.name}`;
            if (q && !label.toLowerCase().includes(q) && !country.code.toLowerCase().includes(q)) return;

            const item = document.createElement('div');
            item.className = 'country-item' + (selectEl.value === country.code ? ' active' : '');
            item.dataset.value = country.code;
            item.textContent = label;

            // Apply hardware acceleration to items for old Android
            if (isOldAndroid) {
              item.style.webkitTransform = 'translateZ(0)';
              item.style.transform = 'translateZ(0)';
              item.style.webkitBackfaceVisibility = 'hidden';
              item.style.backfaceVisibility = 'hidden';
            }

            item.addEventListener('click', () => {
              // For old Android, close immediately without transitions
              if (isOldAndroid) {
                // Immediate close for old Android to prevent flashing
                selectEl.value = country.code;
                updatePickerDisplay(pickerEl, selectEl);
                const changeEvent = new Event('change', { bubbles: true });
                selectEl.dispatchEvent(changeEvent);
                overlayEl.style.display = 'none';
                overlayEl.classList.add('user-stats-hidden');
                overlayEl.style.visibility = 'hidden';
                overlayEl.style.opacity = '0';
              } else {
                // Smooth transition for newer devices
                requestAnimationFrame(() => {
                  selectEl.value = country.code;
                  updatePickerDisplay(pickerEl, selectEl);
                  const changeEvent = new Event('change', { bubbles: true });
                  selectEl.dispatchEvent(changeEvent);
                  overlayEl.style.opacity = '0';
                  setTimeout(() => {
                    overlayEl.classList.add('user-stats-hidden');
                    overlayEl.style.opacity = '';
                  }, 200);
                });
              }
            });
            listEl.appendChild(item);
          });
        };

        const openPicker = () => {
          buildList('');
          searchEl.value = '';

          if (isOldAndroid) {
            // Immediate open for old Android to prevent flashing
            overlayEl.style.display = 'flex';
            overlayEl.style.visibility = 'visible';
            overlayEl.style.opacity = '1';
            overlayEl.classList.remove('user-stats-hidden');
            // Force repaint to prevent flashing
            overlayEl.offsetHeight; // Trigger reflow
            setTimeout(() => searchEl.focus(), 50);
          } else {
            // Smooth open transition for newer devices
            overlayEl.classList.remove('user-stats-hidden');
            overlayEl.style.opacity = '0';
            requestAnimationFrame(() => {
              overlayEl.style.opacity = '1';
              setTimeout(() => searchEl.focus(), 100);
            });
          }
        };

        const closePicker = () => {
          if (isOldAndroid) {
            // Immediate close for old Android to prevent flashing
            overlayEl.style.display = 'none';
            overlayEl.style.visibility = 'hidden';
            overlayEl.style.opacity = '0';
            overlayEl.classList.add('user-stats-hidden');
          } else {
            // Smooth close transition for newer devices
            overlayEl.style.opacity = '0';
            setTimeout(() => {
              overlayEl.classList.add('user-stats-hidden');
              overlayEl.style.opacity = '';
            }, 200);
          }
        };

        pickerEl.addEventListener('click', openPicker);
        overlayEl.querySelector('.picker-close').addEventListener('click', closePicker);
        overlayEl.addEventListener('click', (e) => {
          if (e.target === overlayEl) closePicker();
        });
        searchEl.addEventListener('input', (e) => buildList(e.target.value));

        // Initialize trigger text
        updatePickerDisplay(pickerEl, selectEl);
      }

      // Populate all country dropdowns on load
      populateCountrySelect(document.getElementById('guestCountrySelect'));
      populateCountrySelect(document.getElementById('leaderboardCountryFilter'));
      populateCountrySelect(document.getElementById('authCountry'));

      // Set default for guest profile to "Other"
      const guestSelect = document.getElementById('guestCountrySelect');
      if (guestSelect) {
        guestSelect.value = 'other';
      }

      // Initialize Guest Profile Country Picker
      initializeCountryPicker(
        document.getElementById('guestCountryPicker'),
        document.getElementById('guestCountrySelect'),
        document.getElementById('countryPickerOverlay'),
        document.getElementById('countrySearch'),
        document.getElementById('countryList')
      );

      // Initialize Leaderboard Country Picker
      initializeCountryPicker(
        document.getElementById('leaderboardCountryPicker'),
        document.getElementById('leaderboardCountryFilter'),
        document.getElementById('leaderboardPickerOverlay'),
        document.getElementById('leaderboardCountrySearch'),
        document.getElementById('leaderboardCountryList')
      );

      // Initialize Auth Country Picker
      initializeCountryPicker(
        document.getElementById('authCountryPicker'),
        document.getElementById('authCountry'),
        document.getElementById('authCountryPickerOverlay'),
        document.getElementById('authCountrySearch'),
        document.getElementById('authCountryList')
      );



      // ===== GUEST ID MANAGEMENT =====
      // Generate permanent guest ID (guest-xxxxxxxx)
      function generateGuestId() {
        const timestamp = Date.now();
        const random = Math.floor(Math.random() * 10000);
        const guestNumber = (timestamp % 100000000) + random;
        return `guest-${guestNumber}`;
      }

      // Get or create permanent guest ID
      function getOrCreateGuestId() {
        let guestId = SafeStorage.getItem(GUEST_ID_KEY);
        if (!guestId) {
          guestId = generateGuestId();
          SafeStorage.setItem(GUEST_ID_KEY, guestId);
        }
        return guestId;
      }

      // Set guest ID (for old player recovery)
      function setGuestId(guestId) {
        SafeStorage.setItem(GUEST_ID_KEY, guestId);
        return true;
      }

      // Clear guest ID
      function clearGuestId() {
        SafeStorage.removeItem(GUEST_ID_KEY);
      }

      function getStoredAccountMode() {
        return SafeStorage.getItem(ACCOUNT_MODE_KEY);
      }

      function setStoredAccountMode(mode) {
        saveAccountMode(mode); // Use the new function
      }

      function applyGuestProfileDefaults() {
        if (!userData || typeof userData !== 'object') {
          userData = { ...defaultUserData };
        }
        if (!userData.profile) {
          userData.profile = { ...defaultUserData.profile };
        }

        // Get or create permanent guest ID
        const guestId = getOrCreateGuestId();
        userData.profile.displayName = guestId;
        userData.profile.email = '';
        userData.profile.accountMode = 'guest';
        userData.profile.country = 'other';

        // Set created date if not exists
        if (!userData.profile.createdAt) {
          const now = Date.now();
          userData.profile.createdAt = now;
          userData.profile.createdAtReadable = formatTimestampForFirebase(now);
        } else if (userData.profile.createdAt && !userData.profile.createdAtReadable) {
          // If createdAt exists but readable format doesn't, generate it
          const createdAtMs = typeof userData.profile.createdAt === 'number'
            ? userData.profile.createdAt
            : new Date(userData.profile.createdAt).getTime();
          userData.profile.createdAtReadable = formatTimestampForFirebase(createdAtMs);
        }
      }

      function updateHomeActionButton(buttonId, label) {
        const btn = document.getElementById(buttonId);
        if (!btn) return;

        const titleEl = btn.querySelector('.action-title');
        if (titleEl) {
          titleEl.textContent = label;
        } else {
          btn.textContent = label;
        }

        const subtitleEl = btn.querySelector('.action-subtitle');
        if (subtitleEl) {
          const langAttr = currentLang === 'gu' ? 'subGu' : 'subEn';
          const localizedSubtitle = btn.dataset[langAttr];
          if (localizedSubtitle) {
            subtitleEl.textContent = localizedSubtitle;
          }
        }
      }

      function ensureWelcomeState() {
        // Show welcome modal if user is not logged in
        if (!currentFirebaseUser) {
          enforceWelcomeUntilAuth = true;
          openWelcomeModal();
          return;
        }

        // User is logged in - close welcome modal
        enforceWelcomeUntilAuth = false;
        closeWelcomeModal();
      }

      function clearAuthError() {
        if (authErrorBox) {
          authErrorBox.classList.add('user-stats-hidden');
          authErrorBox.textContent = '';
        }
      }

      function clearAuthMessage() {
        if (authMessageBox) {
          authMessageBox.classList.add('user-stats-hidden');
          authMessageBox.textContent = '';
        }
      }

      function showAuthError(message) {
        if (authErrorBox) {
          clearAuthMessage();
          authErrorBox.textContent = message;
          authErrorBox.classList.remove('user-stats-hidden');
        }
      }

      function showAuthMessage(message) {
        if (authMessageBox) {
          clearAuthError();
          authMessageBox.textContent = message;
          authMessageBox.classList.remove('user-stats-hidden');
        }
      }

      function configureAuthModal(mode) {
        authModalMode = mode;
        clearAuthError();
        clearAuthMessage();

        if (!authModalTitle || !authModalMessage || !authSubmitBtn || !authSwitchModeBtn) return;

        const showProfileFields = mode !== 'login';

        if (displayNameGroup) {
          displayNameGroup.classList.toggle('user-stats-hidden', !showProfileFields);
          displayNameGroup.hidden = !showProfileFields;
          displayNameGroup.style.display = showProfileFields ? '' : 'none';
        }
        if (confirmPasswordGroup) {
          confirmPasswordGroup.classList.toggle('user-stats-hidden', !showProfileFields);
          confirmPasswordGroup.hidden = !showProfileFields;
          confirmPasswordGroup.style.display = showProfileFields ? '' : 'none';
        }
        const countryGroup = document.getElementById('countryGroup');
        if (countryGroup) {
          countryGroup.classList.toggle('user-stats-hidden', !showProfileFields);
          countryGroup.hidden = !showProfileFields;
          countryGroup.style.display = showProfileFields ? '' : 'none';
        }

        if (authDisplayNameInput) {
          if (showProfileFields) {
            if (userData && userData.profile && userData.profile.displayName && userData.profile.displayName.trim() !== '') {
              authDisplayNameInput.value = userData.profile.displayName;
            } else {
              authDisplayNameInput.value = '';
            }
            authDisplayNameInput.setAttribute('required', 'required');
          } else {
            authDisplayNameInput.value = '';
            authDisplayNameInput.removeAttribute('required');
          }
        }

        if (authConfirmPasswordInput) {
          authConfirmPasswordInput.value = '';
          if (showProfileFields) {
            authConfirmPasswordInput.setAttribute('required', 'required');
            authConfirmPasswordInput.setAttribute('tabindex', '0');
          } else {
            authConfirmPasswordInput.removeAttribute('required');
            authConfirmPasswordInput.setAttribute('tabindex', '-1');
          }
        }

        if (authDisplayNameInput) {
          if (showProfileFields) {
            authDisplayNameInput.removeAttribute('tabindex');
          } else {
            authDisplayNameInput.setAttribute('tabindex', '-1');
          }
        }

        if (mode === 'login') {
          authModalTitle.textContent = 'Sign In';
          authModalMessage.textContent = 'Sign in to load your saved progress on any device.';
          authSubmitBtn.textContent = 'Sign In';
          authSwitchModeBtn.textContent = 'Need an account? Create one';
          if (authForgotPasswordBtn) authForgotPasswordBtn.classList.remove('user-stats-hidden');
          if (authPasswordInput) authPasswordInput.setAttribute('autocomplete', 'current-password');
        } else {
          authModalTitle.textContent = mode === 'upgrade' ? 'Save Your Progress' : 'Create Account';
          authModalMessage.textContent = 'Connect your progress to email so it stays safe everywhere.';
          authSubmitBtn.textContent = 'Save Progress';
          authSwitchModeBtn.textContent = 'Already have an account? Sign In';
          if (authForgotPasswordBtn) authForgotPasswordBtn.classList.add('user-stats-hidden');
          if (authPasswordInput) authPasswordInput.setAttribute('autocomplete', 'new-password');
        }

        if (authEmailInput) authEmailInput.value = '';
        if (authPasswordInput) authPasswordInput.value = '';
      }

      function openAuthModal(mode) {
        configureAuthModal(mode);
        if (authModal) {
          authModal.classList.add('active');
          authModal.classList.remove('user-stats-hidden');
        }
      }

      function closeAuthModal() {
        if (authModal) {
          authModal.classList.remove('active');
          authModal.classList.add('user-stats-hidden');
        }
        clearAuthError();
        clearAuthMessage();
        if (enforceWelcomeUntilAuth && !currentFirebaseUser) {
          openWelcomeModal();
        }
      }

      const loginBtn = document.getElementById('loginBtn');

      if (loginBtn) {
        loginBtn.addEventListener('click', () => {
          // Open auth modal in login mode
          configureAuthModal('login');
          openAuthModal('login');
        });
      }

      // Sign out button handler
      const signOutBtn = document.getElementById('signOutBtn');
      if (signOutBtn) {
        signOutBtn.addEventListener('click', async () => {
          await handleSignOut();
        });
      }

      function openWelcomeModal() {
        if (!welcomeModal) return;
        // Ensure home screen maintains its layout
        const homeScreen = document.getElementById('homeScreen');
        if (homeScreen) {
          homeScreen.style.display = 'flex';
        }
        welcomeModal.classList.add('active');
        welcomeModal.classList.remove('user-stats-hidden');
      }

      function closeWelcomeModal() {
        if (!welcomeModal) return;
        // Ensure home screen maintains its layout
        const homeScreen = document.getElementById('homeScreen');
        if (homeScreen) {
          homeScreen.style.display = 'flex';
        }
        welcomeModal.classList.remove('active');
        welcomeModal.classList.add('user-stats-hidden');
      }

      function updateAccountUI(user) {
        if (!syncStatusIcon) return;

        // Check if user is email user
        const isEmailUser = user && user.email;

        // Show delete button when user is logged in
        if (deleteAccountBtn && userData && userData.profile && userData.profile.displayName) {
          deleteAccountBtn.classList.remove('user-stats-hidden');
        }

        if (!user) {
          // No user logged in - show login button, hide multi-device button
          if (deleteAccountBtn) deleteAccountBtn.classList.add('user-stats-hidden');
          if (loginBtn) loginBtn.style.display = 'block';
          if (signInBtn) signInBtn.style.display = 'none';
          if (signOutBtn) signOutBtn.style.display = 'none';
          syncStatusIcon.textContent = '💾';
          syncStatusIcon.className = 'local';
          syncStatusIcon.title = 'Data saved locally only';
          return;
        }

        // User is logged in
        if (deleteAccountBtn) deleteAccountBtn.classList.remove('user-stats-hidden');
        if (loginBtn) loginBtn.style.display = 'none';
        if (signInBtn) signInBtn.style.display = 'none';

        // Show sign out button only for email users (not anonymous)
        if (signOutBtn) {
          if (isEmailUser) {
            signOutBtn.style.display = 'block';
          } else {
            signOutBtn.style.display = 'none';
          }
        }


        // Anonymous user - show local save icon
        syncStatusIcon.textContent = '☁️';
        syncStatusIcon.className = 'synced';
        syncStatusIcon.title = 'Data synced to cloud';
      }

      async function handleAuthFormSubmit(event) {
        event.preventDefault();

        if (!authEmailInput || !authPasswordInput || !authSubmitBtn) return;

        const email = authEmailInput.value.trim().toLowerCase();
        const password = authPasswordInput.value.trim();
        const displayName = authDisplayNameInput ? authDisplayNameInput.value.trim() : '';
        const confirmPassword = authConfirmPasswordInput ? authConfirmPasswordInput.value.trim() : '';
        const country = authCountryInput ? authCountryInput.value : '';

        if (!email || !password) {
          showAuthError('Please enter both email and password.');
          return;
        }

        if (authModalMode !== 'login') {
          if (!displayName || displayName.length < 3) {
            showAuthError('Please choose a username (at least 3 characters).');
            return;
          }
          if (!confirmPassword) {
            showAuthError('Please confirm your password.');
            return;
          }
          if (password !== confirmPassword) {
            showAuthError('Passwords do not match.');
            return;
          }
          if (!country) {
            showAuthError('Please select your country.');
            return;
          }

          // Check if username exists in Firebase users collection
          try {
            const firebaseCheck = await checkUsernameInFirebase(displayName);
            if (firebaseCheck.exists) {
              showAuthError(`Username "${displayName}" is already taken. Try: ${firebaseCheck.suggested || displayName + '123'}`);
              return;
            }
          } catch (error) {
            console.warn('Error checking username:', error);
            // Continue with signup if check fails
          }
        }

        clearAuthError();
        clearAuthMessage();

        const getDisplayNameFallback = () => {
          if (authModalMode !== 'login') {
            return displayName;
          }
          if (!userData || !userData.profile) return email.split('@')[0] || 'Player';
          const profileName = (userData.profile.displayName || '').trim();
          if (profileName && profileName.toLowerCase() !== 'guest player') {
            return profileName;
          }
          const emailName = email.split('@')[0] || 'Player';
          return emailName.charAt(0).toUpperCase() + emailName.slice(1);
        };

        const originalButtonText = authSubmitBtn.textContent;
        authSubmitBtn.disabled = true;
        authSubmitBtn.textContent = 'Please wait...';

        // Show loading popup
        if (authModalMode === 'login') {
          showLoadingPopup('Signing in...');
        } else {
          showLoadingPopup('Creating account...');
        }

        try {
          if (authModalMode === 'login') {
            if (window.firebaseAuth.currentUser) {
              await window.firebaseModules.auth.signOut(window.firebaseAuth);
            }
            await window.firebaseModules.auth.signInWithEmailAndPassword(window.firebaseAuth, email, password);
            saveAccountMode('registered'); // Save to local storage
            enforceWelcomeUntilAuth = false;

            // Show success message
            showLoadingPopup('✅ Signed in successfully!');
            await new Promise(resolve => setTimeout(resolve, 800));
            hideLoadingPopup();

            closeAuthModal();
          } else {
            const finalDisplayName = getDisplayNameFallback();

            // Update loading message
            showLoadingPopup('Creating your account...');

            const newUser = await window.firebaseModules.auth.createUserWithEmailAndPassword(window.firebaseAuth, email, password);
            currentFirebaseUser = newUser.user;
            if (window.firebaseModules.auth.updateProfile) {
              await window.firebaseModules.auth.updateProfile(newUser.user, { displayName: finalDisplayName });
            }
            currentFirebaseUser.displayName = finalDisplayName;
            userData.profile.email = email;
            userData.profile.displayName = finalDisplayName;
            userData.profile.country = country;
            userData.profile.accountMode = 'registered';
            saveAccountMode('registered'); // Save to local storage
            enforceWelcomeUntilAuth = false;

            // Update loading message
            showLoadingPopup('Saving your data...');

            await saveUserDataToFirebase(currentFirebaseUser.uid);

            // Show success message
            showLoadingPopup('✅ Account created successfully!');
            await new Promise(resolve => setTimeout(resolve, 1000));
            hideLoadingPopup();

            closeAuthModal();
            updateAccountUI(currentFirebaseUser);
            updateUIWithUserData();
          }
        } catch (error) {
          console.error('Authentication error:', error);
          hideLoadingPopup();
          showAuthError(error.message || 'Something went wrong. Please try again.');
        } finally {
          authSubmitBtn.disabled = false;
          authSubmitBtn.textContent = originalButtonText;
        }
      }

      // Loading popup functions
      function showLoadingPopup(text = 'Loading...') {
        if (loadingPopup) {
          const loadingText = loadingPopup.querySelector('.loading-text');
          if (loadingText) loadingText.textContent = text;
          loadingPopup.classList.remove('user-stats-hidden');
        }
      }

      function hideLoadingPopup() {
        if (loadingPopup) {
          loadingPopup.classList.add('user-stats-hidden');
        }
      }

      async function handleSignOut() {
        if (!window.firebaseAuth) return;
        try {
          const user = window.firebaseAuth.currentUser;

          if (user) {
            // Save game state to Firebase before signing out (so user can resume on another device)
            try {
              await forceSaveGameStateToFirebase();
              console.log('✅ Saved in-progress games to Firebase before sign out');
            } catch (error) {
              console.error('Error saving in-progress games:', error);
            }

            // Save all data to Firebase before signing out
            await saveUserDataToFirebase(user.uid);
            console.log('✅ Saved all data to Firebase before sign out');

            // Sign out from Firebase
            await window.firebaseModules.auth.signOut(window.firebaseAuth);
            console.log('✅ Signed out from Firebase');
          }

          // Clear ALL local storage (except login session which is handled by LocalUserDB)
          try {
            // Clear game state from local storage
            SafeStorage.removeItem(CLASSIC_GAME_STATE_KEY);
            SafeStorage.removeItem(TIMED_GAME_STATE_KEY);
            SafeStorage.removeItem('blockPuzzleUserData');
            SafeStorage.removeItem('blockPuzzleAccountMode');
            console.log('✅ Cleared all local storage');
          } catch (error) {
            console.error('Error clearing local storage:', error);
          }

          // Clear current user session from LocalUserDB
          LocalUserDB.clearCurrentUser();

          // Reset ALL game state variables completely
          boardClassic = Array(10).fill().map(() => Array(10).fill(null));
          boardTimed = Array(10).fill().map(() => Array(10).fill(null));
          scoreClassic = 0;
          scoreTimed = 0;
          currentThreeClassic = [];
          currentThreeTimed = [];
          selectedClassic = null;
          selectedIdxClassic = null;
          selectedTimed = null;
          selectedIdxTimed = null;
          pausedClassic = false;
          pausedTimed = false;
          totalLinesClassic = 0;
          totalLinesTimed = 0;
          totalBlocksPlaced = 0;
          totalBlocksPlacedTimed = 0;
          timer = 300;
          extraTimeEarnedInGame = 0;
          currentLevelTimed = 1;
          undoCountClassic = 3;
          undoCountTimed = 3;
          gameStartTime = null;

          // Clear game state
          clearClassicGameState();
          clearTimedGameState();

          // Hide all game containers
          const classicContainer = document.getElementById('classicContainer');
          const timedContainer = document.getElementById('timedContainer');
          if (classicContainer) classicContainer.style.display = 'none';
          if (timedContainer) timedContainer.style.display = 'none';

          // Show home screen
          const homeScreen = document.getElementById('homeScreen');
          if (homeScreen) homeScreen.style.display = 'block';

          // Redraw grids to show empty boards
          if (typeof drawGridClassic === 'function') drawGridClassic();
          if (typeof drawGridTimed === 'function') drawGridTimed();

          // Clear pieces display
          const piecesClassic = document.getElementById('piecesClassic');
          const piecesTimed = document.getElementById('piecesTimed');
          if (piecesClassic) piecesClassic.innerHTML = '';
          if (piecesTimed) piecesTimed.innerHTML = '';

          // Reset in-memory state
          currentFirebaseUser = null;
          userData = JSON.parse(JSON.stringify(defaultUserData));
          isUserDataLoaded = false;

          // Reset player name display
          const playerNameDisplay = document.getElementById('playerNameDisplay');
          if (playerNameDisplay) {
            playerNameDisplay.textContent = '🎮 Guest Player';
            playerNameDisplay.title = '';
          }

          // Hide user stats and show/hide appropriate buttons
          updateAccountUI(null);
          updateUIWithUserData();
          setStoredAccountMode(null);

          // Show welcome modal again
          enforceWelcomeUntilAuth = true;
          ensureWelcomeState();

          console.log('✅ Signed out successfully - ready for new user');
        } catch (error) {
          console.error('Error signing out:', error);
          alert('Error signing out. Please try again.');
        }
      }

      if (authForm) authForm.addEventListener('submit', handleAuthFormSubmit);
      if (authCloseBtn) authCloseBtn.addEventListener('click', closeAuthModal);
      if (authModal) {
        authModal.addEventListener('click', (event) => {
          if (event.target === authModal) {
            closeAuthModal();
          }
        });
      }
      if (authSwitchModeBtn) {
        authSwitchModeBtn.addEventListener('click', () => {
          const nextMode = authModalMode === 'login' ? 'signup' : 'login';
          configureAuthModal(nextMode);
        });
      }

      // Welcome modal buttons
      const welcomeGuestBtn = document.getElementById('welcomeGuestBtn');
      const welcomeEmailBtn = document.getElementById('welcomeEmailBtn');

      if (welcomeGuestBtn) {
        welcomeGuestBtn.addEventListener('click', () => {
          // Show guest auth modal (username/password login/signup)
          closeWelcomeModal();
          const guestAuthModal = document.getElementById('guestAuthModal');
          if (guestAuthModal) {
            guestAuthModal.classList.add('active');
            guestAuthModal.classList.remove('user-stats-hidden');
            guestAuthModal.style.display = 'flex';
          }
        });
      }

      if (welcomeEmailBtn) {
        welcomeEmailBtn.addEventListener('click', () => {
          // Show email auth modal (similar to guest auth modal)
          closeWelcomeModal();
          const emailAuthModal = document.getElementById('emailAuthModal');
          if (emailAuthModal) {
            emailAuthModal.classList.add('active');
            emailAuthModal.classList.remove('user-stats-hidden');
            emailAuthModal.style.display = 'flex';
          }
        });
      }

      // Removed: recovery hint wiring (welcome/home) since Guest ID recovery is no longer supported
      // (Removed) Home stats recovery hint handler
      if (authForgotPasswordBtn) {
        authForgotPasswordBtn.addEventListener('click', async () => {
          if (!authEmailInput) return;
          const email = authEmailInput.value.trim().toLowerCase();
          if (!email) {
            showAuthError('Enter your email first to reset the password.');
            return;
          }

          try {
            clearAuthError();
            await window.firebaseModules.auth.sendPasswordResetEmail(window.firebaseAuth, email);
            showAuthMessage('Password reset email sent. Check your inbox.');
          } catch (error) {
            console.error('Password reset error:', error);
            showAuthError(error.message || 'Unable to send reset email. Try again later.');
          }
        });
      }

      // ===== OLD MODAL HANDLERS REMOVED - Using auto anonymous auth =====
      // All guest/email login modals are hidden and unused

      // ===== GUEST AUTH MODAL HANDLERS (Simplified - Just Buttons) =====
      const guestLoginBtn = document.getElementById('guestLoginBtn');
      const guestSignupBtn = document.getElementById('guestSignupBtn');
      const guestAuthBackBtn = document.getElementById('guestAuthBackBtn');

      // Guest Auth Modal Back Button
      if (guestAuthBackBtn) {
        guestAuthBackBtn.addEventListener('click', () => {
          // Close guest auth modal completely
          const guestAuthModal = document.getElementById('guestAuthModal');
          if (guestAuthModal) {
            guestAuthModal.classList.remove('active');
            guestAuthModal.classList.add('user-stats-hidden');
            guestAuthModal.style.display = 'none';
          }

          // Show welcome modal again
          openWelcomeModal();
        });
      }

      if (guestLoginBtn) {
        guestLoginBtn.addEventListener('click', () => {
          // Close guest auth modal
          const guestAuthModal = document.getElementById('guestAuthModal');
          if (guestAuthModal) {
            guestAuthModal.classList.remove('active');
            guestAuthModal.classList.add('user-stats-hidden');
            guestAuthModal.style.display = 'none';
          }

          // Open guest login modal
          const guestLoginModal = document.getElementById('guestLoginModal');
          if (guestLoginModal) {
            guestLoginModal.classList.add('active');
            guestLoginModal.classList.remove('user-stats-hidden');
            guestLoginModal.style.display = 'flex';
          }
        });
      }

      if (guestSignupBtn) {
        guestSignupBtn.addEventListener('click', () => {
          // Close guest auth modal
          const guestAuthModal = document.getElementById('guestAuthModal');
          if (guestAuthModal) {
            guestAuthModal.classList.remove('active');
            guestAuthModal.classList.add('user-stats-hidden');
            guestAuthModal.style.display = 'none';
          }

          // Open guest signup modal
          const guestSignupModal = document.getElementById('guestSignupModal');
          if (guestSignupModal) {
            guestSignupModal.classList.add('active');
            guestSignupModal.classList.remove('user-stats-hidden');
            guestSignupModal.style.display = 'flex';
          }
        });
      }

      // ===== EMAIL AUTH MODAL HANDLERS =====
      const emailLoginBtnHandler = document.getElementById('emailLoginBtn');
      const emailSignupBtnHandler = document.getElementById('emailSignupBtn');
      const emailAuthBackBtnHandler = document.getElementById('emailAuthBackBtn');

      // Email Auth Modal - Login Button
      if (emailLoginBtnHandler) {
        emailLoginBtnHandler.addEventListener('click', () => {
          // Close email auth modal
          const emailAuthModal = document.getElementById('emailAuthModal');
          if (emailAuthModal) {
            emailAuthModal.classList.remove('active');
            emailAuthModal.classList.add('user-stats-hidden');
            emailAuthModal.style.display = 'none';
          }

          // Open auth modal in login mode
          openAuthModal('login');
        });
      }

      // Email Auth Modal - Create Account Button
      if (emailSignupBtnHandler) {
        emailSignupBtnHandler.addEventListener('click', () => {
          // Close email auth modal
          const emailAuthModal = document.getElementById('emailAuthModal');
          if (emailAuthModal) {
            emailAuthModal.classList.remove('active');
            emailAuthModal.classList.add('user-stats-hidden');
            emailAuthModal.style.display = 'none';
          }

          // Open auth modal in signup mode
          openAuthModal('signup');
        });
      }

      // Email Auth Modal Back Button
      if (emailAuthBackBtnHandler) {
        emailAuthBackBtnHandler.addEventListener('click', () => {
          // Close email auth modal completely
          const emailAuthModal = document.getElementById('emailAuthModal');
          if (emailAuthModal) {
            emailAuthModal.classList.remove('active');
            emailAuthModal.classList.add('user-stats-hidden');
            emailAuthModal.style.display = 'none';
          }

          // Show welcome modal again
          openWelcomeModal();
        });
      }

      // ===== GUEST LOGIN MODAL HANDLERS =====
      const guestLoginForm = document.getElementById('guestLoginForm');
      const guestLoginUsernameInput = document.getElementById('guestLoginUsername');
      const guestLoginPasswordInput = document.getElementById('guestLoginPassword');
      const guestLoginBackBtn = document.getElementById('guestLoginBackBtn');
      const guestLoginError = document.getElementById('guestLoginError');

      if (guestLoginForm) {
        guestLoginForm.addEventListener('submit', async (e) => {
          e.preventDefault();

          const username = guestLoginUsernameInput?.value.trim();
          const password = guestLoginPasswordInput?.value.trim();

          if (!username || !password) {
            if (guestLoginError) {
              guestLoginError.textContent = 'કૃપા કરીને Username અને Password enter કરો';
              guestLoginError.classList.remove('user-stats-hidden');
            }
            return;
          }

          // Clear error
          if (guestLoginError) guestLoginError.classList.add('user-stats-hidden');

          // Show loading popup
          showLoadingPopup('Signing in...');

          // Create hidden email from username
          const guestEmail = `${username}@flyingbird.com`;

          try {
            // Login with Firebase email authentication
            const userCredential = await window.firebaseModules.auth.signInWithEmailAndPassword(
              window.firebaseAuth,
              guestEmail,
              password
            );
            currentFirebaseUser = userCredential.user;
            console.log("✅ Guest logged in with email:", guestEmail);

            // Update loading message
            showLoadingPopup('Loading your data...');

            // Find user in LocalUserDB by username
            const storedUser = LocalUserDB.findUserByUsername(username);
            if (!storedUser) {
              // User exists in Firebase but not in LocalUserDB - create entry
              const result = LocalUserDB.createGuestUser(username, password, currentFirebaseUser.uid);
              if (result.success) {
                LocalUserDB.setCurrentUser(result.user.id);
                console.log("✅ Created LocalUserDB entry for existing Firebase user");
              }
            } else {
              // Set as current user
              LocalUserDB.setCurrentUser(storedUser.id);
            }

            // Load data from Firebase
            const currentUserSession = LocalUserDB.getCurrentUser();
            const finalUser = currentUserSession ? LocalUserDB.findUserById(currentUserSession.id) : null;

            if (finalUser) {
              // Load user data from Firestore using Firebase UID (same path as email users)
              try {
                const userDocRef = window.firebaseModules.firestore.doc(window.firebaseDB, 'users', currentFirebaseUser.uid);
                const userDoc = await window.firebaseModules.firestore.getDoc(userDocRef);

                if (userDoc.exists()) {
                  const firebaseData = userDoc.data();
                  userData = mergeUserData(defaultUserData, firebaseData);
                  userData.profile.displayName = username;
                  userData.profile.email = guestEmail; // Ensure email is set
                  userData.profile.accountMode = 'guest';
                  console.log("✅ Guest data loaded from Firebase");
                } else {
                  // No data in Firebase, use default
                  userData = { ...defaultUserData };
                  userData.profile.displayName = username;
                  userData.profile.email = guestEmail; // Set guest email
                  userData.profile.accountMode = 'guest';
                  const now = Date.now();
                  userData.profile.createdAt = now;
                  userData.profile.createdAtReadable = formatTimestampForFirebase(now);
                  console.log("🆕 New guest data initialized");
                }
              } catch (fbError) {
                console.error("Firebase load error:", fbError);
                userData = { ...defaultUserData };
                userData.profile.displayName = username;
                userData.profile.email = guestEmail; // Set guest email
                userData.profile.accountMode = 'guest';
              }

              isUserDataLoaded = true;
              LocalUserDB.updateUserData(finalUser.id, userData);
            }

            // Show success and hide loading
            showLoadingPopup('✅ Signed in successfully!');
            await new Promise(resolve => setTimeout(resolve, 800));
            hideLoadingPopup();

            // Close all modals
            const guestLoginModal = document.getElementById('guestLoginModal');
            if (guestLoginModal) {
              guestLoginModal.classList.remove('active');
              guestLoginModal.classList.add('user-stats-hidden');
              guestLoginModal.style.display = 'none';
            }

            // Also close guest auth modal if open
            const guestAuthModal = document.getElementById('guestAuthModal');
            if (guestAuthModal) {
              guestAuthModal.classList.remove('active');
              guestAuthModal.classList.add('user-stats-hidden');
              guestAuthModal.style.display = 'none';
            }

            // Close welcome modal
            closeWelcomeModal();

            // Update UI with Firebase user
            updateAccountUI(currentFirebaseUser);
            updateUIWithUserData();
            // Sync in-progress games from cloud for this guest
            await syncInProgressFromCloud();
            console.log('✅ Guest logged in:', username);
          } catch (error) {
            console.error('Firebase login error:', error);
            if (guestLoginError) {
              if (error.code === 'auth/user-not-found' || error.code === 'auth/invalid-email') {
                guestLoginError.textContent = '❌ આ Username સાથેનો કોઈ Player નથી. કૃપા કરીને Create Account કરો.';
              } else if (error.code === 'auth/wrong-password' || error.code === 'auth/invalid-credential') {
                guestLoginError.textContent = '❌ ખોટો Password! કૃપા કરીને સાચો password enter કરો.';
              } else {
                guestLoginError.textContent = 'Login error. Please try again.';
              }
              guestLoginError.classList.remove('user-stats-hidden');
            }
          }
        });
      }
      if (guestLoginBackBtn) {
        guestLoginBackBtn.addEventListener('click', () => {
          // Close guest login modal completely
          const guestLoginModal = document.getElementById('guestLoginModal');
          if (guestLoginModal) {
            guestLoginModal.classList.remove('active');
            guestLoginModal.classList.add('user-stats-hidden');
            guestLoginModal.style.display = 'none';
          }

          // Show guest auth modal again
          const guestAuthModal = document.getElementById('guestAuthModal');
          if (guestAuthModal) {
            guestAuthModal.classList.add('active');
            guestAuthModal.classList.remove('user-stats-hidden');
            guestAuthModal.style.display = 'flex';
          }
        });
      }

      // ===== GUEST SIGNUP MODAL HANDLERS =====
      const guestSignupForm = document.getElementById('guestSignupForm');
      const guestSignupUsernameInput = document.getElementById('guestSignupUsername');
      const guestSignupPasswordInput = document.getElementById('guestSignupPassword');
      const guestSignupConfirmPasswordInput = document.getElementById('guestSignupConfirmPassword');
      const guestCountryInput = document.getElementById('guestCountry');
      const guestSignupBackBtn = document.getElementById('guestSignupBackBtn');
      const guestSignupError = document.getElementById('guestSignupError');

      // Populate Guest Signup Country Select
      populateCountrySelect(document.getElementById('guestCountry'));

      // Initialize Guest Country Picker
      initializeCountryPicker(
        document.getElementById('guestCountryPicker'),
        document.getElementById('guestCountry'),
        document.getElementById('guestCountryPickerOverlay'),
        document.getElementById('guestCountrySearch'),
        document.getElementById('guestCountryList')
      );

      if (guestSignupForm) {
        guestSignupForm.addEventListener('submit', async (e) => {
          e.preventDefault();

          const username = guestSignupUsernameInput?.value.trim();
          const password = guestSignupPasswordInput?.value.trim();
          const confirmPassword = guestSignupConfirmPasswordInput?.value.trim();
          const country = guestCountryInput?.value;

          // Clear error
          if (guestSignupError) guestSignupError.classList.add('user-stats-hidden');

          // Validation
          if (!username || !password || !confirmPassword) {
            if (guestSignupError) {
              guestSignupError.textContent = 'કૃપા કરીને બધા fields fill કરો';
              guestSignupError.classList.remove('user-stats-hidden');
            }
            return;
          }

          if (username.length < 3) {
            if (guestSignupError) {
              guestSignupError.textContent = 'Username ઓછામાં ઓછું 3 અક્ષરનું હોવું જોઈએ';
              guestSignupError.classList.remove('user-stats-hidden');
            }
            return;
          }

          if (password.length < 4) {
            if (guestSignupError) {
              guestSignupError.textContent = 'Password ઓછામાં ઓછો 4 અક્ષરનો હોવો જોઈએ';
              guestSignupError.classList.remove('user-stats-hidden');
            }
            return;
          }

          if (password !== confirmPassword) {
            if (guestSignupError) {
              guestSignupError.textContent = 'Passwords match નથી થતા';
              guestSignupError.classList.remove('user-stats-hidden');
            }
            return;
          }

          if (!country) {
            if (guestSignupError) {
              guestSignupError.textContent = 'કૃપા કરીને country select કરો';
              guestSignupError.classList.remove('user-stats-hidden');
            }
            return;
          }

          // Create hidden email from username
          const guestEmail = `${username}@flyingbird.com`;

          // Check if user already exists in LocalUserDB
          const existingUser = LocalUserDB.findUserByUsername(username);
          if (existingUser) {
            if (guestSignupError) {
              guestSignupError.textContent = `❌ આ Username પહેલેથી વપરાયેલું છે! Try: ${username}123`;
              guestSignupError.classList.remove('user-stats-hidden');
            }
            return;
          }

          // Check if username exists in Firebase users collection
          const firebaseCheck = await checkUsernameInFirebase(username);
          if (firebaseCheck.exists) {
            if (guestSignupError) {
              guestSignupError.textContent = `❌ આ Username પહેલેથી વપરાયેલું છે! Try: ${firebaseCheck.suggested || username + '123'}`;
              guestSignupError.classList.remove('user-stats-hidden');
            }
            return;
          }

          // Show loading popup
          showLoadingPopup('Creating account...');

          try {
            // Create Firebase email user with hidden email
            const userCredential = await window.firebaseModules.auth.createUserWithEmailAndPassword(
              window.firebaseAuth,
              guestEmail,
              password
            );
            currentFirebaseUser = userCredential.user;
            console.log("✨ Guest Firebase user created with email:", guestEmail);

            // Update loading message
            showLoadingPopup('Setting up your account...');

            // Create guest user in LocalUserDB with Firebase UID
            const result = LocalUserDB.createGuestUser(username, password, currentFirebaseUser.uid);
            if (!result.success) {
              // Should not happen as we checked above, but just in case
              await currentFirebaseUser.delete();
              hideLoadingPopup();
              if (guestSignupError) {
                guestSignupError.textContent = 'Error creating local user account';
                guestSignupError.classList.remove('user-stats-hidden');
              }
              return;
            }

            // Set as current user
            LocalUserDB.setCurrentUser(result.user.id);

            // Initialize default user data with username and country
            userData = { ...defaultUserData };
            userData.profile.displayName = username;
            userData.profile.email = guestEmail; // Save guest email to Firebase
            userData.profile.accountMode = 'guest';
            userData.profile.country = country;
            const now = Date.now();
            userData.profile.createdAt = now;
            userData.profile.createdAtReadable = formatTimestampForFirebase(now);
            isUserDataLoaded = true;

            // Save to LocalUserDB
            LocalUserDB.updateUserData(result.user.id, userData);

            // Update loading message
            showLoadingPopup('Saving your data...');

            // Save to Firebase Firestore using Firebase UID (same path as email users)
            await saveUserDataToFirebase(currentFirebaseUser.uid);

            // Show success message
            showLoadingPopup('✅ Account created successfully!');

            // Wait a moment to show success message
            await new Promise(resolve => setTimeout(resolve, 1000));

            // Hide loading popup
            hideLoadingPopup();

            // Close all modals
            const guestSignupModal = document.getElementById('guestSignupModal');
            if (guestSignupModal) {
              guestSignupModal.classList.remove('active');
              guestSignupModal.classList.add('user-stats-hidden');
              guestSignupModal.style.display = 'none';
            }

            // Also close guest auth modal if open
            const guestAuthModal = document.getElementById('guestAuthModal');
            if (guestAuthModal) {
              guestAuthModal.classList.remove('active');
              guestAuthModal.classList.add('user-stats-hidden');
              guestAuthModal.style.display = 'none';
            }

            // Close welcome modal
            closeWelcomeModal();

            // Update UI with Firebase user
            updateAccountUI(currentFirebaseUser);
            updateUIWithUserData();
            console.log('✅ Guest account created:', username);
          } catch (error) {
            console.error('Firebase signup error:', error);
            hideLoadingPopup();
            if (guestSignupError) {
              if (error.code === 'auth/email-already-in-use') {
                guestSignupError.textContent = `❌ આ Username પહેલેથી વપરાયેલું છે! Try: ${username}123`;
              } else if (error.code === 'auth/weak-password') {
                guestSignupError.textContent = 'Password વધુ મજબૂત હોવો જોઈએ';
              } else {
                guestSignupError.textContent = 'Error creating account. Please try again.';
              }
              guestSignupError.classList.remove('user-stats-hidden');
            }
          }
        });
      }

      if (guestSignupBackBtn) {
        guestSignupBackBtn.addEventListener('click', () => {
          // Close guest signup modal completely
          const guestSignupModal = document.getElementById('guestSignupModal');
          if (guestSignupModal) {
            guestSignupModal.classList.remove('active');
            guestSignupModal.classList.add('user-stats-hidden');
            guestSignupModal.style.display = 'none';
          }

          // Show guest auth modal again
          const guestAuthModal = document.getElementById('guestAuthModal');
          if (guestAuthModal) {
            guestAuthModal.classList.add('active');
            guestAuthModal.classList.remove('user-stats-hidden');
            guestAuthModal.style.display = 'flex';
          }
        });
      }


      // Old guest recovery handlers removed - using new username/password system

      // ===== DELETE ACCOUNT FUNCTIONALITY =====
      if (deleteAccountBtn) {
        deleteAccountBtn.addEventListener('click', () => {
          // Show delete confirmation modal
          if (deleteAccountModal) {
            deleteAccountModal.classList.add('active');
            deleteAccountModal.classList.remove('user-stats-hidden');
          }
        });
      }

      if (cancelDeleteBtn) {
        cancelDeleteBtn.addEventListener('click', () => {
          // Close delete modal
          if (deleteAccountModal) {
            deleteAccountModal.classList.remove('active');
            deleteAccountModal.classList.add('user-stats-hidden');
          }
        });
      }

      if (confirmDeleteBtn) {
        confirmDeleteBtn.addEventListener('click', async () => {
          // Show loading popup
          showLoadingPopup('Deleting account...');

          try {
            const userIdToDelete = currentFirebaseUser ? currentFirebaseUser.uid : null;
            const currentUserSession = LocalUserDB.getCurrentUser(); // Returns {id, type, username}
            const currentUserId = currentUserSession ? currentUserSession.id : null;
            const storedUser = currentUserId ? LocalUserDB.findUserById(currentUserId) : null;

            console.log('Delete account - currentUserId:', currentUserId);
            console.log('Delete account - storedUser:', storedUser);

            // Delete from Firebase if user exists
            if (currentFirebaseUser && window.firebaseDB) {
              showLoadingPopup('Removing data from cloud...');
              try {
                // Delete user data from Firestore (all users in single 'users' collection)
                const userDocRef = window.firebaseModules.firestore.doc(window.firebaseDB, 'users', currentFirebaseUser.uid);
                await window.firebaseModules.firestore.deleteDoc(userDocRef);
                console.log('User data deleted from Firebase users collection');

                // Delete from leaderboard
                const leaderboardRef = window.firebaseModules.firestore.doc(window.firebaseDB, 'leaderboard', currentFirebaseUser.uid);
                await window.firebaseModules.firestore.deleteDoc(leaderboardRef);
                console.log('Leaderboard entry deleted');

                // Delete Firebase auth user (email-based for both guest and regular users)
                try {
                  // Get user's email before deletion attempt
                  const userEmail = currentFirebaseUser.email;
                  console.log('Attempting to delete Firebase Auth user:', userEmail);

                  showLoadingPopup('Deleting authentication...');

                  // Try to delete directly first
                  await currentFirebaseUser.delete();
                  console.log('✅ Firebase auth user and email deleted successfully');
                } catch (authError) {
                  console.error('❌ Error deleting auth user:', authError);
                  console.error('Error code:', authError.code);
                  console.error('Error message:', authError.message);

                  // If error is auth/requires-recent-login, try to re-authenticate
                  if (authError.code === 'auth/requires-recent-login') {
                    console.log('⚠️ Re-authentication required - attempting automatic re-auth');
                    showLoadingPopup('Re-authenticating...');

                    try {
                      let reauthSuccess = false;
                      let password = null;

                      // For guest users, try stored password first, then prompt if needed
                      if (storedUser && storedUser.type === 'guest' && storedUser.password) {
                        try {
                          const credential = window.firebaseModules.auth.EmailAuthProvider.credential(
                            currentFirebaseUser.email,
                            storedUser.password
                          );
                          await window.firebaseModules.auth.reauthenticateWithCredential(currentFirebaseUser, credential);
                          console.log('✅ Re-authenticated guest user successfully with stored password');
                          reauthSuccess = true;
                        } catch (guestReauthError) {
                          console.log('⚠️ Stored password failed, prompting for password');
                          // If stored password fails, prompt user
                          password = prompt('Please enter your password to confirm account deletion:');
                          if (password) {
                            const credential = window.firebaseModules.auth.EmailAuthProvider.credential(
                              currentFirebaseUser.email,
                              password
                            );
                            await window.firebaseModules.auth.reauthenticateWithCredential(currentFirebaseUser, credential);
                            console.log('✅ Re-authenticated guest user successfully with provided password');
                            reauthSuccess = true;
                          } else {
                            throw new Error('Password required for account deletion');
                          }
                        }
                      } else {
                        // For regular email users, prompt for password
                        password = prompt('Please enter your password to confirm account deletion:');
                        if (password) {
                          const credential = window.firebaseModules.auth.EmailAuthProvider.credential(
                            currentFirebaseUser.email,
                            password
                          );
                          await window.firebaseModules.auth.reauthenticateWithCredential(currentFirebaseUser, credential);
                          console.log('✅ Re-authenticated email user successfully');
                          reauthSuccess = true;
                        } else {
                          throw new Error('Password required for account deletion');
                        }
                      }

                      // Try delete again after successful re-auth
                      if (reauthSuccess) {
                        showLoadingPopup('Deleting account...');
                        // Get fresh user reference after re-auth
                        const freshUser = window.firebaseAuth.currentUser;
                        if (freshUser) {
                          await freshUser.delete();
                          console.log('✅ Firebase auth user and email deleted successfully after re-auth');
                          // Continue to cleanup code below (DON'T return here)
                        } else {
                          throw new Error('User not found after re-authentication');
                        }
                      } else {
                        throw new Error('Re-authentication was not successful');
                      }
                    } catch (reauthError) {
                      console.error('❌ Re-authentication or deletion failed:', reauthError);
                      console.error('Re-auth error details:', reauthError.code, reauthError.message);
                      hideLoadingPopup();
                      alert('Unable to delete account. Please try again or contact support.');

                      // Sign out user on failure
                      try {
                        await window.firebaseModules.auth.signOut(window.firebaseAuth);
                        console.log('Signed out user after re-auth failure');
                      } catch (signOutError) {
                        console.error('Error signing out:', signOutError);
                      }
                      return; // Exit without completing cleanup
                    }
                  } else {
                    // Other auth errors - show error and sign out
                    console.error('❌ Auth error that is not requires-recent-login:', authError.code);
                    hideLoadingPopup();
                    alert(`Unable to delete account: ${authError.message}`);
                    try {
                      await window.firebaseModules.auth.signOut(window.firebaseAuth);
                      console.log('Signed out user after auth error');
                    } catch (signOutError) {
                      console.error('Error signing out:', signOutError);
                    }
                    return; // Exit without completing cleanup
                  }
                }
              } catch (fbError) {
                console.error('Error deleting from Firebase:', fbError);
                // Continue with local cleanup even if Firebase fails
              }
            }

            // Delete from LocalUserDB if guest user
            showLoadingPopup('Cleaning up local data...');

            if (currentUserId && storedUser && storedUser.type === 'guest') {
              LocalUserDB.deleteUser(currentUserId);
              console.log('✅ Guest user deleted from LocalUserDB:', storedUser.username);

              // Also remove from localStorage directly (double-check)
              try {
                const guestDataKeys = [
                  'blockPuzzleUsersDB', // Will be re-saved without this user
                  'currentUser',
                  'guestId',
                  'accountMode'
                ];
                // Already handled by deleteUser, but ensure it's clean
                console.log('LocalUserDB cleanup completed for guest user');
              } catch (e) {
                console.error('Error in additional guest cleanup:', e);
              }
            }

            // Clear current user session
            LocalUserDB.clearCurrentUser();
            console.log('✅ Current user session cleared');

            // Clear user-specific local storage data
            SafeStorage.clearUserData();
            console.log('User-specific local storage cleared');

            // Also clear any remaining user-specific game state from localStorage directly
            try {
              if (userIdToDelete) {
                const userPrefix = `user_${userIdToDelete}_`;
                const keysToRemove = [];
                for (let i = 0; i < localStorage.length; i++) {
                  const key = localStorage.key(i);
                  if (key && key.startsWith(userPrefix)) {
                    keysToRemove.push(key);
                  }
                }
                keysToRemove.forEach(key => localStorage.removeItem(key));
                console.log(`Removed ${keysToRemove.length} user-specific localStorage items`);
              }

              // Clear guest data too if it's a guest
              const guestKeys = [];
              for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith('guest_')) {
                  guestKeys.push(key);
                }
              }
              guestKeys.forEach(key => localStorage.removeItem(key));
              console.log(`Removed ${guestKeys.length} guest localStorage items`);

            } catch (e) {
              console.error('Error clearing user-specific localStorage:', e);
            }

            // Clear guest ID function call (for safety)
            clearGuestId();

            // Reset game boards completely
            boardClassic = Array(10).fill().map(() => Array(10).fill(null));
            boardTimed = Array(10).fill().map(() => Array(10).fill(null));
            scoreClassic = 0;
            scoreTimed = 0;

            // Clear game state completely
            clearClassicGameState();
            clearTimedGameState();

            // Redraw grids to show empty boards
            if (typeof drawGridClassic === 'function') drawGridClassic();
            if (typeof drawGridTimed === 'function') drawGridTimed();

            // Reset userData to default with fresh copy
            userData = JSON.parse(JSON.stringify(defaultUserData));

            // Clear achievement tracking variables
            totalLinesEarned = 0;
            totalExtraTimeEarned = 0;
            isGameActive = false;
            isStartupLoad = true;

            currentFirebaseUser = null;
            isUserDataLoaded = false;

            // Reset player name display to default
            const playerNameDisplay = document.getElementById('playerNameDisplay');
            if (playerNameDisplay) {
              playerNameDisplay.textContent = '🎮 Player';
              playerNameDisplay.title = '';
            }

            // Close delete modal
            if (deleteAccountModal) {
              deleteAccountModal.classList.remove('active');
              deleteAccountModal.classList.add('user-stats-hidden');
            }

            // Hide user stats and delete button
            const userStatsDisplay = document.getElementById('userStatsDisplay');
            if (userStatsDisplay) {
              userStatsDisplay.classList.add('user-stats-hidden');
            }
            if (deleteAccountBtn) {
              deleteAccountBtn.classList.add('user-stats-hidden');
            }

            // Show success message
            showLoadingPopup('✅ Account deleted successfully!');
            await new Promise(resolve => setTimeout(resolve, 1000));
            hideLoadingPopup();

            // Show welcome modal again
            if (welcomeModal) {
              welcomeModal.classList.add('active');
              welcomeModal.classList.remove('user-stats-hidden');
              enforceWelcomeUntilAuth = true;
            }

            console.log('Account deleted successfully');
          } catch (error) {
            console.error('Error deleting account:', error);
            hideLoadingPopup();
            alert('❌ Error deleting account. Please try again.');
          }
        });
      }

      // ===== FIREBASE AUTHENTICATION =====
      async function initializeFirebaseAuth() {
        // Check if there's a current user session in LocalUserDB
        const currentUserSession = LocalUserDB.getCurrentUser(); // Returns {id, type, username}
        if (currentUserSession) {
          const storedUser = LocalUserDB.findUserById(currentUserSession.id);
          if (storedUser && storedUser.type === 'guest') {
            // Auto-restore guest user session with email-based login
            console.log('Restoring guest session:', storedUser.username);

            // Show loading when restoring session
            showLoadingPopup('Restoring session...');

            try {
              // Create hidden email from username
              const guestEmail = `${storedUser.username}@flyingbird.com`;

              // Try to sign in with stored credentials
              const userCredential = await window.firebaseModules.auth.signInWithEmailAndPassword(
                window.firebaseAuth,
                guestEmail,
                storedUser.password
              );
              currentFirebaseUser = userCredential.user;
              console.log("✅ Guest session restored with email:", guestEmail);

              // Update loading message
              showLoadingPopup('Loading your data...');

              // Load user data from Firestore (unified users collection)
              try {
                // Use Firebase UID for all users (guest and email)
                const userDocRef = window.firebaseModules.firestore.doc(window.firebaseDB, 'users', currentFirebaseUser.uid);
                const userDoc = await window.firebaseModules.firestore.getDoc(userDocRef);

                if (userDoc.exists()) {
                  const firebaseData = userDoc.data();
                  userData = mergeUserData(defaultUserData, firebaseData);
                  userData.profile.displayName = storedUser.username;
                  userData.profile.email = guestEmail; // Ensure email is set
                  userData.profile.accountMode = 'guest';
                  console.log("✅ Guest data loaded from Firebase (unified users collection)");
                } else {
                  userData = mergeUserData(defaultUserData, storedUser.userData || {});
                  userData.profile.displayName = storedUser.username;
                  userData.profile.email = guestEmail; // Set guest email
                  userData.profile.accountMode = 'guest';
                }
              } catch (fbError) {
                console.error("Firebase load error:", fbError);
                userData = mergeUserData(defaultUserData, storedUser.userData || {});
                userData.profile.displayName = storedUser.username;
                userData.profile.email = guestEmail; // Set guest email
                userData.profile.accountMode = 'guest';
              }

              isUserDataLoaded = true;

              // Update UI with Firebase user
              updateAccountUI(currentFirebaseUser);
              updateUIWithUserData();
              // Sync any cloud in-progress games into local storage for resume
              await syncInProgressFromCloud();

              // Hide loading after data is loaded
              hideLoadingPopup();

              // Skip welcome modal
              enforceWelcomeUntilAuth = false;
              ensureWelcomeState();
              return;
            } catch (error) {
              hideLoadingPopup();
              console.error('Failed to restore guest session:', error);
              // Clear invalid session
              LocalUserDB.clearCurrentUser();
              // Show welcome modal for new login
              enforceWelcomeUntilAuth = true;
            }
          }
        }

        if (!window.firebaseAuth) {
          console.log("Firebase not available");
          ensureWelcomeState();
          return;
        }

        try {
          // Listen for auth state changes
          window.firebaseModules.auth.onAuthStateChanged(window.firebaseAuth, async (user) => {
            if (user) {
              // Show loading when user signs in (only if data not already loaded)
              const wasDataLoaded = isUserDataLoaded;
              if (!wasDataLoaded) {
                showLoadingPopup('Loading your data...');
              }

              currentFirebaseUser = user;
              console.log("User signed in:", user.uid);
              if (user.email) {
                // Check if this is a guest user with hidden email
                if (user.email.endsWith('@flyingbird.com')) {
                  const username = user.email.replace('@flyingbird.com', '');
                  userData.profile.displayName = username;
                  userData.profile.accountMode = 'guest';
                  console.log("Guest user with hidden email:", username);
                } else {
                  // Regular email user
                  userData.profile.email = user.email;
                  if (!userData.profile.displayName || userData.profile.displayName.startsWith('Guest-')) {
                    userData.profile.displayName = user.displayName || user.email.split('@')[0];
                  }
                }
              }
              updateAccountUI(user);
              await loadUserDataFromFirebase(user.uid);
              // Sync any in-progress games from cloud to local storage
              await syncInProgressFromCloud();

              // Hide loading after data is loaded (only if we showed it)
              if (!wasDataLoaded) {
                hideLoadingPopup();
              }

              enforceWelcomeUntilAuth = false;
              ensureWelcomeState();
            } else {
              console.log("User signed out");
              currentFirebaseUser = null;
              // Reset user data to defaults
              userData = JSON.parse(JSON.stringify(defaultUserData));
              isUserDataLoaded = false;

              // Clear game state completely
              boardClassic = Array(10).fill().map(() => Array(10).fill(null));
              boardTimed = Array(10).fill().map(() => Array(10).fill(null));
              scoreClassic = 0;
              scoreTimed = 0;
              currentThreeClassic = [];
              currentThreeTimed = [];
              selectedClassic = null;
              selectedIdxClassic = null;
              selectedTimed = null;
              selectedIdxTimed = null;
              pausedClassic = false;
              pausedTimed = false;

              // Clear game state from local storage
              clearClassicGameState();
              clearTimedGameState();

              // Hide game containers and show home
              const classicContainer = document.getElementById('classicContainer');
              const timedContainer = document.getElementById('timedContainer');
              if (classicContainer) classicContainer.style.display = 'none';
              if (timedContainer) timedContainer.style.display = 'none';
              const homeScreen = document.getElementById('homeScreen');
              if (homeScreen) homeScreen.style.display = 'block';

              // Clear pieces display
              const piecesClassic = document.getElementById('piecesClassic');
              const piecesTimed = document.getElementById('piecesTimed');
              if (piecesClassic) piecesClassic.innerHTML = '';
              if (piecesTimed) piecesTimed.innerHTML = '';

              // Redraw empty grids
              if (typeof drawGridClassic === 'function') drawGridClassic();
              if (typeof drawGridTimed === 'function') drawGridTimed();

              updateAccountUI(null);
              updateUIWithUserData();
              // Show welcome modal
              enforceWelcomeUntilAuth = true;
              ensureWelcomeState();
            }
          });
        } catch (error) {
          console.error("Firebase auth initialization failed:", error);
          ensureWelcomeState();
        }
      }

      // ===== FIRESTORE DATA MANAGEMENT =====

      // Note: saveGuestDataToFirebase is deprecated - now all users (guest and email) use saveUserDataToFirebase with Firebase UID

      async function loadUserDataFromFirebase(userId) {
        try {
          const userDocRef = window.firebaseModules.firestore.doc(window.firebaseDB, 'users', userId);
          const userDoc = await window.firebaseModules.firestore.getDoc(userDocRef);

          if (userDoc.exists()) {
            const firebaseData = userDoc.data();
            // Merge with defaults to ensure all properties exist
            userData = mergeUserData(defaultUserData, firebaseData);
            console.log("User data loaded from Firebase:", userData);

            // Reset global highscore variables from Firebase data (don't use old local values)
            highscoreClassic = userData.gameStats?.classicHighScore || 0;
            highscoreTimed = userData.gameStats?.timedHighScore || 0;
            console.log("Highscores reset from Firebase - Classic:", highscoreClassic, "Timed:", highscoreTimed);
          } else {
            // First time user - create document with defaults
            userData = { ...defaultUserData };
            const now = Date.now();
            userData.profile.createdAt = now;
            userData.profile.createdAtReadable = formatTimestampForFirebase(now);

            // Reset global highscore variables for new user
            highscoreClassic = 0;
            highscoreTimed = 0;
            console.log("New user - Highscores initialized to 0");
          }

          // Set account mode based on auth type
          userData.profile.accountMode = 'registered';

          // Restore timer state from Firebase gamePlayTimers
          if (userData.gamePlayTimers) {
            // Restore Classic timer (support both readable format and milliseconds for backward compatibility)
            if (userData.gamePlayTimers.classic) {
              const classicTimer = userData.gamePlayTimers.classic;

              // Prefer milliseconds if available, otherwise parse from readable format
              if (classicTimer.startTimeMs > 0) {
                gamePlayStartTimeClassic = classicTimer.startTimeMs;
              } else if (classicTimer.startTime && typeof classicTimer.startTime === 'string') {
                gamePlayStartTimeClassic = parseTimestampFromFirebase(classicTimer.startTime);
              } else if (typeof classicTimer.startTime === 'number' && classicTimer.startTime > 0) {
                // Backward compatibility: old format with milliseconds
                gamePlayStartTimeClassic = classicTimer.startTime;
              }

              if (classicTimer.pausedElapsedMs > 0) {
                gamePlayPausedElapsedClassic = classicTimer.pausedElapsedMs;
              } else if (classicTimer.pausedElapsed && typeof classicTimer.pausedElapsed === 'string') {
                gamePlayPausedElapsedClassic = parseElapsedTimeFromFirebase(classicTimer.pausedElapsed);
              } else if (typeof classicTimer.pausedElapsed === 'number') {
                // Backward compatibility: old format with milliseconds
                gamePlayPausedElapsedClassic = classicTimer.pausedElapsed || 0;
              }

              isGamePlayPausedClassic = classicTimer.isPaused || false;

              if (classicTimer.pausedTimeMs > 0) {
                gamePlayPausedTimeClassic = classicTimer.pausedTimeMs;
              } else if (classicTimer.pausedTime && typeof classicTimer.pausedTime === 'string') {
                gamePlayPausedTimeClassic = parseTimestampFromFirebase(classicTimer.pausedTime);
              } else if (typeof classicTimer.pausedTime === 'number') {
                // Backward compatibility: old format with milliseconds
                gamePlayPausedTimeClassic = classicTimer.pausedTime || 0;
              }

              if (gamePlayStartTimeClassic > 0) {
                console.log("✅ Classic timer restored from Firebase gamePlayTimers - startTime:", gamePlayStartTimeClassic);
              }
            }

            // Restore Timed timer (support both readable format and milliseconds for backward compatibility)
            if (userData.gamePlayTimers.timed) {
              const timedTimer = userData.gamePlayTimers.timed;

              // Prefer milliseconds if available, otherwise parse from readable format
              if (timedTimer.startTimeMs > 0) {
                gamePlayStartTimeTimed = timedTimer.startTimeMs;
              } else if (timedTimer.startTime && typeof timedTimer.startTime === 'string') {
                gamePlayStartTimeTimed = parseTimestampFromFirebase(timedTimer.startTime);
              } else if (typeof timedTimer.startTime === 'number' && timedTimer.startTime > 0) {
                // Backward compatibility: old format with milliseconds
                gamePlayStartTimeTimed = timedTimer.startTime;
              }

              if (timedTimer.pausedElapsedMs > 0) {
                gamePlayPausedElapsedTimed = timedTimer.pausedElapsedMs;
              } else if (timedTimer.pausedElapsed && typeof timedTimer.pausedElapsed === 'string') {
                gamePlayPausedElapsedTimed = parseElapsedTimeFromFirebase(timedTimer.pausedElapsed);
              } else if (typeof timedTimer.pausedElapsed === 'number') {
                // Backward compatibility: old format with milliseconds
                gamePlayPausedElapsedTimed = timedTimer.pausedElapsed || 0;
              }

              isGamePlayPausedTimed = timedTimer.isPaused || false;

              if (timedTimer.pausedTimeMs > 0) {
                gamePlayPausedTimeTimed = timedTimer.pausedTimeMs;
              } else if (timedTimer.pausedTime && typeof timedTimer.pausedTime === 'string') {
                gamePlayPausedTimeTimed = parseTimestampFromFirebase(timedTimer.pausedTime);
              } else if (typeof timedTimer.pausedTime === 'number') {
                // Backward compatibility: old format with milliseconds
                gamePlayPausedTimeTimed = timedTimer.pausedTime || 0;
              }

              if (gamePlayStartTimeTimed > 0) {
                console.log("✅ Timed timer restored from Firebase gamePlayTimers - startTime:", gamePlayStartTimeTimed);
              }
            }
          }

          refreshHighscoreCaches();
          await saveUserDataToFirebase(userId);

          isUserDataLoaded = true;
          updateUIWithUserData();
          // Data saved to Firebase only
        } catch (error) {
          console.error("Error loading user data from Firebase:", error);
          // If Firebase fails, use default data
          userData = { ...defaultUserData };
          updateUIWithUserData();
        }
      }

      async function saveUserDataToFirebase(userId) {
        if (!userId || !window.firebaseDB) return;

        try {
          // Update gamePlayTimers before saving
          if (!userData.gamePlayTimers) {
            userData.gamePlayTimers = {
              classic: {
                startTime: '',
                startTimeMs: 0,
                pausedElapsed: '00:00:00:00',
                pausedElapsedMs: 0,
                isPaused: false,
                pausedTime: '',
                pausedTimeMs: 0
              },
              timed: {
                startTime: '',
                startTimeMs: 0,
                pausedElapsed: '00:00:00:00',
                pausedElapsedMs: 0,
                isPaused: false,
                pausedTime: '',
                pausedTimeMs: 0
              }
            };
          }

          // Update Classic timer state with readable format
          if (gamePlayStartTimeClassic > 0) {
            userData.gamePlayTimers.classic = {
              startTime: formatTimestampForFirebase(gamePlayStartTimeClassic),
              startTimeMs: gamePlayStartTimeClassic, // Keep milliseconds for calculations
              pausedElapsed: formatElapsedTimeForFirebase(gamePlayPausedElapsedClassic || 0),
              pausedElapsedMs: gamePlayPausedElapsedClassic || 0, // Keep milliseconds for calculations
              isPaused: isGamePlayPausedClassic || false,
              pausedTime: gamePlayPausedTimeClassic > 0 ? formatTimestampForFirebase(gamePlayPausedTimeClassic) : '',
              pausedTimeMs: gamePlayPausedTimeClassic || 0 // Keep milliseconds for calculations
            };
          } else {
            // Reset to default if timer not started
            userData.gamePlayTimers.classic = {
              startTime: '',
              startTimeMs: 0,
              pausedElapsed: '00:00:00:00',
              pausedElapsedMs: 0,
              isPaused: false,
              pausedTime: '',
              pausedTimeMs: 0
            };
          }

          // Update Timed timer state with readable format
          if (gamePlayStartTimeTimed > 0) {
            userData.gamePlayTimers.timed = {
              startTime: formatTimestampForFirebase(gamePlayStartTimeTimed),
              startTimeMs: gamePlayStartTimeTimed, // Keep milliseconds for calculations
              pausedElapsed: formatElapsedTimeForFirebase(gamePlayPausedElapsedTimed || 0),
              pausedElapsedMs: gamePlayPausedElapsedTimed || 0, // Keep milliseconds for calculations
              isPaused: isGamePlayPausedTimed || false,
              pausedTime: gamePlayPausedTimeTimed > 0 ? formatTimestampForFirebase(gamePlayPausedTimeTimed) : '',
              pausedTimeMs: gamePlayPausedTimeTimed || 0 // Keep milliseconds for calculations
            };
          } else {
            // Reset to default if timer not started
            userData.gamePlayTimers.timed = {
              startTime: '',
              startTimeMs: 0,
              pausedElapsed: '00:00:00:00',
              pausedElapsedMs: 0,
              isPaused: false,
              pausedTime: '',
              pausedTimeMs: 0
            };
          }

          const userDocRef = window.firebaseModules.firestore.doc(window.firebaseDB, 'users', userId);
          await window.firebaseModules.firestore.setDoc(userDocRef, userData, { merge: true });
          console.log("User data saved to Firebase with gamePlayTimers (readable format):", userData.gamePlayTimers);

          // Data saved to Firebase only

          // Also save to leaderboard collection
          await saveToLeaderboard(userId);
        } catch (error) {
          console.error("Error saving user data to Firebase:", error);
        }
      }

      // Save user scores to leaderboard
      async function saveToLeaderboard(userId) {
        if (!userId || !window.firebaseDB) return;

        try {
          const leaderboardData = {
            displayName: userData.profile.displayName || 'Guest Player',
            country: userData.profile.country || 'Other',
            classicHighScore: userData.gameStats.classicHighScore || 0,
            timedHighScore: userData.gameStats.timedHighScore || 0,
            lastUpdated: window.firebaseModules.firestore.serverTimestamp()
          };

          console.log("Saving to leaderboard:", leaderboardData);

          const leaderboardRef = window.firebaseModules.firestore.doc(window.firebaseDB, 'leaderboard', userId);
          await window.firebaseModules.firestore.setDoc(leaderboardRef, leaderboardData, { merge: true });
          console.log("Leaderboard updated successfully");
        } catch (error) {
          console.error("Error updating leaderboard:", error);
        }
      }

      // Save game history to Firebase
      async function saveGameHistoryToFirebase(gameResult) {
        if (!currentFirebaseUser || !window.firebaseDB) return;

        try {
          const historyRef = window.firebaseModules.firestore.collection(window.firebaseDB, 'users', currentFirebaseUser.uid, 'gameHistory');
          await window.firebaseModules.firestore.addDoc(historyRef, {
            score: gameResult.score,
            lines: gameResult.lines,
            duration: gameResult.duration,
            level: gameResult.level,
            timestamp: window.firebaseModules.firestore.serverTimestamp(),
            blocks: gameResult.blocks || 0
          });
          console.log("Game history saved to Firebase");
        } catch (error) {
          console.error("Error saving game history:", error);
        }
      }

      // ===== CLOUD IN-PROGRESS GAME SYNC (Firestore) =====
      // Store unfinished games in Firestore so users can resume on another device.
      function debounce(fn, delay) {
        let t;
        return function (...args) {
          clearTimeout(t);
          t = setTimeout(() => fn.apply(this, args), delay);
        };
      }

      function isGuestEmail(email) {
        return typeof email === 'string' && email.endsWith('@flyingbird.com');
      }
      function getActiveUserDocRef() {
        if (!window.firebaseDB) return null;

        // All users (both guest and email) now use the same 'users' collection with Firebase UID
        if (currentFirebaseUser && currentFirebaseUser.uid) {
          const ref = window.firebaseModules.firestore.doc(window.firebaseDB, 'users', currentFirebaseUser.uid);
          // Determine if guest based on email domain
          const isGuest = currentFirebaseUser.email && currentFirebaseUser.email.endsWith('@flyingbird.com');
          return { ref, kind: isGuest ? 'guest' : 'registered' };
        }

        return null;
      }

      function sanitizeGameStateForCloud(mode, state) {
        if (!state) return null;
        const base = { ...state };

        // Firebase doesn't support nested arrays directly, so serialize them
        if (base.board && Array.isArray(base.board)) {
          base.board = JSON.stringify(base.board);
        }
        if (base.currentPieces && Array.isArray(base.currentPieces)) {
          base.currentPieces = JSON.stringify(base.currentPieces);
        }

        // Add metadata for conflict resolution
        base.updatedAt = window.firebaseModules.firestore.serverTimestamp();
        base.updatedAtMs = Date.now();
        base.mode = mode;
        return base;
      }

      function sanitizeGameStateForLocal(state) {
        if (!state) return null;
        const copy = { ...state };

        if (typeof copy.board === 'string') {
          try {
            copy.board = JSON.parse(copy.board);
          } catch (e) {
            console.error("Failed to parse board from cloud:", e);
            copy.board = Array(10).fill().map(() => Array(10).fill(null));
          }
        }

        if (typeof copy.currentPieces === 'string') {
          try {
            copy.currentPieces = JSON.parse(copy.currentPieces);
          } catch (e) {
            console.error("Failed to parse currentPieces from cloud:", e);
            copy.currentPieces = [];
          }
        }

        // Remove Firestore-only fields from local cache
        delete copy.updatedAt;
        return copy;
      }

      // Check if username exists in Firebase users collection
      async function checkUsernameInFirebase(username) {
        try {
          if (!window.firebaseDB) return { exists: false, suggested: null };

          // Search all users in Firebase for matching displayName
          const usersRef = window.firebaseModules.firestore.collection(window.firebaseDB, 'users');
          const query = window.firebaseModules.firestore.query(
            usersRef,
            window.firebaseModules.firestore.where('profile.displayName', '==', username)
          );

          const querySnapshot = await window.firebaseModules.firestore.getDocs(query);

          if (!querySnapshot.empty) {
            // Username exists, suggest alternatives
            let suggested = username;
            let counter = 1;
            let found = false;

            // Try to find an available username
            while (!found && counter < 1000) {
              suggested = `${username}${counter}`;
              const checkQuery = window.firebaseModules.firestore.query(
                usersRef,
                window.firebaseModules.firestore.where('profile.displayName', '==', suggested)
              );
              const checkSnapshot = await window.firebaseModules.firestore.getDocs(checkQuery);
              if (checkSnapshot.empty) {
                found = true;
              } else {
                counter++;
              }
            }

            return { exists: true, suggested: found ? suggested : `${username}${Date.now()}` };
          }

          return { exists: false, suggested: null };
        } catch (e) {
          console.warn('Error checking username in Firebase:', e);
          // On error, assume it doesn't exist to allow signup
          return { exists: false, suggested: null };
        }
      }

      async function saveInProgressToCloud(mode, gameState) {
        try {
          const ctx = getActiveUserDocRef();
          if (!ctx || !gameState) return;
          const cloudState = sanitizeGameStateForCloud(mode, gameState);
          const payload = { inProgress: {} };
          payload.inProgress[mode] = cloudState;
          await window.firebaseModules.firestore.setDoc(ctx.ref, payload, { merge: true });
          console.log(`[Cloud] Saved in-progress ${mode} game to Firebase`, cloudState.timerState ? `with timerState: ${JSON.stringify(cloudState.timerState)}` : 'without timerState');
        } catch (e) {
          console.warn('Failed to save in-progress to cloud:', e);
        }
      }

      // Force save game state to Firebase immediately (not debounced)
      async function forceSaveGameStateToFirebase() {
        try {
          if (!currentFirebaseUser || !window.firebaseDB) return;

          // Save classic game state if active
          const classicContainer = document.getElementById('classicContainer');
          if (classicContainer && classicContainer.style.display !== 'none' && isGameActive) {
            // Get timer state
            const timerState = {
              startTime: gamePlayStartTimeClassic || 0,
              pausedElapsed: gamePlayPausedElapsedClassic || 0,
              isPaused: isGamePlayPausedClassic || false,
              pausedTime: gamePlayPausedTimeClassic || 0
            };

            const gameState = {
              mode: 'classic',
              score: scoreClassic || 0,
              board: boardClassic ? JSON.parse(JSON.stringify(boardClassic)) : Array(10).fill().map(() => Array(10).fill(null)),
              currentPieces: currentThreeClassic ? JSON.parse(JSON.stringify(currentThreeClassic)) : [],
              selectedIdx: selectedIdxClassic || null,
              totalLines: totalLinesClassic || 0,
              totalBlocks: totalBlocksPlaced || 0,
              gameStartTime: gameStartTime || Date.now(),
              undoCredits: (typeof undoCountClassic === 'number' ? undoCountClassic : 3),
              isPaused: true,
              timerState: timerState, // Include timer state
              timestamp: Date.now()
            };
            await saveInProgressToCloud('classic', gameState);
          }

          // Save timed game state if active
          const timedContainer = document.getElementById('timedContainer');
          if (timedContainer && timedContainer.style.display !== 'none' && isGameActive) {
            // Get timer state
            const timerState = {
              startTime: gamePlayStartTimeTimed || 0,
              pausedElapsed: gamePlayPausedElapsedTimed || 0,
              isPaused: isGamePlayPausedTimed || false,
              pausedTime: gamePlayPausedTimeTimed || 0
            };

            const gameState = {
              mode: 'timed',
              score: scoreTimed || 0,
              timer: timer || 300,
              board: boardTimed ? JSON.parse(JSON.stringify(boardTimed)) : Array(10).fill().map(() => Array(10).fill(null)),
              currentPieces: currentThreeTimed ? JSON.parse(JSON.stringify(currentThreeTimed)) : [],
              selectedIdx: selectedIdxTimed || null,
              totalLines: totalLinesTimed || 0,
              totalBlocks: totalBlocksPlacedTimed || 0,
              extraTimeEarned: extraTimeEarnedInGame || 0,
              currentLevel: currentLevelTimed || 1,
              gameStartTime: gameStartTime || Date.now(),
              undoCredits: (typeof undoCountTimed === 'number' ? undoCountTimed : 3),
              isPaused: true,
              timerState: timerState, // Include timer state
              timestamp: Date.now()
            };
            await saveInProgressToCloud('timed', gameState);
          }

          console.log('✅ Game state force saved to Firebase');
        } catch (e) {
          console.warn('Failed to force save game state to Firebase:', e);
        }
      }

      // Debounced save functions removed - now saving directly to Firebase immediately

      async function deleteInProgressFromCloud(mode) {
        try {
          // Only delete if user is still logged in
          if (!window.firebaseAuth || !window.firebaseAuth.currentUser) {
            console.log('User not logged in, skipping cloud delete');
            return;
          }
          const ctx = getActiveUserDocRef();
          if (!ctx) return;
          // Mark specific mode as cleared (set to null) while preserving the other
          const payload = { inProgress: {} };
          payload.inProgress[mode] = null;
          await window.firebaseModules.firestore.setDoc(ctx.ref, payload, { merge: true });
        } catch (e) {
          // Only log warning if it's not a permission error (user might be signed out)
          if (e.code !== 'permission-denied' && e.code !== 'missing-or-insufficient-permissions') {
            console.warn('Failed to delete in-progress from cloud:', e);
          }
        }
      }

      async function syncInProgressFromCloud() {
        // This function is kept for compatibility but no longer syncs to localStorage
        // Game state is now loaded directly from Firebase when needed
        // No localStorage sync needed - Firebase is the only source of truth
        console.log('syncInProgressFromCloud called - Firebase is now the only source, no localStorage sync needed');
      }

      // ===== LOCAL STORAGE FALLBACK =====
      // Removed: All data now saved to Firebase only
      // Local storage is only used for login session (handled by LocalUserDB)
      function saveLocalUserData() {
        // No longer saving user data to local storage - all data goes to Firebase
        // Only login session is saved locally via LocalUserDB
      }

      function loadLocalUserData() {
        // No longer loading user data from local storage - all data comes from Firebase
        return null;
      }

      function saveAccountMode(mode) {
        SafeStorage.setItem('blockPuzzleAccountMode', mode);
        console.log("Account mode saved:", mode);
      }

      function getStoredAccountMode() {
        return SafeStorage.getItem('blockPuzzleAccountMode') || null;
      }

      // ===== GAME STATE PERSISTENCE =====
      // ===== SEPARATE GAME STATE STORAGE =====
      const CLASSIC_GAME_STATE_KEY = "blockPuzzle_classicGameState";
      const TIMED_GAME_STATE_KEY = "blockPuzzle_timedGameState";

      async function saveClassicGameState() {
        if (!isGameActive) return;

        const classicContainer = document.getElementById('classicContainer');
        if (classicContainer && classicContainer.style.display !== 'none') {
          // Get timer state
          const timerState = {
            startTime: gamePlayStartTimeClassic || 0,
            pausedElapsed: gamePlayPausedElapsedClassic || 0,
            isPaused: isGamePlayPausedClassic || false,
            pausedTime: gamePlayPausedTimeClassic || 0
          };

          const gameState = {
            mode: 'classic',
            score: scoreClassic || 0,
            board: boardClassic ? JSON.parse(JSON.stringify(boardClassic)) : Array(10).fill().map(() => Array(10).fill(null)),
            currentPieces: currentThreeClassic ? JSON.parse(JSON.stringify(currentThreeClassic)) : [randomShape(), randomShape(), randomShape()],
            selectedIdx: selectedIdxClassic || null,
            totalLines: totalLinesClassic || 0,
            totalBlocks: totalBlocksPlaced || 0,
            gameStartTime: gameStartTime || Date.now(),
            undoCredits: (typeof undoCountClassic === 'number' ? undoCountClassic : 3),
            isPaused: false, // Save as active game, not paused
            timerState: timerState, // Save timer state to Firebase
            timestamp: Date.now()
          };

          // Save to Firebase ONLY (no localStorage)
          try {
            await saveInProgressToCloud('classic', gameState);
            console.log("✅ Classic game state saved to Firebase:", gameState.score, "TimerState:", timerState);
          } catch (e) {
            console.error("Failed to save classic game state to Firebase:", e);
          }
        }
      }

      async function saveTimedGameState() {
        if (!isGameActive) return;

        const timedContainer = document.getElementById('timedContainer');
        if (timedContainer && timedContainer.style.display !== 'none') {
          // Get timer state
          const timerState = {
            startTime: gamePlayStartTimeTimed || 0,
            pausedElapsed: gamePlayPausedElapsedTimed || 0,
            isPaused: isGamePlayPausedTimed || false,
            pausedTime: gamePlayPausedTimeTimed || 0
          };

          const gameState = {
            mode: 'timed',
            score: scoreTimed || 0,
            timer: timer || 300,
            board: boardTimed ? JSON.parse(JSON.stringify(boardTimed)) : Array(10).fill().map(() => Array(10).fill(null)),
            currentPieces: currentThreeTimed ? JSON.parse(JSON.stringify(currentThreeTimed)) : [randomShape(), randomShape(), randomShape()],
            selectedIdx: selectedIdxTimed || null,
            totalLines: totalLinesTimed || 0,
            totalBlocks: totalBlocksPlacedTimed || 0,
            extraTimeEarned: extraTimeEarnedInGame || 0,
            currentLevel: currentLevelTimed || 1,
            gameStartTime: gameStartTime || Date.now(),
            undoCredits: (typeof undoCountTimed === 'number' ? undoCountTimed : 3),
            isPaused: false, // Save as active game, not paused
            timerState: timerState, // Save timer state to Firebase
            timestamp: Date.now()
          };

          // Save to Firebase ONLY (no localStorage)
          try {
            await saveInProgressToCloud('timed', gameState);
            console.log("✅ Timed game state saved to Firebase:", gameState.score, "Timer:", gameState.timer, "TimerState:", timerState);
          } catch (e) {
            console.error("Failed to save timed game state to Firebase:", e);
          }
        }
      }

      async function loadClassicGameState() {
        try {
          // Load from Firebase ONLY (no localStorage)
          const ctx = getActiveUserDocRef();
          if (!ctx) return null;

          const snap = await window.firebaseModules.firestore.getDoc(ctx.ref);
          if (!snap.exists()) return null;

          const data = snap.data();
          const cloudState = (data && data.inProgress && data.inProgress.classic) || null;

          if (cloudState) {
            // Sanitize and return the game state from Firebase
            const gameState = sanitizeGameStateForLocal(cloudState);
            console.log("✅ Classic game state loaded from Firebase:", gameState.score);
            return gameState;
          }

          return null;
        } catch (error) {
          console.error("Error loading classic game state from Firebase:", error);
          return null;
        }
      }

      async function loadTimedGameState() {
        try {
          // Load from Firebase ONLY (no localStorage)
          const ctx = getActiveUserDocRef();
          if (!ctx) return null;

          const snap = await window.firebaseModules.firestore.getDoc(ctx.ref);
          if (!snap.exists()) return null;

          const data = snap.data();
          const cloudState = (data && data.inProgress && data.inProgress.timed) || null;

          if (cloudState) {
            // Sanitize and return the game state from Firebase
            const gameState = sanitizeGameStateForLocal(cloudState);
            console.log("✅ Timed game state loaded from Firebase:", gameState.score, "Timer:", gameState.timer);
            return gameState;
          }

          return null;
        } catch (error) {
          console.error("Error loading timed game state from Firebase:", error);
          return null;
        }
      }

      async function clearClassicGameState() {
        // Don't stop interval ad timer here - let it continue for next game
        // Timer will only stop when player goes home
        // Clear from Firebase ONLY (no localStorage)
        await deleteInProgressFromCloud('classic');
        console.log("Classic game state cleared from Firebase");
      }

      async function clearTimedGameState() {
        // Don't stop interval ad timer here - let it continue for next game
        // Timer will only stop when player goes home
        // Clear from Firebase ONLY (no localStorage)
        await deleteInProgressFromCloud('timed');
        console.log("Timed game state cleared from Firebase");
      }

      // Functions to save/restore manual pause status
      function saveManualPauseStatus() {
        SafeStorage.setItem('blockPuzzle_manualPauseStatus', JSON.stringify({
          isManuallyPaused: isManuallyPaused,
          timestamp: Date.now()
        }));
        console.log("Manual pause status saved:", isManuallyPaused);
      }

      function loadManualPauseStatus() {
        try {
          const data = SafeStorage.getItem('blockPuzzle_manualPauseStatus');
          if (data) {
            const status = JSON.parse(data);
            console.log("Loaded manual pause status:", status.isManuallyPaused);
            return status.isManuallyPaused;
          }
        } catch (error) {
          console.error("Error loading manual pause status:", error);
        }
        return false;
      }

      function clearManualPauseStatus() {
        SafeStorage.removeItem('blockPuzzle_manualPauseStatus');
        console.log("Manual pause status cleared");
      }

      function showPausePopup(mode) {
        const popup = document.getElementById(mode === 'classic' ? 'pausePopupClassic' : 'pausePopupTimed');
        if (popup) {
          popup.style.display = 'block';
          // Pause music when pause popup is shown
          pauseMusicAndEffects();
          if (currentBgMusic && currentBgMusic.paused) {
            console.log("🔇 Music paused - pause popup shown");
          }
        }
      }

      function hidePausePopup(mode) {
        const popup = document.getElementById(mode === 'classic' ? 'pausePopupClassic' : 'pausePopupTimed');
        if (popup) popup.style.display = 'none';
      }

      // Helper function for smooth screen transitions to prevent flashing
      function transitionToScreen(hideElementId, showElementId) {
        const hideEl = document.getElementById(hideElementId);
        const showEl = document.getElementById(showElementId);


        if (!hideEl || !showEl) {
          // Fallback if elements don't exist
          if (hideEl) {
            hideEl.style.display = 'none';
            hideEl.style.opacity = '0';
            hideEl.style.visibility = 'hidden';
          }
          if (showEl) {
            showEl.style.display = 'flex';
            showEl.style.opacity = '1';
            showEl.style.visibility = 'visible';
          }
          return;
        }

        // Ensure new screen is completely hidden before showing
        if (showEl.classList.contains('gameContainer')) {
          // For game containers, keep display none until ready to show
          showEl.style.display = 'none';
          showEl.style.opacity = '0';
          showEl.style.visibility = 'hidden';
          showEl.style.pointerEvents = 'none';
          showEl.style.background = 'transparent';
        } else {
          showEl.style.display = 'flex';
          showEl.style.opacity = '0';
          showEl.style.visibility = 'hidden';
        }
        // Force reflow to ensure display change is applied
        showEl.offsetHeight;

        // If hide element is already hidden, skip fade out
        if (hideEl.style.display === 'none' || hideEl.style.opacity === '0') {
          hideEl.style.display = 'none';
          hideEl.style.opacity = '0';
          hideEl.style.visibility = 'hidden';
          // Show new screen immediately if old screen is already hidden
          requestAnimationFrame(() => {
            if (showEl.classList.contains('gameContainer')) {
              // Restore background and show game container
              showEl.style.background = '';
              showEl.style.display = 'flex';
              showEl.style.pointerEvents = 'auto';
            }
            showEl.style.opacity = '1';
            showEl.style.visibility = 'visible';
          });
        } else {
          // Fade out current screen quickly
          hideEl.style.opacity = '0';
          hideEl.style.visibility = 'hidden';

          // Show new screen immediately after fade out starts
          requestAnimationFrame(() => {
            hideEl.style.display = 'none';
            hideEl.style.opacity = '0';
            hideEl.style.visibility = 'hidden';

            // Enable pointer events and restore background on new screen
            if (showEl.classList.contains('gameContainer')) {
              showEl.style.background = '';
              showEl.style.display = 'flex';
              showEl.style.pointerEvents = 'auto';
            }

            // Fade in new screen immediately
            showEl.style.opacity = '1';
            showEl.style.visibility = 'visible';
          });
        }
      }

      // Auto-pause functions for seamless game interruption handling
      async function autoPauseCurrentGame() {
        const classicContainer = document.getElementById('classicContainer');
        const timedContainer = document.getElementById('timedContainer');

        // Set flag to indicate manual pause/exit to prevent game over popups
        console.log("Setting manual pause flag to prevent game over");
        isManuallyPaused = true;
        gameOverGloballyDisabled = true;

        // Save manual pause status to survive page reload
        saveManualPauseStatus();

        if (classicContainer && classicContainer.style.display !== 'none') {
          // Pause game play timer when auto-pausing
          pauseGamePlayTimer('classic');

          // Auto-pause classic game
          console.log("📱 Auto-pausing classic game (tab switch/minimize)");
          pausedClassic = {
            score: scoreClassic,
            board: JSON.parse(JSON.stringify(boardClassic)),
            currentThree: JSON.parse(JSON.stringify(currentThreeClassic)),
            selectedIdx: selectedIdxClassic,
            timer: null
          };
          stopUndoRecharge("classic");

          // Pause music immediately
          pauseMusicAndEffects();
          if (currentBgMusic && currentBgMusic.paused) {
            console.log("🔇 Music paused due to auto-pause");
          }

          // Show both pause overlay and popup
          document.getElementById("pauseOverlayClassic").style.display = "block";
          showPausePopup('classic');

          // Save game state to Firebase
          await saveClassicGameState();
          console.log("✅ Classic game auto-paused and saved to Firebase");

        } else if (timedContainer && timedContainer.style.display !== 'none') {
          // Pause game play timer when auto-pausing
          pauseGamePlayTimer('timed');

          // Auto-pause timed game
          console.log("📱 Auto-pausing timed game (tab switch/minimize)");
          pausedTimed = {
            score: scoreTimed,
            board: JSON.parse(JSON.stringify(boardTimed)),
            currentThree: JSON.parse(JSON.stringify(currentThreeTimed)),
            selectedIdx: selectedIdxTimed,
            timer: timer
          };
          clearInterval(timerInterval);
          clearInterval(bonusCellInterval);
          stopUndoRecharge("timed");

          // Pause music immediately
          pauseMusicAndEffects();
          if (currentBgMusic && currentBgMusic.paused) {
            console.log("🔇 Music paused due to auto-pause");
          }

          // Ensure timer doesn't go below 1
          if (typeof timer === 'number' && timer <= 0) {
            timer = 1;
            const timerDisplay = document.getElementById('timerDisplay');
            if (timerDisplay) timerDisplay.textContent = "Time: " + timer;
          }

          // Show both pause overlay and popup
          document.getElementById("pauseOverlayTimed").style.display = "block";
          showPausePopup('timed');

          // Save game state to Firebase
          await saveTimedGameState();
          console.log("✅ Timed game auto-paused and saved to Firebase");
        }
      }
      function saveGameState() {
        let gameState = null;

        // Check for paused states first (higher priority)
        if (pausedClassic && pausedClassic.board) {
          gameState = {
            mode: 'classic',
            score: pausedClassic.score || 0,
            board: JSON.parse(JSON.stringify(pausedClassic.board)),
            currentPieces: pausedClassic.currentThree ? JSON.parse(JSON.stringify(pausedClassic.currentThree)) : null,
            selectedIdx: pausedClassic.selectedIdx || null,
            totalLines: totalLinesClassic || 0,
            totalBlocks: totalBlocksPlaced || 0,
            gameStartTime: gameStartTime || null,
            undoCredits: (typeof undoCountClassic === 'number' ? undoCountClassic : 3),
            isPaused: true,
            timestamp: Date.now()
          };
        } else if (pausedTimed && pausedTimed.board) {
          gameState = {
            mode: 'timed',
            score: pausedTimed.score || 0,
            timer: pausedTimed.timer || 300,
            board: JSON.parse(JSON.stringify(pausedTimed.board)),
            currentPieces: pausedTimed.currentThree ? JSON.parse(JSON.stringify(pausedTimed.currentThree)) : null,
            selectedIdx: pausedTimed.selectedIdx || null,
            totalLines: totalLinesTimed || 0,
            totalBlocks: totalBlocksPlacedTimed || 0,
            extraTimeEarned: extraTimeEarnedInGame || 0,
            currentLevel: currentLevelTimed || 1,
            gameStartTime: gameStartTime || null,
            undoCredits: (typeof undoCountTimed === 'number' ? undoCountTimed : 3),
            isPaused: true,
            timestamp: Date.now()
          };
        } else if (isGameActive) {
          // Check which game is currently active (only if not paused)
          const classicContainer = document.getElementById('classicContainer');
          const timedContainer = document.getElementById('timedContainer');

          if (classicContainer && classicContainer.style.display !== 'none') {
            // Classic game is active
            gameState = {
              mode: 'classic',
              score: scoreClassic || 0,
              board: boardClassic ? JSON.parse(JSON.stringify(boardClassic)) : null,
              currentPieces: currentThreeClassic ? JSON.parse(JSON.stringify(currentThreeClassic)) : null,
              totalLines: totalLinesClassic || 0,
              totalBlocks: totalBlocksPlaced || 0,
              gameStartTime: gameStartTime || null,
              undoCredits: (typeof undoCountClassic === 'number' ? undoCountClassic : 3),
              isPaused: false,
              timestamp: Date.now()
            };
          } else if (timedContainer && timedContainer.style.display !== 'none') {
            // Timed game is active
            gameState = {
              mode: 'timed',
              score: scoreTimed || 0,
              timer: timer || 300,
              board: boardTimed ? JSON.parse(JSON.stringify(boardTimed)) : null,
              currentPieces: currentThreeTimed ? JSON.parse(JSON.stringify(currentThreeTimed)) : null,
              totalLines: totalLinesTimed || 0,
              totalBlocks: totalBlocksPlacedTimed || 0,
              extraTimeEarned: extraTimeEarnedInGame || 0,
              currentLevel: currentLevelTimed || 1,
              gameStartTime: gameStartTime || null,
              undoCredits: (typeof undoCountTimed === 'number' ? undoCountTimed : 3),
              isPaused: false,
              timestamp: Date.now()
            };
          }
        }

        if (gameState) {
          // Save to Firebase ONLY (no localStorage)
          if (gameState.mode === 'classic') {
            saveInProgressToCloud('classic', gameState);
          } else if (gameState.mode === 'timed') {
            saveInProgressToCloud('timed', gameState);
          }
          console.log("Game state saved to Firebase:", gameState.mode, "isPaused:", gameState.isPaused);
        }
      }

      function loadGameState() {
        try {
          const savedState = SafeStorage.getItem(GAME_STATE_KEY);
          if (!savedState) return null;

          const gameState = JSON.parse(savedState);

          // Check if saved state is recent (within 24 hours)
          const timeDiff = Date.now() - (gameState.timestamp || 0);
          if (timeDiff > 24 * 60 * 60 * 1000) {
            console.log("Saved game state is too old, clearing");
            clearGameState();
            return null;
          }

          return gameState;
        } catch (error) {
          console.error("Error loading game state:", error);
          return null;
        }
      }

      function clearGameState() {
        SafeStorage.removeItem(GAME_STATE_KEY);
        console.log("Game state cleared");
      }

      function restoreClassicGameState(gameState) {
        if (!gameState) return false;

        try {
          console.log("=== RESTORING CLASSIC GAME STATE ===");
          console.log("Score:", gameState.score, "Board valid:", Array.isArray(gameState.board));

          // NUCLEAR OPTION: Globally disable game over during entire restore process
          console.log("🚫 GLOBALLY DISABLING game over during restore");
          gameOverGloballyDisabled = true;

          // Set flag to prevent game over checks during restore
          isGameRestoring = true;

          // Restore classic game state
          scoreClassic = gameState.score || 0;
          boardClassic = gameState.board && Array.isArray(gameState.board) ?
            JSON.parse(JSON.stringify(gameState.board)) :
            Array(10).fill().map(() => Array(10).fill(null));

          // Fix: Ensure pieces exist, generate if empty
          if (gameState.currentPieces && Array.isArray(gameState.currentPieces) && gameState.currentPieces.length > 0) {
            currentThreeClassic = JSON.parse(JSON.stringify(gameState.currentPieces));
          } else {
            console.warn("⚠️ No pieces in saved state, generating new ones");
            currentThreeClassic = [randomShape(), randomShape(), randomShape()];
          }

          totalLinesClassic = gameState.totalLines || 0;
          totalBlocksPlaced = gameState.totalBlocks || 0;
          gameStartTime = gameState.gameStartTime || Date.now();
          undoCountClassic = Math.min(gameState.undoCredits || 3, MAX_UNDO);
          undoCreditsClassic = undoCountClassic;
          selectedIdxClassic = gameState.selectedIdx || null;

          // Restore timer state from Firebase
          // IMPORTANT: NEVER reset timer if it was already running
          if (gameState.timerState && gameState.timerState.startTime > 0) {
            // Restore timer from Firebase
            gamePlayStartTimeClassic = gameState.timerState.startTime || 0;
            gamePlayPausedElapsedClassic = gameState.timerState.pausedElapsed || 0;
            isGamePlayPausedClassic = gameState.timerState.isPaused || false;
            gamePlayPausedTimeClassic = gameState.timerState.pausedTime || 0;
            // Save to persistent storage
            saveTimerStateToStorage('classic');
            console.log("✅ Classic timer state restored from Firebase - startTime:", gamePlayStartTimeClassic, "isPaused:", isGamePlayPausedClassic);
          } else if (gamePlayStartTimeClassic === 0) {
            // Try to load from persistent storage first
            if (!loadTimerStateFromStorage('classic')) {
              // Only start new timer if it was never started before (first time entering)
              // If timer was already running, preserve it - don't reset
              gamePlayStartTimeClassic = Date.now();
              isGamePlayPausedClassic = false;
              gamePlayPausedElapsedClassic = 0;
              gamePlayPausedTimeClassic = 0;
              saveTimerStateToStorage('classic');
              console.log("✅ Classic timer started (first time, no saved state in Firebase)");
            } else {
              console.log("✅ Classic timer loaded from persistent storage - startTime:", gamePlayStartTimeClassic);
            }
          } else {
            // Timer was already running - preserve it, don't reset
            saveTimerStateToStorage('classic');
            console.log("✅ Classic timer already running - preserving existing timer, startTime:", gamePlayStartTimeClassic);
          }

          console.log("Classic state restored - Score:", scoreClassic, "Board size:", boardClassic.length);

          // Start session time tracking if not already active
          if (!isGameSessionActive) {
            sessionStartTime = Date.now();
            isGameSessionActive = true;
            console.log('Game session started during restore');
          }

          // Show classic game - use smooth transition
          pushToNavigationStack('classic');

          // Ensure game container is ready before transition
          const classicContainerEl = document.getElementById('classicContainer');
          if (classicContainerEl) {
            classicContainerEl.style.opacity = '0';
            classicContainerEl.style.visibility = 'hidden';
            classicContainerEl.style.pointerEvents = 'none';
          }

          transitionToScreen('homeScreen', 'classicContainer');

          // Start background music for Classic mode
          startMusic('classic');

          // Start timer after restoring game (timer state already restored above)
          // Timer will automatically start if it was never started, or resume if it was paused
          startGamePlayTimer('classic');

          // Update timer display immediately after restore
          updateGamePlayTimer('classic');

          // Update UI
          document.getElementById("scoreClassic").textContent = "Score: " + scoreClassic;
          console.log("Drawing classic grid...");
          isDrawingOnly = true; // Set flag to prevent game over checks during drawing
          drawGridClassic();
          console.log("Drawing classic pieces...");
          drawPiecesClassic();
          isDrawingOnly = false; // Reset flag after drawing
          updateUndoButtons();

          // Set game as active
          isGameActive = true;
          isManuallyPaused = false; // Reset flag since we're restoring (not manually paused anymore)

          // Clear saved manual pause status since we're now in controlled pause state
          clearManualPauseStatus();

          // Handle pause state - if game was active when saved, restore as paused
          // (User needs to click Resume to continue)
          pausedClassic = {
            score: scoreClassic,
            board: JSON.parse(JSON.stringify(boardClassic)),
            currentThree: JSON.parse(JSON.stringify(currentThreeClassic)),
            selectedIdx: selectedIdxClassic,
            timer: null
          };
          console.log("Showing pause overlay for classic...");
          document.getElementById("pauseOverlayClassic").style.display = "block";
          showPausePopup('classic');

          // Clear restore flag now that restore is complete
          isGameRestoring = false;

          // Force hide any game over popups that might have appeared
          forceHideGameOverIfNeeded();

          // Re-enable game over immediately after restore is complete
          gameOverGloballyDisabled = false;
          console.log("✅ Game over GLOBALLY RE-ENABLED after Classic restore");

          return true;
        } catch (error) {
          console.error("Error restoring classic game state:", error);
          isGameRestoring = false; // Reset flag on error
          gameOverGloballyDisabled = false; // Reset global flag on error
          clearClassicGameState();
          return false;
        }
      }

      function restoreTimedGameState(gameState) {
        if (!gameState) return false;

        try {
          console.log("=== RESTORING TIMED GAME STATE ===");
          console.log("Score:", gameState.score, "Timer:", gameState.timer, "Board valid:", Array.isArray(gameState.board));

          // NUCLEAR OPTION: Globally disable game over during entire restore process
          console.log("🚫 GLOBALLY DISABLING game over during restore");
          gameOverGloballyDisabled = true;

          // Set flag to prevent game over checks during restore
          isGameRestoring = true;

          // Restore timed game state
          scoreTimed = gameState.score || 0;
          timer = gameState.timer || 300;
          boardTimed = gameState.board && Array.isArray(gameState.board) ?
            JSON.parse(JSON.stringify(gameState.board)) :
            Array(10).fill().map(() => Array(10).fill(null));

          // Fix: Ensure pieces exist, generate if empty
          if (gameState.currentPieces && Array.isArray(gameState.currentPieces) && gameState.currentPieces.length > 0) {
            currentThreeTimed = JSON.parse(JSON.stringify(gameState.currentPieces));
          } else {
            console.warn("⚠️ No pieces in saved state, generating new ones");
            currentThreeTimed = [randomShape(), randomShape(), randomShape()];
          }

          totalLinesTimed = gameState.totalLines || 0;
          totalBlocksPlacedTimed = gameState.totalBlocks || 0;
          extraTimeEarnedInGame = gameState.extraTimeEarned || 0;
          currentLevelTimed = gameState.currentLevel || 1;
          gameStartTime = gameState.gameStartTime || Date.now();
          undoCountTimed = Math.min(gameState.undoCredits || 3, MAX_UNDO);
          undoCreditsTimed = undoCountTimed;
          selectedIdxTimed = gameState.selectedIdx || null;

          // Restore timer state from Firebase
          // IMPORTANT: NEVER reset timer if it was already running
          if (gameState.timerState && gameState.timerState.startTime > 0) {
            // Restore timer from Firebase
            gamePlayStartTimeTimed = gameState.timerState.startTime || 0;
            gamePlayPausedElapsedTimed = gameState.timerState.pausedElapsed || 0;
            isGamePlayPausedTimed = gameState.timerState.isPaused || false;
            gamePlayPausedTimeTimed = gameState.timerState.pausedTime || 0;
            // Save to persistent storage
            saveTimerStateToStorage('timed');
            console.log("✅ Timed timer state restored from Firebase - startTime:", gamePlayStartTimeTimed, "isPaused:", isGamePlayPausedTimed);
          } else if (gamePlayStartTimeTimed === 0) {
            // Try to load from persistent storage first
            if (!loadTimerStateFromStorage('timed')) {
              // Only start new timer if it was never started before (first time entering)
              // If timer was already running, preserve it - don't reset
              gamePlayStartTimeTimed = Date.now();
              isGamePlayPausedTimed = false;
              gamePlayPausedElapsedTimed = 0;
              gamePlayPausedTimeTimed = 0;
              saveTimerStateToStorage('timed');
              console.log("✅ Timed timer started (first time, no saved state in Firebase)");
            } else {
              console.log("✅ Timed timer loaded from persistent storage - startTime:", gamePlayStartTimeTimed);
            }
          } else {
            // Timer was already running - preserve it, don't reset
            saveTimerStateToStorage('timed');
            console.log("✅ Timed timer already running - preserving existing timer, startTime:", gamePlayStartTimeTimed);
          }

          console.log("Timed state restored - Score:", scoreTimed, "Timer:", timer, "Board size:", boardTimed.length);

          // Start session time tracking if not already active
          if (!isGameSessionActive) {
            sessionStartTime = Date.now();
            isGameSessionActive = true;
            console.log('Game session started during restore');
          }

          // Show timed game
          pushToNavigationStack('timed');

          // Ensure game container is ready before transition
          const timedContainerEl = document.getElementById('timedContainer');
          if (timedContainerEl) {
            timedContainerEl.style.opacity = '0';
            timedContainerEl.style.visibility = 'hidden';
            timedContainerEl.style.pointerEvents = 'none';
          }

          transitionToScreen('homeScreen', 'timedContainer');

          // Start background music for Timed mode
          startMusic('timed');

          // Start timer after restoring game (timer state already restored above)
          startGamePlayTimer('timed');

          // Update timer display immediately after restore
          updateGamePlayTimer('timed');

          // Update UI
          document.getElementById("scoreTimed").textContent = "Score: " + scoreTimed;
          document.getElementById("timerDisplay").textContent = "Time: " + timer;
          console.log("Drawing timed grid...");
          isDrawingOnly = true; // Set flag to prevent game over checks during drawing
          drawGridTimed();
          console.log("Drawing timed pieces...");
          drawPiecesTimed();
          updateUndoButtons();

          // Set game as active but keep it in paused state until user explicitly resumes
          isGameActive = true;
          // IMPORTANT: Keep manually paused TRUE so piece drag/placement is blocked during restored pause
          isManuallyPaused = true; // Stay paused after restore

          // Clear saved manual pause status since we're now in controlled pause state
          clearManualPauseStatus();

          // Handle pause state - restored games should always be paused (timer will not run)
          pausedTimed = {
            score: scoreTimed,
            board: JSON.parse(JSON.stringify(boardTimed)),
            currentThree: JSON.parse(JSON.stringify(currentThreeTimed)),
            selectedIdx: selectedIdxTimed,
            timer: timer
          };
          console.log("Showing pause overlay for timed...");
          document.getElementById("pauseOverlayTimed").style.display = "block";
          showPausePopup('timed');

          // Clear restore flag now that restore is complete
          isGameRestoring = false;

          // Force hide any game over popups that might have appeared
          forceHideGameOverIfNeeded();

          // DO NOT re-enable game over here; wait until user clicks Resume
          console.log("⏸️ Keeping gameOverGloballyDisabled TRUE until explicit resume");

          // Keep isDrawingOnly flag active for an extra 500ms to prevent any async game over triggers
          setTimeout(() => {
            isDrawingOnly = false;
            console.log("✅ isDrawingOnly flag FINALLY reset after restore (still paused)");
          }, 500);

          return true;
        } catch (error) {
          console.error("Error restoring timed game state:", error);
          isGameRestoring = false; // Reset flag on error
          gameOverGloballyDisabled = false; // Reset global flag on error
          clearTimedGameState();
          return false;
        }
      }

      function restoreGameState(gameState) {
        if (!gameState) return false;

        try {
          console.log("=== RESTORING GAME STATE ===");
          console.log("Mode:", gameState.mode, "isPaused:", gameState.isPaused);
          console.log("Score:", gameState.score, "Board valid:", Array.isArray(gameState.board));

          if (gameState.mode === 'classic') {
            // Restore classic game state
            console.log("Restoring classic game...");
            scoreClassic = gameState.score || 0;
            boardClassic = gameState.board && Array.isArray(gameState.board) ?
              JSON.parse(JSON.stringify(gameState.board)) :
              Array(10).fill().map(() => Array(10).fill(null));
            currentThreeClassic = gameState.currentPieces || [randomShape(), randomShape(), randomShape()];
            totalLinesClassic = gameState.totalLines || 0;
            totalBlocksPlaced = gameState.totalBlocks || 0;
            gameStartTime = gameState.gameStartTime || Date.now();
            undoCreditsClassic = gameState.undoCredits || 3;
            selectedIdxClassic = gameState.selectedIdx || null;

            console.log("Classic state restored - Score:", scoreClassic, "Board size:", boardClassic.length);

            // Show classic game
            pushToNavigationStack('classic');
            transitionToScreen('homeScreen', 'classicContainer');

            // Update UI
            document.getElementById("scoreClassic").textContent = "Score: " + scoreClassic;
            console.log("Drawing classic grid...");
            drawGridClassic();
            console.log("Drawing classic pieces...");
            drawPiecesClassic();
            updateUndoButtons();

            // Set game as active
            isGameActive = true;

            // Handle pause state - restored games should always be paused
            pausedClassic = {
              score: scoreClassic,
              board: JSON.parse(JSON.stringify(boardClassic)),
              currentThree: JSON.parse(JSON.stringify(currentThreeClassic)),
              selectedIdx: selectedIdxClassic,
              timer: null
            };
            console.log("Showing pause overlay for classic...");
            document.getElementById("pauseOverlayClassic").style.display = "block";

            return true;

          } else if (gameState.mode === 'timed') {
            // Restore timed game state
            console.log("Restoring timed game...");
            scoreTimed = gameState.score || 0;
            timer = gameState.timer || 300;
            boardTimed = gameState.board && Array.isArray(gameState.board) ?
              JSON.parse(JSON.stringify(gameState.board)) :
              Array(10).fill().map(() => Array(10).fill(null));
            currentThreeTimed = gameState.currentPieces || [randomShape(), randomShape(), randomShape()];
            totalLinesTimed = gameState.totalLines || 0;
            totalBlocksPlacedTimed = gameState.totalBlocks || 0;
            extraTimeEarnedInGame = gameState.extraTimeEarned || 0;
            currentLevelTimed = gameState.currentLevel || 1;
            gameStartTime = gameState.gameStartTime || Date.now();
            undoCreditsTimed = gameState.undoCredits || 3;
            selectedIdxTimed = gameState.selectedIdx || null;

            console.log("Timed state restored - Score:", scoreTimed, "Timer:", timer, "Board size:", boardTimed.length);

            // Show timed game
            pushToNavigationStack('timed');
            transitionToScreen('homeScreen', 'timedContainer');

            // Update UI
            document.getElementById("scoreTimed").textContent = "Score: " + scoreTimed;
            document.getElementById("timerDisplay").textContent = "Time: " + timer;
            console.log("Drawing timed grid...");
            drawGridTimed();
            console.log("Drawing timed pieces...");
            drawPiecesTimed();
            updateUndoButtons();

            // Set game as active
            isGameActive = true;

            // Handle pause state - restored games should always be paused (timer will not run)
            pausedTimed = {
              score: scoreTimed,
              board: JSON.parse(JSON.stringify(boardTimed)),
              currentThree: JSON.parse(JSON.stringify(currentThreeTimed)),
              selectedIdx: selectedIdxTimed,
              timer: timer
            };
            console.log("Showing pause overlay for timed...");
            document.getElementById("pauseOverlayTimed").style.display = "block";

            return true;
          }

        } catch (error) {
          console.error("Error restoring game state:", error);
          clearGameState();
          return false;
        }

        return false;
      }

      // ===== UTILITY FUNCTIONS =====
      function mergeUserData(defaults, saved) {
        // Ensure gamePlayTimers is properly merged
        if (!defaults.gamePlayTimers) {
          defaults.gamePlayTimers = {
            classic: {
              startTime: '',
              startTimeMs: 0,
              pausedElapsed: '00:00:00:00',
              pausedElapsedMs: 0,
              isPaused: false,
              pausedTime: '',
              pausedTimeMs: 0
            },
            timed: {
              startTime: '',
              startTimeMs: 0,
              pausedElapsed: '00:00:00:00',
              pausedElapsedMs: 0,
              isPaused: false,
              pausedTime: '',
              pausedTimeMs: 0
            }
          };
        }
        const merged = { ...defaults };

        // Deep merge each section
        if (saved.profile) {
          merged.profile = { ...defaults.profile, ...saved.profile };

          // Generate createdAtReadable if createdAt exists but readable format doesn't
          if (merged.profile.createdAt && !merged.profile.createdAtReadable) {
            const createdAtMs = typeof merged.profile.createdAt === 'number'
              ? merged.profile.createdAt
              : new Date(merged.profile.createdAt).getTime();
            if (!isNaN(createdAtMs) && createdAtMs > 0) {
              merged.profile.createdAtReadable = formatTimestampForFirebase(createdAtMs);
            }
          }
        }
        if (saved.gameStats) merged.gameStats = { ...defaults.gameStats, ...saved.gameStats };
        if (saved.achievements) merged.achievements = { ...defaults.achievements, ...saved.achievements };
        if (saved.settings) merged.settings = { ...defaults.settings, ...saved.settings };
        // Deep merge gamePlayTimers
        if (saved.gamePlayTimers) {
          merged.gamePlayTimers = {
            classic: {
              ...defaults.gamePlayTimers.classic,
              ...(saved.gamePlayTimers.classic || {})
            },
            timed: {
              ...defaults.gamePlayTimers.timed,
              ...(saved.gamePlayTimers.timed || {})
            }
          };
        }

        return merged;
      }
      function updateUIWithUserData() {
        console.log("updateUIWithUserData called with:", userData);

        refreshHighscoreCaches();

        // Show user stats card
        const userStatsDisplay = document.getElementById('userStatsDisplay');
        console.log("userStatsDisplay element:", userStatsDisplay);
        if (userStatsDisplay) {
          userStatsDisplay.classList.remove('user-stats-hidden');
          console.log("User stats display shown");
        } else {
          console.error("userStatsDisplay element not found!");
        }

        // Update player name
        const playerNameDisplay = document.getElementById('playerNameDisplay');
        if (playerNameDisplay) {
          let displayName = userData.profile.displayName;
          if (!displayName && currentFirebaseUser) {
            displayName = `Player-${currentFirebaseUser.uid.substring(0, 8)}`;
          } else if (!displayName) {
            displayName = 'Player';
          }
          playerNameDisplay.textContent = `🎮 ${displayName}`;
          if (userData.profile.email) {
            playerNameDisplay.title = `Account linked to ${userData.profile.email}`;
          } else {
            playerNameDisplay.title = 'Playing as guest (local save only)';
          }
          console.log("Player name updated:", displayName);
        } else {
          console.error("playerNameDisplay element not found!");
        }

        // Update sync status
        const syncStatusIcon = document.getElementById('syncStatusIcon');
        if (syncStatusIcon) {
          if (currentFirebaseUser) {
            syncStatusIcon.textContent = '☁️';
            syncStatusIcon.className = 'synced';
            syncStatusIcon.title = 'Data synced to cloud';
          } else {
            syncStatusIcon.textContent = '💾';
            syncStatusIcon.className = 'local';
            syncStatusIcon.title = 'Data saved locally only';
          }
          console.log("Sync status updated");
        }

        // Update stats
        const totalGamesDisplay = document.getElementById('totalGamesDisplay');
        if (totalGamesDisplay) {
          totalGamesDisplay.textContent = userData.gameStats.totalGames.toLocaleString();
          console.log("Total games updated:", userData.gameStats.totalGames);
        }

        const classicHighScoreDisplay = document.getElementById('classicHighScoreDisplay');
        if (classicHighScoreDisplay) {
          const classicHigh = userData.gameStats.classicHighScore || 0;
          classicHighScoreDisplay.textContent = classicHigh.toLocaleString();
          console.log("Classic high score updated:", classicHigh);
        }

        const timedHighScoreDisplay = document.getElementById('timedHighScoreDisplay');
        if (timedHighScoreDisplay) {
          const timedHigh = userData.gameStats.timedHighScore || 0;
          timedHighScoreDisplay.textContent = timedHigh.toLocaleString();
          console.log("Timed high score updated:", timedHigh);
        }

        const totalTimeDisplay = document.getElementById('totalTimeDisplay');
        if (totalTimeDisplay) {
          const totalSeconds = userData.gameStats.totalTime || 0;
          const hours = Math.floor(totalSeconds / 3600);
          const minutes = Math.floor((totalSeconds % 3600) / 60);

          if (hours > 0) {
            totalTimeDisplay.textContent = `${hours}h ${minutes}m`;
          } else {
            totalTimeDisplay.textContent = `${minutes}m`;
          }
          console.log("Total time updated:", hours, "h", minutes, "m");
        }

        // Update Classic Timer Display (from Firebase gamePlayTimers)
        const classicTimerDisplay = document.getElementById('classicTimerDisplay');
        if (classicTimerDisplay) {
          // Use global variables (which are updated from Firebase) instead of userData
          let elapsedMs = 0;

          if (gamePlayStartTimeClassic > 0) {
            if (isGamePlayPausedClassic && gamePlayPausedElapsedClassic > 0) {
              // Timer is paused - use pausedElapsed
              elapsedMs = gamePlayPausedElapsedClassic;
            } else if (!isGamePlayPausedClassic) {
              // Timer is running - calculate from startTime
              elapsedMs = Date.now() - gamePlayStartTimeClassic;
            }
          }

          const formattedTime = formatElapsedTime(elapsedMs);
          classicTimerDisplay.textContent = formattedTime;
          console.log("Classic timer updated:", formattedTime, "(" + elapsedMs + "ms)");
        }

        // Update Timed Timer Display (from Firebase gamePlayTimers)
        const timedTimerDisplay = document.getElementById('timedTimerDisplay');
        if (timedTimerDisplay) {
          // Use global variables (which are updated from Firebase) instead of userData
          let elapsedMs = 0;

          if (gamePlayStartTimeTimed > 0) {
            if (isGamePlayPausedTimed && gamePlayPausedElapsedTimed > 0) {
              // Timer is paused - use pausedElapsed
              elapsedMs = gamePlayPausedElapsedTimed;
            } else if (!isGamePlayPausedTimed) {
              // Timer is running - calculate from startTime
              elapsedMs = Date.now() - gamePlayStartTimeTimed;
            }
          }

          const formattedTime = formatElapsedTime(elapsedMs);
          timedTimerDisplay.textContent = formattedTime;
          console.log("Timed timer updated:", formattedTime, "(" + elapsedMs + "ms)");
        }

        const achievementsCountDisplay = document.getElementById('achievementsCountDisplay');
        if (achievementsCountDisplay) {
          const unlockedCount = Object.values(userData.achievements).filter(Boolean).length;
          const totalCount = 75; // Total achievements: 15 Classic Score + 15 Timed Score + 15 Classic Lines + 15 Timed Lines + 15 Extra Time
          achievementsCountDisplay.textContent = `${unlockedCount}/${totalCount}`;
          console.log("Achievements updated:", unlockedCount, "/", totalCount);
        }

        console.log("updateUIWithUserData completed");

        // Force a slight delay and re-update to ensure DOM is ready
        setTimeout(() => {
          const userStatsDisplay = document.getElementById('userStatsDisplay');
          if (userStatsDisplay && userStatsDisplay.classList.contains('user-stats-hidden')) {
            userStatsDisplay.classList.remove('user-stats-hidden');
            console.log("Force showed user stats display after delay");
          }
        }, 100);
      }

      // Periodic update for home page timer displays (every second)
      let homePageTimerUpdateInterval = null;
      function startHomePageTimerUpdate() {
        // Clear existing interval if any
        if (homePageTimerUpdateInterval) {
          clearInterval(homePageTimerUpdateInterval);
        }

        // Update timer displays every second when on home page
        homePageTimerUpdateInterval = setInterval(() => {
          const homeScreen = document.getElementById('homeScreen');
          if (homeScreen && homeScreen.style.display !== 'none') {
            // Update Classic Timer Display
            const classicTimerDisplay = document.getElementById('classicTimerDisplay');
            if (classicTimerDisplay) {
              // Use current timer state (from variables, not Firebase)
              let elapsedMs = 0;
              if (gamePlayStartTimeClassic > 0) {
                if (isGamePlayPausedClassic && gamePlayPausedElapsedClassic > 0) {
                  elapsedMs = gamePlayPausedElapsedClassic;
                } else if (!isGamePlayPausedClassic) {
                  elapsedMs = Date.now() - gamePlayStartTimeClassic;
                }
              }
              const formattedTime = formatElapsedTime(elapsedMs);
              classicTimerDisplay.textContent = formattedTime;
            }

            // Update Timed Timer Display
            const timedTimerDisplay = document.getElementById('timedTimerDisplay');
            if (timedTimerDisplay) {
              // Use current timer state (from variables, not Firebase)
              let elapsedMs = 0;
              if (gamePlayStartTimeTimed > 0) {
                if (isGamePlayPausedTimed && gamePlayPausedElapsedTimed > 0) {
                  elapsedMs = gamePlayPausedElapsedTimed;
                } else if (!isGamePlayPausedTimed) {
                  elapsedMs = Date.now() - gamePlayStartTimeTimed;
                }
              }
              const formattedTime = formatElapsedTime(elapsedMs);
              timedTimerDisplay.textContent = formattedTime;
            }
          }
        }, 1000);
      }

      // Start home page timer update on page load
      startHomePageTimerUpdate();

      // ===== MANUAL UI REFRESH FUNCTION =====
      function forceRefreshUI() {
        console.log("Force refreshing UI with current userData:", userData);
        updateUIWithUserData();
      }

      // Make it globally available for debugging
      window.forceRefreshUI = forceRefreshUI;

      // ===== GAME DATA SYNC FUNCTIONS =====
      function updateGameStats(gameResult) {
        if (!userData.gameStats) userData.gameStats = { ...defaultUserData.gameStats };

        console.log("Updating game stats with result:", gameResult);
        console.log("Previous stats:", userData.gameStats);

        // Update stats
        userData.gameStats.totalGames += 1;

        if (typeof userData.gameStats.classicHighScore !== 'number') {
          userData.gameStats.classicHighScore = userData.gameStats.highScore || 0;
        }
        if (typeof userData.gameStats.timedHighScore !== 'number') {
          userData.gameStats.timedHighScore = 0;
        }

        if (gameResult.mode === 'classic' && gameResult.score > userData.gameStats.classicHighScore) {
          userData.gameStats.classicHighScore = gameResult.score;
          console.log("New classic high score:", userData.gameStats.classicHighScore);
        }

        if (gameResult.mode === 'timed' && gameResult.score > userData.gameStats.timedHighScore) {
          userData.gameStats.timedHighScore = gameResult.score;
          console.log("New timed high score:", userData.gameStats.timedHighScore);
        }

        const bestOverallHigh = Math.max(
          userData.gameStats.classicHighScore || 0,
          userData.gameStats.timedHighScore || 0
        );
        if (bestOverallHigh > (userData.gameStats.highScore || 0)) {
          userData.gameStats.highScore = bestOverallHigh;
          console.log("New overall high score:", userData.gameStats.highScore);
        }
        if (gameResult.lines > userData.gameStats.bestLines) {
          userData.gameStats.bestLines = gameResult.lines;
        }
        // Note: totalTime is now tracked per session, not per game

        console.log("Updated stats:", userData.gameStats);

        // Check achievements
        checkAchievements(gameResult);

        // ===== IMMEDIATE UI UPDATE =====
        // Update UI immediately after stats change
        updateUIWithUserData();
        console.log("UI updated after game stats change");

        // Save data
        if (currentFirebaseUser) {
          saveUserDataToFirebase(currentFirebaseUser.uid);
          saveGameHistoryToFirebase(gameResult);
        } else {
          saveLocalUserData();
        }
      }

      // ===== ACHIEVEMENT SYSTEM =====

      // Create anonymous Firebase user for guests
      // DEPRECATED: No longer used - Guest users now use email-based authentication
      // Guest accounts are created with hidden email format: username@flyingbird.com
      /*
      async function createAnonymousGuestUser() {
        // This function is no longer needed as guests use regular email auth
        console.warn("createAnonymousGuestUser is deprecated - guests now use email authentication");
      }
      */

      const achievementDefinitions = {
        scoreClassic: [
          { key: 'scoreClassic5000', name: 'સ્કોર નવીન', nameEn: 'Score Novice', target: 5000, level: 1 },
          { key: 'scoreClassic9000', name: 'સ્કોર સંગ્રાહક', nameEn: 'Score Collector', target: 9000, level: 2 },
          { key: 'scoreClassic18000', name: 'સ્કોર શિકારી', nameEn: 'Score Hunter', target: 18000, level: 3 },
          { key: 'scoreClassic27000', name: 'સ્કોર યોદ્ધા', nameEn: 'Score Warrior', target: 27000, level: 4 },
          { key: 'scoreClassic36000', name: 'સ્કોર ચેમ્પિયન', nameEn: 'Score Champion', target: 36000, level: 5 },
          { key: 'scoreClassic45000', name: 'સ્કોર માસ્ટર', nameEn: 'Score Master', target: 45000, level: 6 },
          { key: 'scoreClassic54000', name: 'સ્કોર વીરો', nameEn: 'Score Hero', target: 54000, level: 7 },
          { key: 'scoreClassic63000', name: 'સ્કોર લિજેન્ડ', nameEn: 'Score Legend', target: 63000, level: 8 },
          { key: 'scoreClassic81000', name: 'સ્કોર ટાઇટન', nameEn: 'Score Titan', target: 81000, level: 9 },
          { key: 'scoreClassic108000', name: 'સ્કોર ગોડ', nameEn: 'Score God', target: 108000, level: 10 },
          { key: 'scoreClassic163000', name: 'સ્કોર ઇમ્પેરર', nameEn: 'Score Emperor', target: 163000, level: 11 },
          { key: 'scoreClassic252000', name: 'સ્કોર ઓલિમ્પિયન', nameEn: 'Score Olympian', target: 252000, level: 12 },
          { key: 'scoreClassic504000', name: 'સ્કોર ડેમિગોડ', nameEn: 'Score Demigod', target: 504000, level: 13 },
          { key: 'scoreClassic756000', name: 'સ્કોર ઇમોર્ટલ', nameEn: 'Score Immortal', target: 756000, level: 14 },
          { key: 'scoreClassic1100000', name: 'સ્કોર પરમાત્મા', nameEn: 'Score Supreme', target: 1100000, level: 15 }
        ],
        scoreTimed: [
          { key: 'scoreTimed5000', name: 'સ્કોર નવીન', nameEn: 'Score Novice', target: 5000, level: 1 },
          { key: 'scoreTimed9000', name: 'સ્કોર સંગ્રાહક', nameEn: 'Score Collector', target: 9000, level: 2 },
          { key: 'scoreTimed18000', name: 'સ્કોર શિકારી', nameEn: 'Score Hunter', target: 18000, level: 3 },
          { key: 'scoreTimed27000', name: 'સ્કોર યોદ્ધા', nameEn: 'Score Warrior', target: 27000, level: 4 },
          { key: 'scoreTimed36000', name: 'સ્કોર ચેમ્પિયન', nameEn: 'Score Champion', target: 36000, level: 5 },
          { key: 'scoreTimed45000', name: 'સ્કોર માસ્ટર', nameEn: 'Score Master', target: 45000, level: 6 },
          { key: 'scoreTimed54000', name: 'સ્કોર વીરો', nameEn: 'Score Hero', target: 54000, level: 7 },
          { key: 'scoreTimed63000', name: 'સ્કોર લિજેન્ડ', nameEn: 'Score Legend', target: 63000, level: 8 },
          { key: 'scoreTimed81000', name: 'સ્કોર ટાઇટન', nameEn: 'Score Titan', target: 81000, level: 9 },
          { key: 'scoreTimed108000', name: 'સ્કોર ગોડ', nameEn: 'Score God', target: 108000, level: 10 },
          { key: 'scoreTimed163000', name: 'સ્કોર ઇમ્પેરર', nameEn: 'Score Emperor', target: 163000, level: 11 },
          { key: 'scoreTimed252000', name: 'સ્કોર ઓલિમ્પિયન', nameEn: 'Score Olympian', target: 252000, level: 12 },
          { key: 'scoreTimed504000', name: 'સ્કોર ડેમિગોડ', nameEn: 'Score Demigod', target: 504000, level: 13 },
          { key: 'scoreTimed756000', name: 'સ્કોર ઇમોર્ટલ', nameEn: 'Score Immortal', target: 756000, level: 14 },
          { key: 'scoreTimed1100000', name: 'સ્કોર પરમાત્મા', nameEn: 'Score Supreme', target: 1100000, level: 15 }
        ],
        linesClassic: [
          { key: 'linesClassic50', name: 'લાઇન નવીન', nameEn: 'Line Novice', target: 50, level: 1 },
          { key: 'linesClassic100', name: 'લાઇન બ્રેકર', nameEn: 'Line Breaker', target: 100, level: 2 },
          { key: 'linesClassic175', name: 'લાઇન ક્લિયરર', nameEn: 'Line Clearer', target: 175, level: 3 },
          { key: 'linesClassic250', name: 'લાઇન યોદ્ધા', nameEn: 'Line Warrior', target: 250, level: 4 },
          { key: 'linesClassic375', name: 'લાઇન ચેમ્પિયન', nameEn: 'Line Champion', target: 375, level: 5 },
          { key: 'linesClassic500', name: 'લાઇન માસ્ટર', nameEn: 'Line Master', target: 500, level: 6 },
          { key: 'linesClassic750', name: 'લાઇન વીરો', nameEn: 'Line Hero', target: 750, level: 7 },
          { key: 'linesClassic1250', name: 'લાઇન લિજેન્ડ', nameEn: 'Line Legend', target: 1250, level: 8 },
          { key: 'linesClassic2000', name: 'લાઇન ટાઇટન', nameEn: 'Line Titan', target: 2000, level: 9 },
          { key: 'linesClassic2750', name: 'લાઇન ગોડ', nameEn: 'Line God', target: 2750, level: 10 },
          { key: 'linesClassic3750', name: 'લાઇન ઇમ્પેરર', nameEn: 'Line Emperor', target: 3750, level: 11 },
          { key: 'linesClassic5000', name: 'લાઇન ઓલિમ્પિયન', nameEn: 'Line Olympian', target: 5000, level: 12 },
          { key: 'linesClassic6250', name: 'લાઇન ડેમિગોડ', nameEn: 'Line Demigod', target: 6250, level: 13 },
          { key: 'linesClassic7500', name: 'લાઇન ઇમોર્ટલ', nameEn: 'Line Immortal', target: 7500, level: 14 },
          { key: 'linesClassic10000', name: 'લાઇન પરમાત્મા', nameEn: 'Line Supreme', target: 10000, level: 15 }
        ],
        linesTimed: [
          { key: 'linesTimed50', name: 'લાઇન નવીન', nameEn: 'Line Novice', target: 50, level: 1 },
          { key: 'linesTimed100', name: 'લાઇન બ્રેકર', nameEn: 'Line Breaker', target: 100, level: 2 },
          { key: 'linesTimed175', name: 'લાઇન ક્લિયરર', nameEn: 'Line Clearer', target: 175, level: 3 },
          { key: 'linesTimed250', name: 'લાઇન યોદ્ધા', nameEn: 'Line Warrior', target: 250, level: 4 },
          { key: 'linesTimed375', name: 'લાઇન ચેમ્પિયન', nameEn: 'Line Champion', target: 375, level: 5 },
          { key: 'linesTimed500', name: 'લાઇન માસ્ટર', nameEn: 'Line Master', target: 500, level: 6 },
          { key: 'linesTimed750', name: 'લાઇન વીરો', nameEn: 'Line Hero', target: 750, level: 7 },
          { key: 'linesTimed1250', name: 'લાઇન લિજેન્ડ', nameEn: 'Line Legend', target: 1250, level: 8 },
          { key: 'linesTimed2000', name: 'લાઇન ટાઇટન', nameEn: 'Line Titan', target: 2000, level: 9 },
          { key: 'linesTimed2750', name: 'લાઇન ગોડ', nameEn: 'Line God', target: 2750, level: 10 },
          { key: 'linesTimed3750', name: 'લાઇન ઇમ્પેરર', nameEn: 'Line Emperor', target: 3750, level: 11 },
          { key: 'linesTimed5000', name: 'લાઇન ઓલિમ્પિયન', nameEn: 'Line Olympian', target: 5000, level: 12 },
          { key: 'linesTimed6250', name: 'લાઇન ડેમિગોડ', nameEn: 'Line Demigod', target: 6250, level: 13 },
          { key: 'linesTimed7500', name: 'લાઇન ઇમોર્ટલ', nameEn: 'Line Immortal', target: 7500, level: 14 },
          { key: 'linesTimed10000', name: 'લાઇન પરમાત્મા', nameEn: 'Line Supreme', target: 10000, level: 15 }
        ],
        extraTime: [
          // Display shows small numbers but unlock requires large time earned (in seconds)
          { key: 'extraTime100', name: 'સમય નવીન', nameEn: 'Time Novice', displayTarget: 500, target: 500, level: 1 },
          { key: 'extraTime200', name: 'સમય સંગ્રાહક', nameEn: 'Time Collector', displayTarget: 800, target: 800, level: 2 },
          { key: 'extraTime350', name: 'સમય શિકારી', nameEn: 'Time Hunter', displayTarget: 1100, target: 1100, level: 3 },
          { key: 'extraTime500', name: 'સમય યોદ્ધા', nameEn: 'Time Warrior', displayTarget: 1400, target: 1400, level: 4 },
          { key: 'extraTime700', name: 'સમય ચેમ્પિયન', nameEn: 'Time Champion', displayTarget: 1700, target: 1700, level: 5 },
          { key: 'extraTime900', name: 'સમય માસ્ટર', nameEn: 'Time Master', displayTarget: 2000, target: 2000, level: 6 },
          { key: 'extraTime1100', name: 'સમય વીરો', nameEn: 'Time Hero', displayTarget: 2400, target: 2400, level: 7 },
          { key: 'extraTime1300', name: 'સમય લિજેન્ડ', nameEn: 'Time Legend', displayTarget: 2800, target: 2800, level: 8 },
          { key: 'extraTime1550', name: 'સમય ટાઇટન', nameEn: 'Time Titan', displayTarget: 3200, target: 3200, level: 9 },
          { key: 'extraTime1800', name: 'સમય ગોડ', nameEn: 'Time God', displayTarget: 4000, target: 4000, level: 10 },
          { key: 'extraTime2050', name: 'સમય ઇમ્પેરર', nameEn: 'Time Emperor', displayTarget: 5000, target: 5000, level: 11 },
          { key: 'extraTime2400', name: 'સમય ઓલિમ્પિયન', nameEn: 'Time Olympian', displayTarget: 6000, target: 6000, level: 12 },
          { key: 'extraTime2700', name: 'સમય ડેમિગોડ', nameEn: 'Time Demigod', displayTarget: 8000, target: 8000, level: 13 },
          { key: 'extraTime3000', name: 'સમય ઇમોર્ટલ', nameEn: 'Time Immortal', displayTarget: 10000, target: 10000, level: 14 },
          { key: 'extraTime4000', name: 'સમય પરમાત્મા', nameEn: 'Time Supreme', displayTarget: 12000, target: 12000, level: 15 }
        ]
      };

      // Note: All game state flags and tracking variables are declared at script top

      // Function to reset game flags for new game session
      function resetGameFlags() {
        isManuallyPaused = false;
        isGameActive = true;
        isStartupLoad = false;
        isGameRestoring = false;
        isDrawingOnly = false;
        gameOverGloballyDisabled = false;
        isLegitimateGameOver = false; // Reset legitimate game over flag
        boardFillSequence = []; // Reset fill sequence
        clearManualPauseStatus(); // Clear saved status for fresh start
      }

      // Play board fill animation on game start - with block demonstration
      async function playBoardFillAnimation(mode) {
        const grid = mode === 'classic' ? gridClassic : gridTimed;
        const cells = Array.from(grid.children);

        // Create random sequence of cell indices (60% of cells = 60 cells)
        const allIndices = Array.from({ length: 100 }, (_, i) => i);
        // Shuffle all indices
        for (let i = allIndices.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [allIndices[i], allIndices[j]] = [allIndices[j], allIndices[i]];
        }
        // Take first 60 cells (60%)
        boardFillSequence = allIndices.slice(0, 60);

        // Random colors for demonstration
        const demoColors = ['#3b82f6', '#8b5cf6', '#ec4899', '#f59e0b', '#10b981', '#06b6d4'];

        // PHASE 1: Fill blocks with animation
        const fillPromises = boardFillSequence.map((cellIndex, sequenceIndex) => {
          return new Promise(resolve => {
            setTimeout(() => {
              const cell = cells[cellIndex];
              if (cell) {
                // Random color for this block
                const randomColor = demoColors[Math.floor(Math.random() * demoColors.length)];
                cell.style.background = randomColor;
                cell.classList.add('filled', 'board-filling');
                setTimeout(() => {
                  cell.classList.remove('board-filling');
                  resolve();
                }, 250);
              } else {
                resolve();
              }
            }, sequenceIndex * 8); // 8ms delay for ultra-fast fill
          });
        });

        await Promise.all(fillPromises);

        // Wait 300ms to show filled board
        await new Promise(resolve => setTimeout(resolve, 300));

        // PHASE 2: Clear all filled blocks with animation (reverse order)
        const reverseSequence = [...boardFillSequence].reverse();
        const clearPromises = reverseSequence.map((cellIndex, sequenceIndex) => {
          return new Promise(resolve => {
            setTimeout(() => {
              const cell = cells[cellIndex];
              if (cell) {
                cell.classList.add('board-clearing');
                setTimeout(() => {
                  cell.classList.remove('board-clearing', 'filled');
                  cell.style.background = '';
                  resolve();
                }, 250);
              } else {
                resolve();
              }
            }, sequenceIndex * 15); // 15ms delay for faster clear
          });
        });

        await Promise.all(clearPromises);
      }

      // Play board clear animation on game over (reverse of fill)
      async function playBoardClearAnimation(mode) {
        const grid = mode === 'classic' ? gridClassic : gridTimed;
        const cells = Array.from(grid.children);

        // Use the same sequence as fill but in reverse; if missing (e.g., restored game), generate a full-board sequence
        let reverseSequence = [];
        if (Array.isArray(boardFillSequence) && boardFillSequence.length > 0) {
          reverseSequence = [...boardFillSequence].reverse();
        } else {
          // Fallback: animate all cells in a randomized order for a consistent effect
          const allIndices = Array.from({ length: 100 }, (_, i) => i);
          for (let i = allIndices.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [allIndices[i], allIndices[j]] = [allIndices[j], allIndices[i]];
          }
          reverseSequence = allIndices;
        }

        // Animate cells in reverse order
        const animationPromises = reverseSequence.map((cellIndex, sequenceIndex) => {
          return new Promise(resolve => {
            setTimeout(() => {
              const cell = cells[cellIndex];
              if (cell) {
                // Add animation class instead of inline style
                cell.classList.add('board-clearing');
                setTimeout(() => {
                  cell.classList.remove('board-clearing');
                  resolve();
                }, 250);
              } else {
                resolve();
              }
            }, sequenceIndex * 10); // 10ms delay between each cell for faster clear
          });
        });

        await Promise.all(animationPromises);
      }
      // Safe function to show game over - with final validation
      function safeShowGameOver(mode) {
        console.log("=== Attempting to show game over for", mode, "===");
        console.log("Current flags - manuallyPaused:", isManuallyPaused, "restoring:", isGameRestoring, "drawingOnly:", isDrawingOnly, "globallyDisabled:", gameOverGloballyDisabled);

        // ULTIMATE PROTECTION: Check all possible blocking conditions
        if (isManuallyPaused || isGameRestoring || isDrawingOnly || gameOverGloballyDisabled) {
          console.log("🚫 BLOCKING game over popup due to protection flags");
          return false;
        }

        if (mode === 'classic' && pausedClassic) {
          console.log("🚫 BLOCKING classic game over - paused state exists");
          return false;
        }

        if (mode === 'timed' && pausedTimed) {
          console.log("🚫 BLOCKING timed game over - paused state exists");
          return false;
        }

        if (mode === 'timed' && timer > 0) {
          console.log("🚫 BLOCKING timed game over - timer still has", timer, "seconds");
          return false;
        }

        console.log("✅ ALLOWING game over popup for", mode);
        return true;
      }

      // Ultimate protection function - override any direct popup shows
      function forceHideGameOverIfNeeded() {
        // Don't hide if game over was legitimately shown
        if (isLegitimateGameOver) {
          return;
        }

        if (gameOverGloballyDisabled || isManuallyPaused || isGameRestoring || isDrawingOnly) {
          const classicGameOver = document.getElementById("gameOverClassic");
          const timedGameOver = document.getElementById("gameOverTimed");

          if (classicGameOver && classicGameOver.style.display === "block") {
            console.log("🚫 FORCE HIDING Classic game over popup!");
            classicGameOver.style.display = "none";
          }

          if (timedGameOver && timedGameOver.style.display === "block") {
            console.log("🚫 FORCE HIDING Timed game over popup!");
            timedGameOver.style.display = "none";
          }
        }
      }

      function checkAchievements(gameResult) {
        const achievements = userData.achievements;
        let newAchievements = [];

        // Don't show achievement popups during startup/initial load
        if (isStartupLoad) {
          console.log("Skipping achievement popup during startup");
          return;
        }
        // Allow achievement evaluation in two scenarios:
        // 1. Active gameplay (isGameActive === true)
        // 2. Game over event providing gameResult (so end-of-game achievements still show)
        if (!isGameActive && !gameResult) {
          console.log("Skipping achievement popup - neither active gameplay nor game over");
          return;
        }

        // Check score achievements based on game mode
        const gameMode = gameResult ? gameResult.mode : (isGameActive ? (scoreClassic > 0 ? 'classic' : 'timed') : null);
        if (gameMode) {
          const scoreDefs = gameMode === 'classic' ? achievementDefinitions.scoreClassic : achievementDefinitions.scoreTimed;
          const currentScore = gameMode === 'classic' ? (gameResult ? gameResult.score : scoreClassic) : (gameResult ? gameResult.score : scoreTimed);
          const highScore = gameMode === 'classic' ? (userData.gameStats.classicHighScore || 0) : (userData.gameStats.timedHighScore || 0);
          const scoreToCheck = Math.max(currentScore, highScore);

          scoreDefs.forEach(achievement => {
            if (scoreToCheck >= achievement.target && !achievements[achievement.key]) {
              achievements[achievement.key] = true;
              const name = currentLang === 'gu' ? achievement.name : achievement.nameEn;
              newAchievements.push({
                title: `🏆 ${name} #${achievement.level}`,
                message: `${currentLang === 'gu' ? 'સ્કોર' : 'Score'}: ${achievement.target.toLocaleString()}`
              });
            }
          });
        }

        // Track and check line achievements based on game mode
        if (gameResult && gameResult.lines) {
          const gameMode = gameResult.mode || 'classic';
          const lineDefs = gameMode === 'classic' ? achievementDefinitions.linesClassic : achievementDefinitions.linesTimed;

          // Track lines per mode
          if (gameMode === 'classic') {
            totalLinesEarned = (userData.gameStats.classicTotalLines || 0) + gameResult.lines;
          } else {
            totalLinesEarned = (userData.gameStats.timedTotalLines || 0) + gameResult.lines;
          }

          lineDefs.forEach(achievement => {
            if (totalLinesEarned >= achievement.target && !achievements[achievement.key]) {
              achievements[achievement.key] = true;
              const name = currentLang === 'gu' ? achievement.name : achievement.nameEn;
              newAchievements.push({
                title: `🏆 ${name} #${achievement.level}`,
                message: `${currentLang === 'gu' ? 'લાઇન' : 'Lines'}: ${achievement.target.toLocaleString()}`
              });
            }
          });
        }

        // Track and check extra time achievements (Timed mode only)
        // NOTE: Extra time achievements are already checked in real-time during gameplay
        // This is just for updating the cumulative total for future sessions
        if (gameResult.mode === 'timed' && gameResult.extraTime) {
          // Use Math.max to track the highest extra time earned in a single game
          // NOT cumulative across games (that would be unfair)
          const gameExtraTime = gameResult.extraTime;
          console.log(`🕐 Game over - Extra time this game: ${gameExtraTime}, Previous best: ${totalExtraTimeEarned}`);
          totalExtraTimeEarned = Math.max(totalExtraTimeEarned, gameExtraTime);
          console.log(`🕐 Updated totalExtraTimeEarned: ${totalExtraTimeEarned}`);

          // DO NOT check achievements here - they were already checked in real-time
          // This prevents double-counting and false achievements
          console.log(`ℹ️ Extra time achievements already checked in real-time, skipping game-over check`);
        }

        // Show new achievements only during active gameplay
        if (newAchievements.length > 0) {
          showAchievementPopup(newAchievements);
        }
      }

      // Real-time achievement checking during gameplay
      function checkRealtimeAchievements(mode) {
        // Real-time checks should run during active gameplay; startup blocked
        if (isStartupLoad) {
          console.log("Skipping real-time achievements - startup load");
          return;
        }
        if (!isGameActive) {
          // Edge case: If game just transitioned to game over, let checkAchievements handle via gameResult
          return;
        }

        const achievements = userData.achievements;
        let newAchievements = [];

        // Check score achievements in real-time (mode-specific)
        const currentScore = mode === 'classic' ? scoreClassic : scoreTimed;
        const scoreDefs = mode === 'classic' ? achievementDefinitions.scoreClassic : achievementDefinitions.scoreTimed;
        scoreDefs.forEach(achievement => {
          if (currentScore >= achievement.target && !achievements[achievement.key]) {
            achievements[achievement.key] = true;
            const name = currentLang === 'gu' ? achievement.name : achievement.nameEn;
            newAchievements.push({
              title: `🏆 ${name} #${achievement.level}`,
              message: `${currentLang === 'gu' ? 'સ્કોર' : 'Score'}: ${achievement.target.toLocaleString()}`
            });
          }
        });

        // Check line achievements in real-time (mode-specific)
        const currentLines = mode === 'classic' ? totalLinesClassic : totalLinesTimed;
        const lineDefs = mode === 'classic' ? achievementDefinitions.linesClassic : achievementDefinitions.linesTimed;
        console.log(`🎯 Real-time check: mode=${mode}, currentLines=${currentLines}, totalLinesEarned=${totalLinesEarned}, isGameActive=${isGameActive}`);
        if (currentLines > 0) {
          // Use current game session's total lines directly (already cumulative within game)
          totalLinesEarned = currentLines;
          console.log(`📊 Checking line achievements: totalLinesEarned=${totalLinesEarned}`);
          lineDefs.forEach(achievement => {
            const alreadyUnlocked = achievements[achievement.key];
            const meetsTarget = totalLinesEarned >= achievement.target;
            console.log(`  - ${achievement.key}: target=${achievement.target}, earned=${totalLinesEarned}, unlocked=${alreadyUnlocked}, meets=${meetsTarget}`);
            if (totalLinesEarned >= achievement.target && !achievements[achievement.key]) {
              achievements[achievement.key] = true;
              const name = currentLang === 'gu' ? achievement.name : achievement.nameEn;
              console.log(`🎉 UNLOCKING LINE ACHIEVEMENT: ${achievement.key} - ${name}`);
              newAchievements.push({
                title: `🏆 ${name} #${achievement.level}`,
                message: `${currentLang === 'gu' ? 'લાઇન' : 'Lines'}: ${achievement.target.toLocaleString()}`
              });
            }
          });
        }

        // Check timed mode extra time achievements in real-time
        if (mode === 'timed' && extraTimeEarnedInGame > 0) {
          // Use current game session's extra time directly (already cumulative within game)
          totalExtraTimeEarned = extraTimeEarnedInGame;
          console.log(`⏱️ Real-time extra time check: extraTimeEarnedInGame=${extraTimeEarnedInGame}, totalExtraTimeEarned=${totalExtraTimeEarned}`);
          achievementDefinitions.extraTime.forEach(achievement => {
            const alreadyUnlocked = achievements[achievement.key];
            const meetsTarget = totalExtraTimeEarned >= achievement.target;
            console.log(`  - ${achievement.key}: target=${achievement.target}, earned=${totalExtraTimeEarned}, unlocked=${alreadyUnlocked}, meets=${meetsTarget}`);
            if (totalExtraTimeEarned >= achievement.target && !achievements[achievement.key]) {
              achievements[achievement.key] = true;
              const name = currentLang === 'gu' ? achievement.name : achievement.nameEn;
              const displayValue = achievement.displayTarget || achievement.target;
              console.log(`🎉 UNLOCKING EXTRA TIME ACHIEVEMENT: ${achievement.key} - ${name}`);
              newAchievements.push({
                title: `🏆 ${name} #${achievement.level}`,
                message: `${currentLang === 'gu' ? 'વધારાનો સમય' : 'Extra Time'}: ${displayValue}${currentLang === 'gu' ? ' સેકંડ' : ' sec'}`
              });
            }
          });
        }

        // Show new achievements immediately
        if (newAchievements.length > 0) {
          showAchievementPopup(newAchievements);
          // Update stats card immediately
          updateUIWithUserData();
          // Save progress
          saveLocalUserData();
          if (currentFirebaseUser) {
            saveUserDataToFirebase(currentFirebaseUser.uid);
          }
        }
      }

      function showAchievementPopup(achievements) {
        // Extra safety check - never show popup during startup
        if (isStartupLoad) {
          console.log("Blocked achievement popup during startup load");
          return;
        }

        const popup = document.getElementById('achievementPopup');
        const title = document.getElementById('achievementTitle');
        const message = document.getElementById('achievementMessage');

        if (!popup || !title || !message) {
          console.log("Achievement popup elements not found");
          return;
        }

        let currentIndex = 0;

        function showNext() {
          // Extra safety check before showing each achievement
          if (isStartupLoad) {
            console.log("Blocked achievement display during startup");
            popup.style.display = 'none';
            return;
          }

          if (currentIndex >= achievements.length) {
            popup.style.display = 'none';
            return;
          }

          const achievement = achievements[currentIndex];
          const playerName = userData.profile.displayName || 'Player';

          title.textContent = achievement.title;
          message.innerHTML = `
            <strong>${currentLang === 'gu' ? 'અભિનંદન' : 'Congratulations'} ${playerName}!</strong><br>
            ${achievement.message}
          `;

          popup.style.display = 'block';

          // Extra protection - if still in startup, immediately hide
          if (isStartupLoad) {
            console.log("Emergency block: hiding achievement popup during startup");
            popup.style.display = 'none';
            popup.classList.add('user-stats-hidden');
            return;
          }

          playSound('bonus'); // Achievement sound

          currentIndex++;
        }

        showNext();

        // Auto close and show next after 3 seconds
        const autoClose = setInterval(() => {
          if (isStartupLoad) {
            clearInterval(autoClose);
            popup.style.display = 'none';
            return;
          }
          showNext();
          if (currentIndex >= achievements.length) {
            clearInterval(autoClose);
          }
        }, 3000);
      }

      function showAchievementsList() {
        const modal = document.getElementById('achievementListModal');
        const listContainer = document.getElementById('achievementsList');

        listContainer.innerHTML = '';

        // Calculate totals
        const totalScoreClassic = achievementDefinitions.scoreClassic.filter(a => userData.achievements[a.key]).length;
        const totalScoreTimed = achievementDefinitions.scoreTimed.filter(a => userData.achievements[a.key]).length;
        const totalLinesClassic = achievementDefinitions.linesClassic.filter(a => userData.achievements[a.key]).length;
        const totalLinesTimed = achievementDefinitions.linesTimed.filter(a => userData.achievements[a.key]).length;
        const totalTime = achievementDefinitions.extraTime.filter(a => userData.achievements[a.key]).length;
        const grandTotal = totalScoreClassic + totalScoreTimed + totalLinesClassic + totalLinesTimed + totalTime;

        // Summary Header
        const summaryDiv = document.createElement('div');
        summaryDiv.style.cssText = `
          padding: 15px;
          margin-bottom: 20px;
          border-radius: 12px;
          background: linear-gradient(135deg, rgba(251, 191, 36, 0.3), rgba(16, 185, 129, 0.3));
          border: 2px solid rgba(255, 255, 255, 0.3);
          text-align: center;
        `;
        summaryDiv.innerHTML = `
          <h3 style="margin: 0 0 10px 0; color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);">
            🏆 ${currentLang === 'gu' ? 'કુલ સિદ્ધિઓ' : 'Total Achievements'}: ${grandTotal}/75
          </h3>
          <div style="display: flex; justify-content: space-around; font-size: 12px; color: white; flex-wrap: wrap;">
            <div>🎮 Classic Score: ${totalScoreClassic}/15</div>
            <div>⏱️ Timed Score: ${totalScoreTimed}/15</div>
            <div>📏 Classic Lines: ${totalLinesClassic}/15</div>
            <div>📏 Timed Lines: ${totalLinesTimed}/15</div>
            <div>⏱️ Extra Time: ${totalTime}/15</div>
          </div>
        `;
        listContainer.appendChild(summaryDiv);

        // Classic Score Achievements
        const scoreClassicSection = document.createElement('div');
        scoreClassicSection.style.marginBottom = '20px';
        scoreClassicSection.innerHTML = `<h4 style="color: white; font-weight: bold; font-size: 1.3rem; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);">🎮 ${currentLang === 'gu' ? 'ક્લાસિક સ્કોર સિદ્ધિઓ' : 'Classic Score Achievements'} (${totalScoreClassic}/15)</h4>`;

        achievementDefinitions.scoreClassic.forEach(achievement => {
          const unlocked = userData.achievements[achievement.key];
          const name = currentLang === 'gu' ? achievement.name : achievement.nameEn;

          const achievementDiv = document.createElement('div');
          achievementDiv.style.cssText = `
            padding: 10px;
            margin: 5px 0;
            border-radius: 8px;
            background: ${unlocked ? 'rgba(251, 191, 36, 0.2)' : 'rgba(100, 100, 100, 0.1)'};
            opacity: ${unlocked ? '1' : '0.5'};
            border: 2px solid ${unlocked ? '#fbbf24' : '#555'};
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: 500;
          `;
          achievementDiv.innerHTML = `
            <strong style="color: white; font-weight: bold; text-shadow: 1px 1px 2px rgba(0,0,0,0.5);">${unlocked ? '✅' : '🔒'} ${name} #${achievement.level}</strong><br>
            <small style="color: rgba(255, 255, 255, 0.9); text-shadow: 1px 1px 2px rgba(0,0,0,0.5);">${currentLang === 'gu' ? 'સ્કોર' : 'Score'}: ${achievement.target.toLocaleString()}</small>
          `;
          scoreClassicSection.appendChild(achievementDiv);
        });

        listContainer.appendChild(scoreClassicSection);

        // Timed Score Achievements
        const scoreTimedSection = document.createElement('div');
        scoreTimedSection.style.marginBottom = '20px';
        scoreTimedSection.innerHTML = `<h4 style="color: white; font-weight: bold; font-size: 1.3rem; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);">⏱️ ${currentLang === 'gu' ? 'ટાઇમ્ડ સ્કોર સિદ્ધિઓ' : 'Timed Score Achievements'} (${totalScoreTimed}/15)</h4>`;

        achievementDefinitions.scoreTimed.forEach(achievement => {
          const unlocked = userData.achievements[achievement.key];
          const name = currentLang === 'gu' ? achievement.name : achievement.nameEn;

          const achievementDiv = document.createElement('div');
          achievementDiv.style.cssText = `
            padding: 10px;
            margin: 5px 0;
            border-radius: 8px;
            background: ${unlocked ? 'rgba(251, 191, 36, 0.2)' : 'rgba(100, 100, 100, 0.1)'};
            opacity: ${unlocked ? '1' : '0.5'};
            border: 2px solid ${unlocked ? '#fbbf24' : '#555'};
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: 500;
          `;
          achievementDiv.innerHTML = `
            <strong style="color: white; font-weight: bold; text-shadow: 1px 1px 2px rgba(0,0,0,0.5);">${unlocked ? '✅' : '🔒'} ${name} #${achievement.level}</strong><br>
            <small style="color: rgba(255, 255, 255, 0.9); text-shadow: 1px 1px 2px rgba(0,0,0,0.5);">${currentLang === 'gu' ? 'સ્કોર' : 'Score'}: ${achievement.target.toLocaleString()}</small>
          `;
          scoreTimedSection.appendChild(achievementDiv);
        });

        listContainer.appendChild(scoreTimedSection);

        // Classic Line Achievements
        const lineClassicSection = document.createElement('div');
        lineClassicSection.style.marginBottom = '20px';
        lineClassicSection.innerHTML = `<h4 style="color: white; font-weight: bold; font-size: 1.3rem; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);">📏 ${currentLang === 'gu' ? 'ક્લાસિક લાઇન સિદ્ધિઓ' : 'Classic Line Achievements'} (${totalLinesClassic}/15)</h4>`;

        achievementDefinitions.linesClassic.forEach(achievement => {
          const unlocked = userData.achievements[achievement.key];
          const name = currentLang === 'gu' ? achievement.name : achievement.nameEn;

          const achievementDiv = document.createElement('div');
          achievementDiv.style.cssText = `
            padding: 10px;
            margin: 5px 0;
            border-radius: 8px;
            background: ${unlocked ? 'rgba(16, 185, 129, 0.2)' : 'rgba(100, 100, 100, 0.1)'};
            opacity: ${unlocked ? '1' : '0.5'};
            border: 2px solid ${unlocked ? '#10b981' : '#555'};
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: 500;
          `;
          achievementDiv.innerHTML = `
            <strong style="color: white; font-weight: bold; text-shadow: 1px 1px 2px rgba(0,0,0,0.5);">${unlocked ? '✅' : '🔒'} ${name} #${achievement.level}</strong><br>
            <small style="color: rgba(255, 255, 255, 0.9); text-shadow: 1px 1px 2px rgba(0,0,0,0.5);">${currentLang === 'gu' ? 'લાઇન' : 'Lines'}: ${achievement.target.toLocaleString()}</small>
          `;
          lineClassicSection.appendChild(achievementDiv);
        });

        listContainer.appendChild(lineClassicSection);

        // Timed Line Achievements
        const lineTimedSection = document.createElement('div');
        lineTimedSection.style.marginBottom = '20px';
        lineTimedSection.innerHTML = `<h4 style="color: white; font-weight: bold; font-size: 1.3rem; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);">📏 ${currentLang === 'gu' ? 'ટાઇમ્ડ લાઇન સિદ્ધિઓ' : 'Timed Line Achievements'} (${totalLinesTimed}/15)</h4>`;

        achievementDefinitions.linesTimed.forEach(achievement => {
          const unlocked = userData.achievements[achievement.key];
          const name = currentLang === 'gu' ? achievement.name : achievement.nameEn;

          const achievementDiv = document.createElement('div');
          achievementDiv.style.cssText = `
            padding: 10px;
            margin: 5px 0;
            border-radius: 8px;
            background: ${unlocked ? 'rgba(16, 185, 129, 0.2)' : 'rgba(100, 100, 100, 0.1)'};
            opacity: ${unlocked ? '1' : '0.5'};
            border: 2px solid ${unlocked ? '#10b981' : '#555'};
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: 500;
          `;
          achievementDiv.innerHTML = `
            <strong style="color: white; font-weight: bold; text-shadow: 1px 1px 2px rgba(0,0,0,0.5);">${unlocked ? '✅' : '🔒'} ${name} #${achievement.level}</strong><br>
            <small style="color: rgba(255, 255, 255, 0.9); text-shadow: 1px 1px 2px rgba(0,0,0,0.5);">${currentLang === 'gu' ? 'લાઇન' : 'Lines'}: ${achievement.target.toLocaleString()}</small>
          `;
          lineTimedSection.appendChild(achievementDiv);
        });

        listContainer.appendChild(lineTimedSection);

        // Extra Time Achievements (Timed Mode Only)
        const timeSection = document.createElement('div');
        timeSection.style.marginBottom = '20px';
        timeSection.innerHTML = `<h4 style="color: white; font-weight: bold; font-size: 1.3rem; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);">⏱️ ${currentLang === 'gu' ? 'વધારાનો સમય સિદ્ધિઓ (ટાઇમ્ડ મોડ માટે)' : 'Extra Time Achievements (Timed Mode Only)'} (${totalTime}/15)</h4>`;

        achievementDefinitions.extraTime.forEach(achievement => {
          const unlocked = userData.achievements[achievement.key];
          const name = currentLang === 'gu' ? achievement.name : achievement.nameEn;
          const displayValue = achievement.displayTarget || achievement.target;

          const achievementDiv = document.createElement('div');
          achievementDiv.style.cssText = `
            padding: 10px;
            margin: 5px 0;
            border-radius: 8px;
            background: ${unlocked ? 'rgba(14, 165, 233, 0.2)' : 'rgba(100, 100, 100, 0.1)'};
            opacity: ${unlocked ? '1' : '0.5'};
            border: 2px solid ${unlocked ? '#0ea5e9' : '#555'};
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: 500;
          `;
          achievementDiv.innerHTML = `
            <strong style="color: white; font-weight: bold; text-shadow: 1px 1px 2px rgba(0,0,0,0.5);">${unlocked ? '✅' : '🔒'} ${name} #${achievement.level}</strong><br>
            <small style="color: rgba(255, 255, 255, 0.9); text-shadow: 1px 1px 2px rgba(0,0,0,0.5);">${currentLang === 'gu' ? 'વધારાનો સમય' : 'Extra Time'}: ${displayValue}${currentLang === 'gu' ? ' સેકંડ' : ' sec'}</small>
          `;
          timeSection.appendChild(achievementDiv);
        });

        listContainer.appendChild(timeSection);

        modal.style.display = 'block';
      }

      function getCountryFlag(country) {
        return getFlagEmoji(country);
      }
      // Function to show info pages (How to Play / Privacy Policy)
      function showInfoPage(htmlFile, pageId, contentId) {
        const page = document.getElementById(pageId);
        const content = document.getElementById(contentId);

        if (!page || !content) return;

        // Hide home screen
        const homeScreen = document.getElementById('homeScreen');
        if (homeScreen) {
          homeScreen.style.display = 'none';
        }

        // Show info page
        page.classList.remove('user-stats-hidden');

        // Determine the correct path based on environment
        // Check if running in Android WebView
        const isAndroidWebView = typeof window.Android !== 'undefined';
        let filePath;

        if (isAndroidWebView) {
          // Android WebView: use android_asset path
          filePath = `file:///android_asset/${htmlFile}`;
        } else {
          // Browser: use relative path
          filePath = htmlFile;
        }

        // Load HTML file using iframe (works better in WebView)
        content.innerHTML = `
          <iframe 
            src="${filePath}" 
            style="width: 100%; height: 100%; min-height: 600px; border: none; background: white; border-radius: 10px;"
            frameborder="0">
          </iframe>
        `;
      }

      // Function to hide info page and return to home
      function hideInfoPage(pageId) {
        const page = document.getElementById(pageId);
        if (page) {
          page.classList.add('user-stats-hidden');
        }

        // Show home screen
        const homeScreen = document.getElementById('homeScreen');
        if (homeScreen) {
          homeScreen.style.display = 'flex';
        }
      }

      async function showLeaderboard(mode) {
        const contentDiv = document.getElementById('leaderboardContent');
        const countryFilter = document.getElementById('leaderboardCountryFilter').value;
        contentDiv.innerHTML = '<p>Loading...</p>';

        try {
          // Fetch ALL leaderboard data from Firebase (no limit for accurate count)
          const leaderboardRef = window.firebaseModules.firestore.collection(
            window.firebaseDB,
            'leaderboard'
          );

          const scoreField = mode === 'classic' ? 'classicHighScore' : 'timedHighScore';

          // Fetch all players ordered by score
          const q = window.firebaseModules.firestore.query(
            leaderboardRef,
            window.firebaseModules.firestore.orderBy(scoreField, 'desc')
          );

          const querySnapshot = await window.firebaseModules.firestore.getDocs(q);

          const allPlayers = [];
          querySnapshot.forEach((doc) => {
            const data = doc.data();
            if (data[scoreField] > 0) {
              allPlayers.push({
                uid: doc.id,
                displayName: data.displayName || 'Anonymous',
                country: data.country || '',
                score: data[scoreField]
              });
            }
          });

          // Apply country filter if selected
          let leaderboardData;
          let totalPlayers;

          if (countryFilter) {
            // Filter by country code (lowercase)
            leaderboardData = allPlayers.filter(player => {
              return player.country?.toLowerCase() === countryFilter.toLowerCase();
            });
            totalPlayers = leaderboardData.length;

            // Find current user's rank in filtered list
            const currentUserId = currentFirebaseUser ? currentFirebaseUser.uid : 'guest';
            const currentUserScore = mode === 'classic'
              ? userData.gameStats.classicHighScore
              : userData.gameStats.timedHighScore;

            // Calculate exact rank from full filtered list
            let currentUserRank = leaderboardData.findIndex(item => item.uid === currentUserId) + 1;

            if (currentUserRank === 0) {
              // User not found, calculate rank by counting players with higher score
              currentUserRank = leaderboardData.filter(item => item.score > currentUserScore).length + 1;
            }

            // Limit to top 500 for display
            leaderboardData = leaderboardData.slice(0, 500);

            // Display rank text - exact number, no percentage
            let rankText = '';
            if (currentUserRank <= 10) {
              rankText = `🥇 Rank: ${currentUserRank} / ${totalPlayers}`;
            } else if (currentUserRank <= 100) {
              rankText = `🥈 Rank: ${currentUserRank} / ${totalPlayers}`;
            } else if (currentUserRank <= 500) {
              rankText = `🥉 Rank: ${currentUserRank} / ${totalPlayers}`;
            } else {
              rankText = `📊 Rank: ${currentUserRank} / ${totalPlayers}`;
            }

            displayLeaderboard(contentDiv, leaderboardData, currentUserId, currentUserScore, rankText, totalPlayers);

          } else {
            // Global - all players
            totalPlayers = allPlayers.length;

            // Find current user's rank in global list
            const currentUserId = currentFirebaseUser ? currentFirebaseUser.uid : 'guest';
            const currentUserScore = mode === 'classic'
              ? userData.gameStats.classicHighScore
              : userData.gameStats.timedHighScore;

            // Calculate exact rank from full global list
            let currentUserRank = allPlayers.findIndex(item => item.uid === currentUserId) + 1;

            if (currentUserRank === 0) {
              // User not found, calculate rank by counting players with higher score
              currentUserRank = allPlayers.filter(item => item.score > currentUserScore).length + 1;
            }

            // Limit to top 500 for display
            leaderboardData = allPlayers.slice(0, 500);

            // Display rank text - exact number, no percentage
            let rankText = '';
            if (currentUserRank <= 10) {
              rankText = `🥇 Rank: ${currentUserRank} / ${totalPlayers}`;
            } else if (currentUserRank <= 100) {
              rankText = `🥈 Rank: ${currentUserRank} / ${totalPlayers}`;
            } else if (currentUserRank <= 500) {
              rankText = `🥉 Rank: ${currentUserRank} / ${totalPlayers}`;
            } else {
              rankText = `📊 Rank: ${currentUserRank} / ${totalPlayers}`;
            }

            displayLeaderboard(contentDiv, leaderboardData, currentUserId, currentUserScore, rankText, totalPlayers);
          }

        } catch (error) {
          console.error('Error loading leaderboard:', error);
          contentDiv.innerHTML = `<p>${currentLang === 'gu' ? 'લીડરબોર્ડ લોડ કરવામાં ભૂલ' : 'Error loading leaderboard'}: ${error.message}</p>`;
        }
      }

      function getCountryShortName(country) {
        const shortNames = {
          'India': 'IN',
          'USA': 'US',
          'UK': 'GB',
          'Canada': 'CA',
          'Australia': 'AU',
          'Germany': 'DE',
          'France': 'FR',
          'Japan': 'JP',
          'China': 'CN',
          'Brazil': 'BR',
          'Mexico': 'MX',
          'Spain': 'ES',
          'Italy': 'IT',
          'South Korea': 'KR',
          'Netherlands': 'NL',
          'Other': 'XX'
        };

        // If already a short code (2 chars), return as-is
        if (country && country.length === 2) {
          return country.toUpperCase();
        }

        return shortNames[country] || '';
      }

      function getRankIcon(rank) {
        if (rank <= 10) return '🥇';
        if (rank <= 100) return '🥈';
        if (rank <= 500) return '🥉';
        return '📊';
      }

      function displayLeaderboard(contentDiv, leaderboardData, currentUserId, currentUserScore, rankText, totalPlayers) {
        const displayCount = Math.min(leaderboardData.length, 500);
        const userCountry = userData.profile.country || 'Unknown';
        const userShortCountry = getCountryShortName(userCountry) || '--';

        // Display leaderboard
        contentDiv.innerHTML = `
          <div style="padding: 15px; background: rgba(251, 191, 36, 0.2); border-radius: 10px; margin-bottom: 15px; border: 2px solid #fbbf24;">
            <h4 style="margin: 0 0 5px 0;">👤 ${userData.profile.displayName} ${userShortCountry !== '--' ? `(${userShortCountry})` : ''}</h4>
            <p style="margin: 0; font-size: 1.1em;">
              <strong>${currentLang === 'gu' ? 'સ્કોર' : 'Score'}: ${currentUserScore.toLocaleString()}</strong>
            </p>
            <p style="margin: 5px 0 0 0; color: #fbbf24;">
              <strong>${rankText}</strong>
            </p>
          </div>
          <h4 style="margin: 15px 0 10px 0;">${currentLang === 'gu' ? 'ટોચના ખેલાડીઓ' : 'Top Players'} (${totalPlayers} / Top ${displayCount})</h4>
          <div style="max-height: 400px; overflow-y: auto;">
            ${leaderboardData.map((player, index) => {
          const actualRank = index + 1;
          const rankIcon = getRankIcon(actualRank);
          const playerCountry = player.country || '';
          const shortCountry = getCountryShortName(playerCountry) || '--';

          console.log("Displaying player:", player.displayName, "Country:", playerCountry, "Short:", shortCountry);

          return `
              <div style="
                padding: 8px;
                margin: 5px 0;
                border-radius: 8px;
                background: ${player.uid === currentUserId ? 'rgba(251, 191, 36, 0.3)' : 'rgba(100, 100, 100, 0.1)'};
                border: 2px solid ${index < 3 ? '#fbbf24' : '#555'};
                display: grid;
                grid-template-columns: 35px 40px 1fr 45px auto;
                gap: 8px;
                align-items: center;
                font-size: 14px;
              ">
                <span style="font-weight: bold; color: ${index === 0 ? '#ffd700' : index === 1 ? '#c0c0c0' : index === 2 ? '#cd7f32' : 'white'};">
                  ${actualRank}.
                </span>
                <span style="font-size: 18px;">
                  ${rankIcon}
                </span>
                <span style="font-weight: 600; color: white; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                  ${player.displayName}
                </span>
                <span style="font-weight: 500; color: #fbbf24; font-size: 12px;">
                  ${shortCountry}
                </span>
                <span style="font-weight: bold; color: #10b981; text-align: right;">
                  ${player.score.toLocaleString()}
                </span>
              </div>
            `;
        }).join('')}
          </div>
        `;
      }

      // Initialize Firebase when page loads
      initializeFirebaseAuth();

      // Force UI update after Firebase initialization
      setTimeout(() => {
        console.log("Force updating UI after page load...");
        if (userData && Object.keys(userData).length > 0) {
          updateUIWithUserData();
        }

        // Force hide achievement popup if it's visible during startup
        const achievementPopup = document.getElementById('achievementPopup');
        if (achievementPopup) {
          achievementPopup.style.display = 'none';
          achievementPopup.classList.add('user-stats-hidden');
          console.log("Achievement popup forcibly hidden during startup");
        }

        // Clear startup flag after initial load is complete
        // This prevents achievement popups from showing on app startup
        isStartupLoad = false;
        console.log("Startup load completed - achievement tracking enabled");

        // DO NOT auto-restore game on page load
        // Game will be restored only when user explicitly clicks Classic or Timed button
        // This ensures home screen always shows first, and user has control
        console.log("✅ Home screen shown - game will restore only when user clicks Classic/Timed button");

        // Ensure home screen is visible and game containers are hidden
        const homeScreen = document.getElementById('homeScreen');
        const classicContainer = document.getElementById('classicContainer');
        const timedContainer = document.getElementById('timedContainer');
        if (homeScreen) homeScreen.style.display = 'flex';
        if (classicContainer) classicContainer.style.display = 'none';
        if (timedContainer) timedContainer.style.display = 'none';

        // Monitor for any rogue achievement popups and force hide them
        const achievementMonitor = setInterval(() => {
          const popup = document.getElementById('achievementPopup');
          if (popup && popup.style.display === 'block' && !isGameActive) {
            console.log("Detected rogue achievement popup - force hiding");
            popup.style.display = 'none';
            popup.classList.add('user-stats-hidden');
          }
        }, 500);

        // Stop monitoring after 10 seconds
        setTimeout(() => {
          clearInterval(achievementMonitor);
          console.log("Achievement popup monitoring stopped");
        }, 10000);
      }, 2000);


      let currentLang = SafeStorage.getItem('blockPuzzleLang') || 'en'; // default English, persisted


      /* Shared shapes + utility (added) */
      const shapes = [
        // Original 53 shapes
        { shape: [[1]], color: "#991b1b" },                                    // 1. Single Block (1x1) - darker red
        { shape: [[1, 1]], color: "#92400e" },                                 // 2. Horizontal Domino (2x1) - darker orange
        { shape: [[1, 1, 1]], color: "#064e3b" },                              // 3. Horizontal Trio (3x1) - darker green
        { shape: [[1, 1, 1, 1]], color: "#1e3a8a" },                           // 4. Horizontal Line (4x1) - darker blue
        { shape: [[1, 1, 1, 1, 1]], color: "#5b21b6" },                        // 5. Long Horizontal Line (5x1) - darker purple
        { shape: [[1], [1]], color: "#9f1239" },                               // 6. Vertical Domino (1x2) - darker pink
        { shape: [[1], [1], [1]], color: "#854d0e" },                          // 7. Vertical Trio (1x3) - darker yellow
        { shape: [[1], [1], [1], [1]], color: "#15803d" },                     // 8. Vertical Line (1x4) - darker green
        { shape: [[1], [1], [1], [1], [1]], color: "#0c4a6e" },                // 9. Long Vertical Line (1x5) - darker sky
        { shape: [[1, 1], [1, 1]], color: "#c2410c" },                         // 10. Square (2x2) - darker orange
        { shape: [[1, 1, 1], [1, 1, 1]], color: "#115e59" },                   // 11. Rectangle (3x2) - darker teal
        { shape: [[1, 1], [1, 1], [1, 1]], color: "#ca8a04" },                 // 12. Rectangle (2x3 - Vertical) - darker yellow
        { shape: [[1, 1, 1], [1, 1, 1], [1, 1, 1]], color: "#6b21a8" },        // 13. Big Square (3x3) - darker purple
        { shape: [[0, 1, 0], [1, 1, 1]], color: "#9f1239" },                   // 14. T-Shape (Up) - darker rose
        { shape: [[1, 0], [1, 1], [1, 0]], color: "#0e7490" },                 // 15. T-Shape (Left) - darker cyan
        { shape: [[1, 1, 1], [0, 1, 0]], color: "#4d7c0f" },                   // 16. T-Shape (Down) - darker lime
        { shape: [[0, 1], [1, 1], [0, 1]], color: "#a21caf" },                 // 17. T-Shape (Right) - darker fuchsia
        { shape: [[1, 0], [1, 1]], color: "#a16207" },                         // 18. L-Shape (Small, Left-Bottom) - darker yellow
        { shape: [[1, 1], [1, 0]], color: "#15803d" },                         // 19. L-Shape (Small, Right-Bottom) - darker green
        { shape: [[0, 1], [1, 1]], color: "#991b1b" },                         // 20. L-Shape (Small, Left-Top) - darker red
        { shape: [[1, 1], [0, 1]], color: "#dc2626" },                         // 21. L-Shape (Small, Left-Top) - darker red
        { shape: [[1, 0], [1, 0], [1, 1]], color: "#9f1239" },                 // 22. L-Shape (Long, Left-Bottom) Duplicate - darker pink
        { shape: [[0, 1], [0, 1], [1, 1]], color: "#854d0e" },                 // 23. L-Shape (Long, Right-Bottom) - darker yellow
        { shape: [[1, 1], [1, 0], [1, 0]], color: "#15803d" },                 // 24. L-Shape (Long, Left-Top) - darker green
        { shape: [[1, 1], [0, 1], [0, 1]], color: "#0c4a6e" },                 // 25. L-Shape (Long, Right-Top) - darker sky
        { shape: [[1, 1, 1], [1, 0, 0]], color: "#0891b2" },                   // 26. L-Shape (Wide, Left-Top) - darker cyan
        { shape: [[1, 0, 0], [1, 1, 1]], color: "#b45309" },                   // 27. L-Shape (Wide, Left-Bottom) - darker amber
        { shape: [[0, 0, 1], [1, 1, 1]], color: "#059669" },                   // 28. L-Shape (Wide, Right-Bottom) - darker emerald
        { shape: [[1, 1, 1], [0, 0, 1]], color: "#9ca3af" },                   // 29. L-Shape (Wide, Right-Top) - darker gray
        { shape: [[1, 1, 0], [0, 1, 1]], color: "#1e3a8a" },                   // 30. Z-Shape (Left) - darker blue
        { shape: [[0, 1, 1], [1, 1, 0]], color: "#dc2626" },                   // 31. Z-Shape (Right) - darker red
        { shape: [[1, 0], [1, 1], [0, 1]], color: "#0d9488" },                 // 32. Z-Shape (Vertical, Left) - darker teal
        { shape: [[0, 1], [1, 1], [1, 0]], color: "#a855f7" },                 // 33. Z-Shape (Vertical, Right) - darker purple
        { shape: [[1, 0, 1], [1, 1, 1]], color: "#7c3aed" },                   // 34. U-Shape (Up) - darker violet
        { shape: [[1, 1, 1], [1, 0, 1]], color: "#db2777" },                   // 35. U-Shape (Down) - darker pink
        { shape: [[1, 1, 1], [0, 0, 1], [0, 0, 1]], color: "#e11d48" },        // 36. L-Shape (3x3, Right-Top) - darker rose
        { shape: [[0, 0, 1], [0, 0, 1], [1, 1, 1]], color: "#9f1239" },        // 37. L-Shape (3x3, Right-Bottom) - darker pink
        { shape: [[1, 0, 0], [1, 0, 0], [1, 1, 1]], color: "#b45309" },        // 38. L-Shape (3x3, Left-Bottom) - darker amber
        { shape: [[1, 1, 1], [1, 0, 0], [1, 0, 0]], color: "#1e3a8a" },        // 39. L-Shape (3x3, Left-Top) - darker blue
        { shape: [[1, 1], [1, 0], [1, 1]], color: "#dc2626" },                 // 40. H-Shape (Left) - darker red
        { shape: [[1, 1], [0, 1], [1, 1]], color: "#3b82f6" },                 // 41. H-Shape (Right) - darker blue
        { shape: [[0, 1], [0, 1], [1, 1]], color: "#e11d48" },                 // 42. P-Shape (Vertical, Left) - darker teal
        { shape: [[0, 1], [1, 1], [1, 1]], color: "#f97316" },                 // 43. P-Shape (Vertical, Right) - darker orange
        { shape: [[1, 1], [1, 1], [1, 0]], color: "#dc2626" },                 // 44. P-Shape (Vertical, Left-Top) - darker red
        { shape: [[1, 1], [1, 1], [0, 1]], color: "#3b82f6" },                 // 45. P-Shape (Vertical, Right-Top) - darker blue
        { shape: [[1, 1, 1], [1, 1, 0]], color: "#db2777" },                   // 46. P-Shape (Left) - darker pink
        { shape: [[1, 1, 0], [1, 1, 1]], color: "#ca8a04" },                   // 47. P-Shape (Bottom-Left) - darker yellow
        { shape: [[0, 1, 1], [1, 1, 1]], color: "#059669" },                   // 48. P-Shape (Bottom-Right) - darker emerald
        { shape: [[1, 1, 1], [0, 1, 1]], color: "#0891b2" },                   // 49. P-Shape (Right) - darker cyan
        { shape: [[0, 0, 1], [1, 1, 1], [0, 0, 1]], color: "#064e3b" },        // 50. T-Shape (Tall, Right) - darker emerald
        { shape: [[0, 1, 0], [0, 1, 0], [1, 1, 1]], color: "#5b21b6" },        // 51. T-Shape (Tall, Down) - darker violet
        { shape: [[1, 1, 1], [0, 1, 0], [0, 1, 0]], color: "#047857" },        // 52. T-Shape (Tall, Up) - darker emerald
        { shape: [[1, 0, 0], [1, 1, 1], [1, 0, 0]], color: "#1f2937" },        // 53. T-Shape (Tall, Left) - darker gray
      ];

      /* Device-specific calibration for drag precision */
      function getDeviceInfo() {
        const ua = navigator.userAgent.toLowerCase();
        const device = {
          model: '',
          needsPrecisionFix: false,
          epsilon: 0,
          isOldAndroid: false,
          useInstantPlacement: false
        };

        // Detect Android version
        const androidMatch = ua.match(/android\s+(\d+)/);
        const androidVersion = androidMatch ? parseInt(androidMatch[1]) : 0;

        // Detect refresh rate capability (Android 13 and below typically 60Hz, Android 14+ may have 120Hz)
        device.isLowRefreshRate = androidVersion > 0 && androidVersion <= 13;
        device.use2DTransforms = device.isLowRefreshRate; // Use 2D transforms for 60Hz devices

        // Android 11 થી નીચે (Android 10, 9, 8, etc.)
        if (androidVersion > 0 && androidVersion < 11) {
          device.isOldAndroid = true;
          device.useInstantPlacement = true;
          device.model = `Android ${androidVersion}`;
          console.log(`📱 Old Android detected: ${device.model} - Using instant placement optimization`);
        } else if (device.isLowRefreshRate) {
          device.model = `Android ${androidVersion} (60Hz)`;
          console.log(`📱 Low refresh rate device detected: ${device.model} - Using 2D transforms and throttled updates`);
        }

        // OnePlus Nord 2
        if (ua.includes('oneplus') && (ua.includes('nord') || ua.includes('iv2201'))) {
          device.model = 'OnePlus Nord 2';
          device.needsPrecisionFix = true;
          device.epsilon = 0.35; // Aggressive rounding bias
        }
        // Samsung M31
        else if (ua.includes('samsung') && (ua.includes('m31') || ua.includes('sm-m315f'))) {
          device.model = 'Samsung M31';
          device.needsPrecisionFix = true;
          device.epsilon = 0.4; // Stronger correction needed
        }
        // Poco C3
        else if (ua.includes('poco') && (ua.includes('c3') || ua.includes('m2006c3'))) {
          device.model = 'Poco C3';
          device.needsPrecisionFix = true;
          device.epsilon = 0.38;
        }
        // Generic low-end devices (as fallback)
        else if (ua.includes('android') && window.devicePixelRatio && window.devicePixelRatio < 2) {
          device.model = 'Low DPR Android';
          device.needsPrecisionFix = true;
          device.epsilon = 0.3;
        }

        return device;
      }

      const deviceInfo = getDeviceInfo();
      if (deviceInfo.needsPrecisionFix) {
        console.log(`📱 Device detected: ${deviceInfo.model} - Applying precision fix with epsilon ${deviceInfo.epsilon}`);
      }

      // Original random shape function (kept for backward compatibility)
      function randomShapeOriginal() {
        return JSON.parse(JSON.stringify(shapes[Math.floor(Math.random() * shapes.length)]));
      }

      // Weighted random shape function based on 10-session cycle
      function randomShape() {
        // Check if we need to start a new 10-session cycle
        if (shapeSessionCounter >= 10 || shapePool.length === 0) {
          shapeSessionCounter = 0;
          initializeShapePool();
        }

        // Get shape index from pool
        const shapeIndex = shapePool[shapeSessionCounter % shapePool.length];
        shapeSessionCounter++;

        // Return a deep copy of the shape
        return JSON.parse(JSON.stringify(shapes[shapeIndex]));
      }

      /* Highscore storage and helpers */
      let highscoreClassic = parseInt(SafeStorage.getItem("highscoreClassic") || "0", 10);
      let highscoreTimed = parseInt(SafeStorage.getItem("highscoreTimed") || "0", 10);

      function coerceScoreValue(rawValue) {
        if (typeof rawValue === 'number' && Number.isFinite(rawValue)) {
          return rawValue;
        }
        if (typeof rawValue === 'string') {
          const sanitized = rawValue.replace(/[^0-9.-]/g, '');
          const parsed = Number.parseFloat(sanitized);
          if (Number.isFinite(parsed)) {
            return parsed;
          }
        }
        return 0;
      }

      function extractModeHighScore(stats, mode) {
        if (!stats || typeof stats !== 'object') return 0;

        const candidates = [];
        const nested = stats[mode];
        const modesCollection = stats.modes && typeof stats.modes === 'object' ? stats.modes[mode] : null;
        const highscoresCollection = stats.highscores && typeof stats.highscores === 'object' ? stats.highscores[mode] : null;

        if (mode === 'classic') {
          candidates.push(
            stats.classicHighScore,
            stats.classicHighscore,
            stats.highscoreClassic,
            stats.classicScore,
            stats.bestClassicScore,
            stats.classic_best,
            stats.classicBest
          );
        } else {
          candidates.push(
            stats.timedHighScore,
            stats.timedHighscore,
            stats.highscoreTimed,
            stats.timedScore,
            stats.bestTimedScore,
            stats.timed_best,
            stats.timedBest
          );
        }

        if (nested && typeof nested === 'object') {
          candidates.push(
            nested.highScore,
            nested.highscore,
            nested.bestScore,
            nested.best,
            nested.score
          );
        }

        if (modesCollection && typeof modesCollection === 'object') {
          candidates.push(
            modesCollection.highScore,
            modesCollection.highscore,
            modesCollection.bestScore,
            modesCollection.best,
            modesCollection.score
          );
        }

        if (highscoresCollection && typeof highscoresCollection === 'object') {
          candidates.push(
            highscoresCollection.highScore,
            highscoresCollection.highscore,
            highscoresCollection.bestScore,
            highscoresCollection.best,
            highscoresCollection.score
          );
        }

        let maxScore = 0;
        for (const value of candidates) {
          const score = coerceScoreValue(value);
          if (score > maxScore) {
            maxScore = score;
          }
        }

        return maxScore;
      }
      function refreshHighscoreCaches() {
        if (!userData.gameStats) userData.gameStats = { ...defaultUserData.gameStats };

        const classicFromData = extractModeHighScore(userData.gameStats, 'classic');
        const timedFromData = extractModeHighScore(userData.gameStats, 'timed');

        // Use userData as the source of truth, don't mix with old cached values
        highscoreClassic = classicFromData;
        highscoreTimed = timedFromData;

        userData.gameStats.classicHighScore = highscoreClassic;
        userData.gameStats.timedHighScore = highscoreTimed;
        const bestOverall = Math.max(highscoreClassic, highscoreTimed, coerceScoreValue(userData.gameStats.highScore));
        userData.gameStats.highScore = bestOverall;

        // Local storage removed - Firebase only
        // localStorage.setItem("highscoreClassic", String(highscoreClassic));
        // localStorage.setItem("highscoreTimed", String(highscoreTimed));

        updateHighscoreDisplays();

        if (isUserDataLoaded) {
          saveLocalUserData();
        }
      }
      function updateHighscoreDisplays() {
        const classicValue = Number.isFinite(highscoreClassic) ? highscoreClassic : 0;
        const timedValue = Number.isFinite(highscoreTimed) ? highscoreTimed : 0;

        const hsCardClassic = document.getElementById("classicHighScoreDisplay");
        if (hsCardClassic) {
          hsCardClassic.textContent = classicValue.toLocaleString();
        }

        const hsCardTimed = document.getElementById("timedHighScoreDisplay");
        if (hsCardTimed) {
          hsCardTimed.textContent = timedValue.toLocaleString();
        }

        const s = document.getElementById("hsSmall");
        if (s) s.textContent = "🏆 " + classicValue;

        const st = document.getElementById("hsSmallTimed");
        if (st) st.textContent = "🏆 " + timedValue;
      }

      function updateHighscore(mode, score) {
        if (!userData.gameStats) userData.gameStats = { ...defaultUserData.gameStats };

        let updated = false;
        if (mode === "classic") {
          if (score > highscoreClassic) {
            highscoreClassic = score;
            // localStorage.setItem("highscoreClassic", String(highscoreClassic)); // Removed - Firebase only
            userData.gameStats.classicHighScore = highscoreClassic;
            updated = true;
          }
        } else {
          if (score > highscoreTimed) {
            highscoreTimed = score;
            // localStorage.setItem("highscoreTimed", String(highscoreTimed)); // Removed - Firebase only
            userData.gameStats.timedHighScore = highscoreTimed;
            updated = true;
          }
        }

        const bestOverall = Math.max(highscoreClassic, highscoreTimed);
        if (bestOverall > Number(userData.gameStats.highScore || 0)) {
          userData.gameStats.highScore = bestOverall;
          updated = true;
        }

        updateHighscoreDisplays();

        if (updated) {
          if (currentFirebaseUser) {
            saveUserDataToFirebase(currentFirebaseUser.uid);
          } else {
            // Data saved to Firebase only
          }
        }

        return mode === "classic" ? highscoreClassic : highscoreTimed;
      }

      /* ==================== SOUND SYSTEM ==================== */
      // Sound volumes
      let musicVolume = 0.03;  // 3% default volume
      let effectsVolume = 0.10; // 10% default volume

      // Sound effects enabled flag (controlled by music button)
      let soundEffectsEnabled = true;

      // Background music - Separate for each mode
      // Detect if running in Android WebView or browser
      const isAndroidWebView = window.location.protocol === 'file:' && navigator.userAgent.includes('Android');
      const audioBasePath = isAndroidWebView ? 'file:///android_asset/' : '';

      const bgMusicClassic = new Audio();
      bgMusicClassic.src = isAndroidWebView ? audioBasePath + 'classic background music.mp3' : 'https://firebasestorage.googleapis.com/v0/b/block-puzzle-free-butterfly.firebasestorage.app/o/block%20puzzle%20free%20butterfly%20website%20asset%2Fclassic%20background%20music.mp3?alt=media&token=d5504562-21df-4417-abe6-5cff4583976d';
      bgMusicClassic.loop = true;
      bgMusicClassic.volume = musicVolume;
      bgMusicClassic.preload = 'auto';

      const bgMusicTimed = new Audio();
      bgMusicTimed.src = isAndroidWebView ? audioBasePath + 'timer background music.mp3' : 'https://firebasestorage.googleapis.com/v0/b/block-puzzle-free-butterfly.firebasestorage.app/o/block%20puzzle%20free%20butterfly%20website%20asset%2Ftimer%20background%20music.mp3?alt=media&token=0d1c31b0-338e-472c-8ecb-7fdec3ead68c'; // Timer mode માટે નવો music
      bgMusicTimed.loop = true;
      bgMusicTimed.volume = musicVolume;
      bgMusicTimed.preload = 'auto';

      let currentBgMusic = null; // Track which music is playing

      // Sound effects
      const soundEffects = {
        drag: new Audio(isAndroidWebView ? audioBasePath + 'drag1.mp3' : 'https://firebasestorage.googleapis.com/v0/b/block-puzzle-free-butterfly.firebasestorage.app/o/block%20puzzle%20free%20butterfly%20website%20asset%2Fdrag1.mp3?alt=media&token=1e9b95be-4634-4bde-97c6-99196092951f'),
        place: new Audio(isAndroidWebView ? audioBasePath + 'place1.mp3' : 'https://firebasestorage.googleapis.com/v0/b/block-puzzle-free-butterfly.firebasestorage.app/o/block%20puzzle%20free%20butterfly%20website%20asset%2Fplace1.mp3?alt=media&token=1fed6f40-6a89-4a0c-b4b6-300ab944cc22'),
        clear: new Audio(isAndroidWebView ? audioBasePath + 'line clear.mp3' : 'https://firebasestorage.googleapis.com/v0/b/block-puzzle-free-butterfly.firebasestorage.app/o/block%20puzzle%20free%20butterfly%20website%20asset%2Fline%20clear.mp3?alt=media&token=4dfbe6bf-a1c6-4b37-a00b-a7b414f353a7'),
        combo: new Audio(isAndroidWebView ? audioBasePath + 'combo line clear1.mp3' : 'https://firebasestorage.googleapis.com/v0/b/block-puzzle-free-butterfly.firebasestorage.app/o/block%20puzzle%20free%20butterfly%20website%20asset%2Fcombo%20line%20clear1.mp3?alt=media&token=f71a9b54-6bd2-4a26-85cb-009e22670b63'), // 2+ lines માટે નવો sound
        bonus: new Audio(isAndroidWebView ? audioBasePath + 'time bonus.mp3' : 'https://firebasestorage.googleapis.com/v0/b/block-puzzle-free-butterfly.firebasestorage.app/o/block%20puzzle%20free%20butterfly%20website%20asset%2Ftime%20bonus.mp3?alt=media&token=7a10fc0b-aab9-4408-a411-e653e1b1ae60'),
        gameover: new Audio(isAndroidWebView ? audioBasePath + 'game over.mp3' : 'https://firebasestorage.googleapis.com/v0/b/block-puzzle-free-butterfly.firebasestorage.app/o/block%20puzzle%20free%20butterfly%20website%20asset%2Fgame%20over.mp3?alt=media&token=5ae164a7-390e-4fb5-96da-f53f6d434056'),
        // Combo voice sounds (female voice)
        comboVoice2: new Audio(isAndroidWebView ? audioBasePath + 'combo_nice.mp3' : 'https://firebasestorage.googleapis.com/v0/b/block-puzzle-free-butterfly.firebasestorage.app/o/block%20puzzle%20free%20butterfly%20website%20asset%2Fcombo_nice.mp3?alt=media&token=97e04574-b8cb-428a-8611-7ddd4e5a7ce2'),      // Combo 2,3
        comboVoice4: new Audio(isAndroidWebView ? audioBasePath + 'combo_good.mp3' : 'https://firebasestorage.googleapis.com/v0/b/block-puzzle-free-butterfly.firebasestorage.app/o/block%20puzzle%20free%20butterfly%20website%20asset%2Fcombo_good.mp3?alt=media&token=de50955e-0efd-4049-97cf-e88b4ce69881'),      // Combo 4,5
        comboVoice6: new Audio(isAndroidWebView ? audioBasePath + 'combo_awesome.mp3' : 'https://firebasestorage.googleapis.com/v0/b/block-puzzle-free-butterfly.firebasestorage.app/o/block%20puzzle%20free%20butterfly%20website%20asset%2Fcombo_awesome.mp3?alt=media&token=caa4f0f3-9993-4916-a41b-e36f90f2ba41'),  // Combo 6,7
        comboVoice8: new Audio(isAndroidWebView ? audioBasePath + 'combo_excellent.mp3' : 'https://firebasestorage.googleapis.com/v0/b/block-puzzle-free-butterfly.firebasestorage.app/o/block%20puzzle%20free%20butterfly%20website%20asset%2Fcombo_excellent.mp3?alt=media&token=dbeddf78-779d-43e9-9cc6-4879a3d7d859'), // Combo 8,9
        comboVoice10: new Audio(isAndroidWebView ? audioBasePath + 'combo_incredible.mp3' : 'https://firebasestorage.googleapis.com/v0/b/block-puzzle-free-butterfly.firebasestorage.app/o/block%20puzzle%20free%20butterfly%20website%20asset%2Fcombo_incredible.mp3?alt=media&token=8734bc2d-3d3f-430d-9efa-03188e3e39ef'), // Combo 10+
        comboVoice11: new Audio(isAndroidWebView ? audioBasePath + 'combo_amazing.mp3' : 'https://firebasestorage.googleapis.com/v0/b/block-puzzle-free-butterfly.firebasestorage.app/o/block%20puzzle%20free%20butterfly%20website%20asset%2Fcombo_amazing.mp3?alt=media&token=27a126db-2381-486e-8161-6cbdfcc485cf'),
        comboVoice12: new Audio(isAndroidWebView ? audioBasePath + 'combo_fantastic.mp3' : 'https://firebasestorage.googleapis.com/v0/b/block-puzzle-free-butterfly.firebasestorage.app/o/block%20puzzle%20free%20butterfly%20website%20asset%2Fcombo_fantastic.mp3?alt=media&token=24f0ab0c-91ba-434b-94c4-730139c9ef56'),
        comboVoice13: new Audio(isAndroidWebView ? audioBasePath + 'combo_outstanding.mp3' : 'https://firebasestorage.googleapis.com/v0/b/block-puzzle-free-butterfly.firebasestorage.app/o/block%20puzzle%20free%20butterfly%20website%20asset%2Fcombo_outstanding.mp3?alt=media&token=9d26b7c1-6991-4341-bd93-94ce3b4249d0'),
        comboVoice14: new Audio(isAndroidWebView ? audioBasePath + 'combo_unbelievable.mp3' : 'https://firebasestorage.googleapis.com/v0/b/block-puzzle-free-butterfly.firebasestorage.app/o/block%20puzzle%20free%20butterfly%20website%20asset%2Fcombo_unbelievable.mp3?alt=media&token=9764e6ad-79b5-4ae9-9320-3cc149ad88c7'),
        comboVoice15: new Audio(isAndroidWebView ? audioBasePath + 'combo_perfect.mp3' : 'https://firebasestorage.googleapis.com/v0/b/block-puzzle-free-butterfly.firebasestorage.app/o/block%20puzzle%20free%20butterfly%20website%20asset%2Fcombo_perfect.mp3?alt=media&token=21ae7fd1-dfea-4369-9ea5-72970fcf7402'),
        comboVoice16: new Audio(isAndroidWebView ? audioBasePath + 'combo_brilliant.mp3' : 'https://firebasestorage.googleapis.com/v0/b/block-puzzle-free-butterfly.firebasestorage.app/o/block%20puzzle%20free%20butterfly%20website%20asset%2Fcombo_brilliant.mp3?alt=media&token=962c2959-d4c9-49a5-a19d-9dcfa12818fc')
      };

      // Suppress audio errors in browser (files won't exist)
      Object.values(soundEffects).forEach(sound => {
        sound.addEventListener('error', () => {
          // Silently ignore audio errors in browser
        });
      });

      // Set volumes for all sound effects
      Object.values(soundEffects).forEach(sound => {
        sound.volume = effectsVolume;
      });

      function playSound(type) {
        // Don't play sound effects if they are disabled
        if (!soundEffectsEnabled) {
          return;
        }

        let sound;
        switch (type) {
          case 'drag':
            sound = soundEffects.drag;
            break;
          case 'place':
            sound = soundEffects.place;
            break;
          case 'clear1':
            // 1 line માટે normal clear sound
            sound = soundEffects.clear;
            break;
          case 'clear2':
          case 'clear3':
          case 'clear4':
          case 'clear5':
          case 'clear6':
            // 2+ lines માટે combo sound
            sound = soundEffects.combo;
            break;
          case 'bonus':
            sound = soundEffects.bonus;
            break;
          case 'gameover':
            sound = soundEffects.gameover;
            break;
          default:
            return;
        }

        if (sound) {
          sound.currentTime = 0; // Reset to start
          sound.volume = effectsVolume;
          sound.play().catch(e => console.log('Sound play failed:', e));
        }
      }

      // ===== COMBO VOICE SOUND EFFECTS =====
      // Play female voice encouragement for specific combo counts
      // Uses audio files for mobile compatibility (Web Speech API doesn't work well on mobile)
      function playComboVoice(comboCount) {
        if (!soundEffectsEnabled) {
          return;
        }

        let sound = null;

        // Determine which sound to play based on combo count
        if (comboCount === 2 || comboCount === 3) {
          sound = soundEffects.comboVoice2; // "Nice!"
        } else if (comboCount === 4 || comboCount === 5) {
          sound = soundEffects.comboVoice4; // "Good!"
        } else if (comboCount === 6 || comboCount === 7) {
          sound = soundEffects.comboVoice6; // "Awesome!"
        } else if (comboCount === 8 || comboCount === 9) {
          sound = soundEffects.comboVoice8; // "Excellent!"
        } else if (comboCount >= 10) {
          // For combo 10 and above, cycle through messages
          const highComboSounds = [
            soundEffects.comboVoice10,  // "Incredible!"
            soundEffects.comboVoice11,  // "Amazing!"
            soundEffects.comboVoice12,  // "Fantastic!"
            soundEffects.comboVoice13,  // "Outstanding!"
            soundEffects.comboVoice14,  // "Unbelievable!"
            soundEffects.comboVoice15,  // "Perfect!"
            soundEffects.comboVoice16   // "Brilliant!"
          ];
          const soundIndex = (comboCount - 10) % highComboSounds.length;
          sound = highComboSounds[soundIndex];
        } else {
          // No voice for combo 1
          return;
        }

        // Play audio file if available
        if (sound) {
          try {
            sound.currentTime = 0; // Reset to start
            // Combo voice sounds use higher volume (25%) for better clarity
            sound.volume = Math.min(effectsVolume * 2.5, 0.25); // 2.5x effects volume, max 25%
            sound.play().catch(e => {
              console.log('Combo voice audio play failed:', e);
              // Fallback to Web Speech API if audio file doesn't exist
              playComboVoiceFallback(comboCount);
            });
          } catch (e) {
            console.log('Combo voice error:', e);
            // Fallback to Web Speech API if audio file doesn't exist
            playComboVoiceFallback(comboCount);
          }
        } else {
          // Fallback to Web Speech API
          playComboVoiceFallback(comboCount);
        }
      }

      // Fallback function using Web Speech API (for browsers/desktop)
      function playComboVoiceFallback(comboCount) {
        // Check if Web Speech API is available
        if (!('speechSynthesis' in window)) {
          console.log('Web Speech API not available');
          return;
        }

        // Combo voice messages based on combo count
        let message = '';

        if (comboCount === 2 || comboCount === 3) {
          message = 'Nice!';
        } else if (comboCount === 4 || comboCount === 5) {
          message = 'Good!';
        } else if (comboCount === 6 || comboCount === 7) {
          message = 'Awesome!';
        } else if (comboCount === 8 || comboCount === 9) {
          message = 'Excellent!';
        } else if (comboCount >= 10) {
          // For combo 10 and above, cycle through messages
          const highComboMessages = [
            'Incredible!',
            'Amazing!',
            'Fantastic!',
            'Outstanding!',
            'Unbelievable!',
            'Perfect!',
            'Brilliant!'
          ];
          const messageIndex = (comboCount - 10) % highComboMessages.length;
          message = highComboMessages[messageIndex];
        } else {
          return;
        }

        // Cancel any ongoing speech
        window.speechSynthesis.cancel();

        // Create speech utterance
        const utterance = new SpeechSynthesisUtterance(message);

        // Try to use female voice (if available)
        const voices = window.speechSynthesis.getVoices();
        const femaleVoice = voices.find(voice =>
          voice.name.toLowerCase().includes('female') ||
          voice.name.toLowerCase().includes('zira') ||  // Windows female voice
          voice.name.toLowerCase().includes('samantha') ||  // macOS female voice
          voice.name.toLowerCase().includes('karen') ||  // macOS female voice
          voice.name.toLowerCase().includes('veena') ||  // Android female voice
          (voice.lang.startsWith('en') && voice.gender === 'female')
        );

        if (femaleVoice) {
          utterance.voice = femaleVoice;
        } else {
          // Fallback: use first available English voice
          const englishVoice = voices.find(voice => voice.lang.startsWith('en'));
          if (englishVoice) {
            utterance.voice = englishVoice;
          }
        }

        // Set speech properties
        // Combo voice sounds use higher volume (25%) for better clarity
        utterance.volume = Math.min(effectsVolume * 2.5, 0.25); // 2.5x effects volume, max 25%
        utterance.rate = 1.1; // Slightly faster for excitement
        utterance.pitch = 1.2; // Higher pitch for female voice
        utterance.lang = 'en-US';

        // Play the voice
        window.speechSynthesis.speak(utterance);

        console.log(`🎤 Combo voice (fallback): "${message}" for combo ${comboCount}`);
      }

      // Load voices when available (some browsers need this)
      if ('speechSynthesis' in window) {
        // Load voices immediately if available
        if (window.speechSynthesis.getVoices().length > 0) {
          console.log('Voices loaded:', window.speechSynthesis.getVoices().length);
        } else {
          // Wait for voices to load
          window.speechSynthesis.onvoiceschanged = () => {
            console.log('Voices loaded:', window.speechSynthesis.getVoices().length);
          };
        }
      }

      // Music control functions
      function startMusic(mode) {
        // Stop any currently playing music
        stopMusic();

        // Start music based on mode
        if (mode === 'classic') {
          currentBgMusic = bgMusicClassic;
        } else if (mode === 'timed') {
          currentBgMusic = bgMusicTimed;
        }

        if (currentBgMusic && currentBgMusic.paused) {
          const playPromise = currentBgMusic.play();
          if (playPromise && typeof playPromise.catch === 'function') {
            playPromise.catch(e => {
              if (e && e.message && typeof e.message === 'string' && e.message.includes('interrupted') && e.message.includes('pause')) return;
              console.warn('Music play failed (if 403: Firebase Storage rules must allow public read):', e.message || e);
            });
          }
          // Enable sound effects when music starts
          soundEffectsEnabled = true;
          updateMusicButtonState();
        }
      }

      // Helper function to pause music and disable sound effects (keeps them in sync)
      function pauseMusicAndEffects() {
        if (currentBgMusic && !currentBgMusic.paused) {
          currentBgMusic.pause();
          soundEffectsEnabled = false;
          updateMusicButtonState();
        }
      }

      function stopMusic() {
        if (currentBgMusic) {
          currentBgMusic.pause();
          currentBgMusic.currentTime = 0;
        }
        // Also stop both musics to be safe
        bgMusicClassic.pause();
        bgMusicClassic.currentTime = 0;
        bgMusicTimed.pause();
        bgMusicTimed.currentTime = 0;

        // Disable sound effects when music stops (keep them in sync)
        soundEffectsEnabled = false;
        updateMusicButtonState();
      }

      /* ==================== END SOUND SYSTEM ==================== */

      // Music button state update function (now controls both music and sound effects)
      function updateMusicButtonState() {
        // Combined state: both music and sound effects should be enabled/disabled together
        const isEnabled = (currentBgMusic && !currentBgMusic.paused) && soundEffectsEnabled;
        const classicBtn = document.getElementById("musicToggleClassicBtn");
        const timedBtn = document.getElementById("musicToggleTimedBtn");

        // Get the music text, fallback to English if L is not yet defined
        const musicText = (typeof L !== 'undefined' && L.music) ? L.music : "🔊 Music";

        // Update icons based on combined state (music + sound effects)
        if (classicBtn) {
          if (isEnabled) {
            classicBtn.innerHTML = musicText;
          } else {
            classicBtn.innerHTML = musicText.replace("🔊", "🔇");
          }
        }

        if (timedBtn) {
          if (isEnabled) {
            timedBtn.innerHTML = musicText;
          } else {
            timedBtn.innerHTML = musicText.replace("🔊", "🔇");
          }
        }
      }

      /* Note: All game state variables are declared at script top */

      // Undo stacks
      // (duplicate declarations removed)
      const undoStackTimed = [];
      // cap for undo credits
      const MAX_UNDO = 25; // <-- max undo credits per mode
      // Undo counts & recharge (start with 3, but never exceed MAX_UNDO)
      let undoCreditsClassic = 3; // Undo credits for classic mode
      let undoCreditsTimed = 3;   // Undo credits for timed mode
      let undoCountClassic = Math.min(3, MAX_UNDO);
      let undoCountTimed = Math.min(3, MAX_UNDO);
      const UNDO_RECHARGE_MS = 15 * 60 * 1000;
      // Note: undoRechargeIntervalClassic and undoRechargeIntervalTimed declared at script top

      function startUndoRecharge(mode) {
        if (mode === "classic") {
          if (undoRechargeIntervalClassic) return;
          undoRechargeIntervalClassic = setInterval(() => {
            if (undoCountClassic < MAX_UNDO) {
              undoCountClassic++;
              updateUndoButtons();
            }
          }, UNDO_RECHARGE_MS);
        } else {
          if (undoRechargeIntervalTimed) return;
          undoRechargeIntervalTimed = setInterval(() => {
            if (undoCountTimed < MAX_UNDO) {
              undoCountTimed++;
              updateUndoButtons();
            }
          }, UNDO_RECHARGE_MS);
        }
      }

      function stopUndoRecharge(mode) {
        if (mode === "classic") {
          if (undoRechargeIntervalClassic) { clearInterval(undoRechargeIntervalClassic); undoRechargeIntervalClassic = null; }
        } else {
          if (undoRechargeIntervalTimed) { clearInterval(undoRechargeIntervalTimed); undoRechargeIntervalTimed = null; }
        }
      }
      // Undo stacks
      const UNDO_LIMIT = 20;
      const undoStackClassic = [];

      function pushUndo(mode) {
        const entry = {};
        if (mode === "classic") {
          entry.score = scoreClassic;
          entry.board = JSON.parse(JSON.stringify(boardClassic));
          entry.currentThree = JSON.parse(JSON.stringify(currentThreeClassic));
          entry.selectedIdx = selectedIdxClassic;
          undoStackClassic.push(entry);
          if (undoStackClassic.length > UNDO_LIMIT) undoStackClassic.shift();
        } else {
          entry.score = scoreTimed;
          entry.board = JSON.parse(JSON.stringify(boardTimed));
          entry.currentThree = JSON.parse(JSON.stringify(currentThreeTimed));
          entry.selectedIdx = selectedIdxTimed;
          entry.timer = timer;
          undoStackTimed.push(entry);
          if (undoStackTimed.length > UNDO_LIMIT) undoStackTimed.shift();
        }
        updateUndoButtons();
      }

      function undoMove(mode) {
        const stack = mode === "classic" ? undoStackClassic : undoStackTimed;
        // nothing to undo or no undo credits
        if (stack.length === 0) return;
        if (mode === "classic" && undoCountClassic <= 0) return;
        if (mode === "timed" && undoCountTimed <= 0) return;
        // consume one undo credit
        if (mode === "classic") undoCountClassic--;
        else undoCountTimed--;
        const s = stack.pop();
        if (mode === "classic") {
          scoreClassic = s.score;
          boardClassic = JSON.parse(JSON.stringify(s.board));
          currentThreeClassic = JSON.parse(JSON.stringify(s.currentThree));
          selectedIdxClassic = s.selectedIdx;
          selectedClassic = selectedIdxClassic != null ? currentThreeClassic[selectedIdxClassic] : null;
          drawGridClassic();
          drawPiecesClassic();
          document.getElementById("scoreClassic").textContent = "Score: " + scoreClassic;
        } else {
          scoreTimed = s.score;
          boardTimed = JSON.parse(JSON.stringify(s.board));
          currentThreeTimed = JSON.parse(JSON.stringify(s.currentThree));
          selectedIdxTimed = s.selectedIdx;
          selectedTimed = selectedIdxTimed != null ? currentThreeTimed[selectedIdxTimed] : null;
          timer = s.timer != null ? s.timer : timer;
          drawGridTimed();
          drawPiecesTimed();
          document.getElementById("scoreTimed").textContent = "Score: " + scoreTimed;
          document.getElementById("timerDisplay").textContent = "Time: " + timer;
        }
        updateUndoButtons();
      }

      function updateUndoButtons() {
        const uc = document.getElementById("undoClassicBtn");
        const ut = document.getElementById("undoTimedBtn");
        // show remaining undo credits and disable when none available or no stack entry
        const label = currentLang === "gu" ? "↶ પાછું લો" : "↶ Undo";
        if (uc) {
          uc.disabled = undoStackClassic.length === 0 || undoCountClassic === 0;
          uc.textContent = label + " (" + undoCountClassic + ")";
        }
        if (ut) {
          ut.disabled = undoStackTimed.length === 0 || undoCountTimed === 0;
          ut.textContent = label + " (" + undoCountTimed + ")";
        }
      }
      /* Home buttons */
      document.getElementById("classicBtn").onclick = async () => {
        // Check for saved classic game state from Firebase
        const savedClassicState = await loadClassicGameState();
        if (savedClassicState) {
          // Restore saved classic game directly to paused state
          console.log("Restoring saved classic game in paused state");
          // Pre-set protection flags ASAP to avoid any race that could show game over
          gameOverGloballyDisabled = true;
          isGameRestoring = true;
          // Proactively hide any lingering game over popup before restoring
          const classicGameOverEl = document.getElementById("gameOverClassic");
          if (classicGameOverEl) classicGameOverEl.style.display = "none";
          restoreClassicGameState(savedClassicState);
          startUndoRecharge("classic");
          return;
        }

        // No saved state, show game screen - use smooth transition
        pushToNavigationStack('classic');

        // Ensure game container is ready before transition
        const classicContainer = document.getElementById('classicContainer');
        if (classicContainer) {
          classicContainer.style.opacity = '0';
          classicContainer.style.visibility = 'hidden';
          classicContainer.style.pointerEvents = 'none';
        }

        transitionToScreen('homeScreen', 'classicContainer');

        // Start session time tracking
        if (!isGameSessionActive) {
          sessionStartTime = Date.now();
          isGameSessionActive = true;
          console.log('Game session started');
        }

        // Start background music for Classic mode
        startMusic('classic');

        if (pausedClassic) {
          // Resume existing paused state
          scoreClassic = pausedClassic.score;
          boardClassic = JSON.parse(JSON.stringify(pausedClassic.board));
          currentThreeClassic = JSON.parse(JSON.stringify(pausedClassic.currentThree));
          selectedIdxClassic = pausedClassic.selectedIdx;

          drawGridClassic();
          drawPiecesClassic();
          document.getElementById("scoreClassic").textContent = "Score: " + scoreClassic;
          // Show pause overlay immediately
          document.getElementById("pauseOverlayClassic").style.display = "block";
          // Pause music when showing pause overlay
          pauseMusicAndEffects();
          if (currentBgMusic && currentBgMusic.paused) {
            console.log("🔇 Music paused - pause overlay shown");
          }
          startUndoRecharge("classic");
        } else {
          // Fresh start - await the animation
          await startClassicGame();
        }
        updateUndoButtons();
      };


      document.getElementById("timedBtn").onclick = async () => {
        // Check for saved timed game state from Firebase
        const savedTimedState = await loadTimedGameState();
        if (savedTimedState) {
          // Restore saved timed game directly to paused state
          console.log("Restoring saved timed game in paused state");
          // Pre-set protection flags ASAP to avoid any race that could show game over
          gameOverGloballyDisabled = true;
          isGameRestoring = true;
          // Proactively hide any lingering game over popup before restoring
          const timedGameOverEl = document.getElementById("gameOverTimed");
          if (timedGameOverEl) timedGameOverEl.style.display = "none";
          restoreTimedGameState(savedTimedState);
          startUndoRecharge("timed");
          return;
        }

        // No saved state, show game screen
        pushToNavigationStack('timed');

        // Ensure game container is ready before transition
        const timedContainer = document.getElementById('timedContainer');
        if (timedContainer) {
          timedContainer.style.opacity = '0';
          timedContainer.style.visibility = 'hidden';
          timedContainer.style.pointerEvents = 'none';
        }

        transitionToScreen('homeScreen', 'timedContainer');

        // Start session time tracking
        if (!isGameSessionActive) {
          sessionStartTime = Date.now();
          isGameSessionActive = true;
          console.log('Game session started');
        }

        // Start background music for Timed mode
        startMusic('timed');

        if (pausedTimed) {
          // Resume existing paused state
          scoreTimed = pausedTimed.score;
          boardTimed = JSON.parse(JSON.stringify(pausedTimed.board));
          currentThreeTimed = JSON.parse(JSON.stringify(pausedTimed.currentThree));
          selectedIdxTimed = pausedTimed.selectedIdx;
          timer = pausedTimed.timer;

          drawGridTimed();
          drawPiecesTimed();
          document.getElementById("scoreTimed").textContent = "Score: " + scoreTimed;
          document.getElementById("timerDisplay").textContent = "Time: " + timer;

          // Show pause overlay immediately - timer will not run until resumed
          document.getElementById("pauseOverlayTimed").style.display = "block";
          // Pause music when showing pause overlay
          if (currentBgMusic && !currentBgMusic.paused) {
            pauseMusicAndEffects();
            if (currentBgMusic && currentBgMusic.paused) {
              console.log("🔇 Music paused - pause overlay shown");
            }
          }
          startUndoRecharge("timed");
        } else {
          // Fresh start - await the animation
          await startTimedGame();
        }
        updateUndoButtons();
      };

      // Sound controls
      document.getElementById("soundBtn").onclick = () => {
        document.getElementById("soundPopup").style.display = "block";
        // Sync sliders and labels with current volumes when opening popup
        try {
          const mv = Math.round((typeof musicVolume === 'number' ? musicVolume : 0.03) * 100);
          const ev = Math.round((typeof effectsVolume === 'number' ? effectsVolume : 0.10) * 100);
          const mvInput = document.getElementById("musicVolume");
          const mvLabel = document.getElementById("musicVolumeValue");
          const evInput = document.getElementById("effectsVolume");
          const evLabel = document.getElementById("effectsVolumeValue");
          if (mvInput) mvInput.value = mv;
          if (mvLabel) mvLabel.textContent = mv + "%";
          if (evInput) evInput.value = ev;
          if (evLabel) evLabel.textContent = ev + "%";
        } catch (e) {
          console.warn("Failed to sync sound sliders:", e);
        }
      };
      document.getElementById("closeSoundPopup").onclick = () => {
        document.getElementById("soundPopup").style.display = "none";
      };

      // Achievement popup handlers
      document.getElementById("closeAchievementPopup").onclick = () => {
        const popup = document.getElementById("achievementPopup");
        popup.style.display = "none";
        popup.classList.add('user-stats-hidden');
        console.log("Achievement popup manually closed");
      };

      // Achievements list button
      document.getElementById("achievementsBtn").onclick = () => {
        showAchievementsList();
      };
      document.getElementById("closeAchievementList").onclick = () => {
        document.getElementById("achievementListModal").style.display = "none";
      };

      // Leaderboard button
      document.getElementById("leaderboardBtn").onclick = () => {
        document.getElementById("leaderboardModal").style.display = "block";
        showLeaderboard('classic');
      };

      // How to Play button
      document.getElementById("howToPlayBtn").onclick = () => {
        showInfoPage('how-to-play.html', 'howToPlayPage', 'howToPlayContent');
      };

      // Privacy Policy button
      document.getElementById("privacyPolicyBtn").onclick = () => {
        showInfoPage('privacy-policy.html', 'privacyPolicyPage', 'privacyPolicyContent');
      };

      // Back buttons
      // Listen for messages from iframe (back button clicks)
      window.addEventListener('message', function (event) {
        if (event.data === 'closeInfoPage') {
          // Determine which info page is currently visible
          const howToPlayPage = document.getElementById('howToPlayPage');
          const privacyPolicyPage = document.getElementById('privacyPolicyPage');

          if (howToPlayPage && !howToPlayPage.classList.contains('user-stats-hidden')) {
            hideInfoPage('howToPlayPage');
          } else if (privacyPolicyPage && !privacyPolicyPage.classList.contains('user-stats-hidden')) {
            hideInfoPage('privacyPolicyPage');
          }
        }
      });

      // Exit confirmation popup handlers
      document.getElementById("exitConfirmYes").onclick = () => {
        hideExitConfirmation();
        // Exit the app - Android will handle this
        if (window.Android && typeof window.Android.exitApp === 'function') {
          window.Android.exitApp();
        } else {
          // Mobile WebView fallback: try to close
          window.close();
        }
      };

      document.getElementById("exitConfirmNo").onclick = () => {
        hideExitConfirmation();
      };

      document.getElementById("closeLeaderboard").onclick = () => {
        document.getElementById("leaderboardModal").style.display = "none";
      };

      let currentLeaderboardMode = 'classic';

      document.getElementById("showClassicLeaderboard").onclick = () => {
        currentLeaderboardMode = 'classic';
        showLeaderboard('classic');
      };
      document.getElementById("showTimedLeaderboard").onclick = () => {
        currentLeaderboardMode = 'timed';
        showLeaderboard('timed');
      };

      // Country filter change event
      document.getElementById("leaderboardCountryFilter").addEventListener("change", () => {
        showLeaderboard(currentLeaderboardMode);
      });

      // Volume sliders
      document.getElementById("musicVolume").addEventListener("input", (e) => {
        musicVolume = e.target.value / 100;
        bgMusicClassic.volume = musicVolume;
        bgMusicTimed.volume = musicVolume;
        document.getElementById("musicVolumeValue").textContent = e.target.value + "%";
      });

      document.getElementById("effectsVolume").addEventListener("input", (e) => {
        effectsVolume = e.target.value / 100;
        document.getElementById("effectsVolumeValue").textContent = e.target.value + "%";
        playSound('place'); // Preview sound
      });


      function updateLanguageUI() {
        const gu = {
          // ...
          undo: "↶ પાછું લો",
          title: '<span class="emoji">🦋</span><span class="text-gradient"> બ્લોક પઝલ </span><span class="emoji">🦋</span><br><span class="emoji">🦋</span><span class="text-gradient">ફ્રી બટરફ્લાઇ </span><span class="emoji">🦋</span>',
          classic: "🎮 ક્લાસિક ગેમ 🎮",
          timed: "⏱️ ટાઈમ ગેમ ⏱️",
          toggle: "🌐 English",
          sound: "🔊 અવાજ",
          music: "🔊 સંગીત",
          achievements: "🏆 સિદ્ધિઓ",
          leaderboard: "📊 લીડરબોર્ડ",
          howToPlay: "📖 કેવી રીતે રમવું",
          privacyPolicy: "🔒 ગોપનીયતા નીતિ",
          score: "સ્કોર: ",
          time: "સમય: ",
          pausedClassic: "⏸️ ક્લાસિક રોકાયું",
          pausedTimed: "⏸️ ટાઈમ રોકાયું",
          overClassic: "❌ ક્લાસિક સમાપ્ત",
          overTimed: "❌ ટાઈમ સમાપ્ત",
          restart: "🔄 ફરી શરૂ કરો",
          home: "🏠 હોમ",
          forgotPassword: "🔑 પાસવર્ડ ભૂલી ગયા?",
          recoverHint: 'જૂના ખેલાડી છો? <strong>Guest ID રિકવર કરો</strong>',
          signup: "✨ એકાઉન્ટ બનાવો",
          login: "🔑 લોગિન",
          adWillShow: "Ad દેખાશે",
        };
        const en = {
          // ...
          undo: "↶ Undo",
          title: '<span class="emoji">🦋</span><span class="text-gradient"> Block Puzzle </span><span class="emoji">🦋</span><br><span class="emoji">🦋</span><span class="text-gradient">Free Butterfly </span><span class="emoji">🦋</span>',
          classic: "🎮 Classic Game 🎮",
          timed: "⏱️ Timed Game ⏱️",
          toggle: "🌐 ગુજરાતી",
          sound: "🔊 Sound",
          music: "🔊 Music",
          achievements: "🏆 Achievements",
          leaderboard: "📊 Leaderboard",
          howToPlay: "📖 How to Play",
          privacyPolicy: "🔒 Privacy Policy",
          score: "Score: ",
          time: "Time: ",
          pausedClassic: "⏸️ Classic Paused",
          pausedTimed: "⏸️ Timed Paused",
          overClassic: "❌ Classic Over",
          overTimed: "❌ Timed Over",
          restart: "🔄 Restart",
          home: "🏠 Home",
          forgotPassword: "🔑 Forgot password?",
          recoverHint: 'Returning player? <strong>Recover Guest ID</strong>',
          signup: "✨ Signup",
          login: "🔑 Login",
          adWillShow: "Ad will show",
        };

        const L = currentLang === "gu" ? gu : en;

        // Home screen
        document.querySelector("#homeScreen h1").innerHTML = L.title;
        updateHomeActionButton("classicBtn", L.classic);
        updateHomeActionButton("timedBtn", L.timed);
        updateHomeActionButton("toggleLangBtn", L.toggle);
        updateHomeActionButton("soundBtn", L.sound);
        updateHomeActionButton("achievementsBtn", L.achievements);
        updateHomeActionButton("leaderboardBtn", L.leaderboard);
        updateHomeActionButton("howToPlayBtn", L.howToPlay || "How to Play");
        updateHomeActionButton("privacyPolicyBtn", L.privacyPolicy || "Privacy Policy");

        // Localize recovery hints (welcome modal + home stats card)
        const hintText = L.recoverHint;
        const hintWelcome = document.getElementById('recoverGuestHint');
        const hintHome = document.getElementById('recoverGuestHintHome');
        if (hintWelcome) hintWelcome.innerHTML = hintText;
        if (hintHome) hintHome.innerHTML = hintText;

        // Classic
        document.getElementById("scoreClassic").textContent = L.score + scoreClassic;
        const ucBtn = document.getElementById("undoClassicBtn");
        if (ucBtn) ucBtn.textContent = L.undo;
        document.querySelector("#pauseOverlayClassic h3").textContent = L.pausedClassic;
        document.querySelector("#gameOverClassic h3").textContent = L.overClassic;
        document.getElementById("restartClassicBtn").textContent = L.restart;
        const pausePopupClassicRestartBtn = document.getElementById("pausePopupClassicRestart");
        if (pausePopupClassicRestartBtn) pausePopupClassicRestartBtn.textContent = L.restart;
        const restartPauseOverlayClassicBtn = document.getElementById("restartPauseOverlayClassicBtn");
        if (restartPauseOverlayClassicBtn) restartPauseOverlayClassicBtn.textContent = L.restart;
        document.getElementById("goHomeClassicBtn").textContent = L.home;
        document.getElementById("goHomeClassicOverBtn").textContent = L.home;

        // Timed
        document.getElementById("scoreTimed").textContent = L.score + scoreTimed;
        const utBtn = document.getElementById("undoTimedBtn");
        if (utBtn) utBtn.textContent = L.undo;
        document.getElementById("timerDisplay").textContent = L.time + timer;
        document.querySelector("#pauseOverlayTimed h3").textContent = L.pausedTimed;
        document.querySelector("#gameOverTimed h3").textContent = L.overTimed;
        document.getElementById("restartTimedBtn").textContent = L.restart;
        const pausePopupTimedRestartBtn = document.getElementById("pausePopupTimedRestart");
        if (pausePopupTimedRestartBtn) pausePopupTimedRestartBtn.textContent = L.restart;
        const restartPauseOverlayTimedBtn = document.getElementById("restartPauseOverlayTimedBtn");
        if (restartPauseOverlayTimedBtn) restartPauseOverlayTimedBtn.textContent = L.restart;
        document.getElementById("goHomeTimedBtn").textContent = L.home;
        document.getElementById("goHomeTimedOverBtn").textContent = L.home;

        if (authForgotPasswordBtn) {
          authForgotPasswordBtn.textContent = L.forgotPassword;
        }

        // Multi-device modal localization
        const multiDeviceTitleEl = document.getElementById('multiDeviceTitle');
        const multiDeviceMessageEl = document.getElementById('multiDeviceMessage');
        const multiDeviceSignupBtn = document.getElementById('multiDeviceSignupBtn');
        const multiDeviceLoginBtn = document.getElementById('multiDeviceLoginBtn');
        const multiDeviceBtn = document.getElementById('multiDeviceBtn');
        const loginBtn = document.getElementById('loginBtn');

        if (multiDeviceTitleEl) multiDeviceTitleEl.textContent = L.multiDeviceTitle;
        if (multiDeviceMessageEl) multiDeviceMessageEl.textContent = L.multiDeviceMessage;
        if (multiDeviceSignupBtn) multiDeviceSignupBtn.textContent = L.signup;
        if (multiDeviceLoginBtn) multiDeviceLoginBtn.textContent = L.login;
        if (loginBtn) loginBtn.textContent = L.login;

        updateHighscoreDisplays();

        // ensure undo buttons show counts with localization
        updateUndoButtons();

        // Update music button states with new language
        updateMusicButtonState();

        // Update interval ad countdown labels
        const countdownLabelClassic = document.getElementById('intervalAdCountdownLabelClassic');
        const countdownLabelTimed = document.getElementById('intervalAdCountdownLabelTimed');
        if (countdownLabelClassic) countdownLabelClassic.textContent = L.adWillShow;
        if (countdownLabelTimed) countdownLabelTimed.textContent = L.adWillShow;

        // Persist language selection
        SafeStorage.setItem('blockPuzzleLang', currentLang);
      }


      /* ===================================================================== */
      /* GAME INITIALIZATION FUNCTIONS                                         */
      /* ===================================================================== */

      /* ----------------------------------------------------------------- */
      /* START CLASSIC GAME - Classic mode initialize અને start કરે      */
      /* Score reset, board clear, random pieces generate, grid draw કરે  */
      /* ----------------------------------------------------------------- */
      /* ========== Classic ========== */
      async function startClassicGame() {
        // ===== FIREBASE TRACKING INITIALIZATION =====
        gameStartTime = Date.now();
        totalLinesClassic = 0;
        totalBlocksPlaced = 0;
        totalLinesEarned = 0; // Reset cumulative achievement tracker for fresh game

        // Start game play timer for Classic mode (only if first time entering)
        startGamePlayTimer('classic');

        // Reset all game flags for fresh start
        resetGameFlags();

        // Clear any saved game state since we're starting fresh
        clearClassicGameState();

        // Hide all overlays
        document.getElementById("pauseOverlayClassic").style.display = "none";
        document.getElementById("gameOverClassic").style.display = "none";
        piecesPlacedClassic = 0;
        hidePausePopup('classic');

        scoreClassic = 0;
        boardClassic = Array(10).fill().map(() => Array(10).fill(null));
        currentThreeClassic = [randomShape(), randomShape(), randomShape()];
        selectedClassic = null; selectedIdxClassic = null;
        pausedClassic = null; // Reset paused state

        document.getElementById("scoreClassic").textContent = "Score: " + scoreClassic;

        // Draw grid first, then play animation
        drawGridClassic();

        // Play board fill animation after grid is drawn
        await playBoardFillAnimation('classic');

        drawPiecesClassic();
        document.getElementById("pauseOverlayClassic").style.display = "none";
        document.getElementById("gameOverClassic").style.display = "none";
        // start undo recharge while playing classic
        startUndoRecharge("classic");
        updateUndoButtons();
        // Update music button state to show correct icon
        updateMusicButtonState();
      }
      function drawGridClassic() {
        const grid = document.getElementById("gridClassic");

        // Safety check - ensure boardClassic is properly initialized
        if (!boardClassic || !Array.isArray(boardClassic) || boardClassic.length !== 10) {
          console.warn("boardClassic not properly initialized, creating empty board");
          boardClassic = Array(10).fill().map(() => Array(10).fill(null));
        }

        // Store existing butterfly shadows before clearing
        const shadowPositions = [];
        grid.querySelectorAll('.butterfly-shadow').forEach(cell => {
          if (!cell.classList.contains('filled')) {
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            shadowPositions.push({ row, col });
          }
        });

        grid.innerHTML = "";
        for (let r = 0; r < 10; r++) {
          for (let c = 0; c < 10; c++) {
            const cell = document.createElement("div");
            cell.className = "cell";
            cell.dataset.row = r;
            cell.dataset.col = c;

            // Safety check for board row
            const boardRow = boardClassic[r];
            const data = boardRow && boardRow[c] ? boardRow[c] : null;

            if (data) {
              cell.style.background = data.color;
              cell.classList.add("filled");
            } else {
              // Clear any inline background style for empty cells
              cell.style.background = "";
              cell.style.removeProperty('background');
              cell.style.removeProperty('background-color');
              // Restore butterfly shadow if this position had one
              const hasShadow = shadowPositions.some(pos => pos.row === r && pos.col === c);
              if (hasShadow) {
                cell.classList.add('butterfly-shadow');
              }
            }

            grid.appendChild(cell);
          }
        }
        // Update blur for invalid pieces
        updateInvalidPiecesClassic();
      }

      function clearPreviewClassic() {
        // Remove glow overlays immediately
        document.querySelectorAll("#gridClassic .line-preview-glow-row, #gridClassic .line-preview-glow-col").forEach(overlay => {
          overlay.remove();
        });

        let needsRedraw = false;

        document.querySelectorAll("#gridClassic .cell").forEach(c => {
          // Check if this cell had preview applied
          const hadPreview = c.classList.contains("preview") || c.classList.contains("line-preview-complete");

          // Remove all preview classes
          c.classList.remove("preview", "preview-invalid", "line-preview-complete");

          // Remove background color only if it's not a filled cell
          if (!c.classList.contains("filled")) {
            c.style.background = "";
            c.style.removeProperty('background');
          } else {
            // For filled cells, remove any inline background override
            if (hadPreview) {
              c.style.removeProperty('background');
              c.style.removeProperty('background-color');
              needsRedraw = true;
            }
          }

          // Remove transitions
          c.style.transition = "";
          c.style.removeProperty('transition');
        });

        // Redraw grid immediately if we modified filled cells
        if (needsRedraw) {
          drawGridClassic();
        }
      }

      function showPreviewClassic(r, c, obj) {
        const shape = obj.shape;
        const color = obj.color;
        const canPlace = canPlaceClassic(r, c, obj);

        // Show the block preview with glow effects
        const blockPreviewCells = [];
        for (let i = 0; i < shape.length; i++) {
          for (let j = 0; j < shape[i].length; j++) {
            if (shape[i][j]) {
              const tr = r + i;
              const tc = c + j;
              if (tr < 10 && tc < 10) {
                const cell = document.querySelector(`#gridClassic .cell[data-row="${tr}"][data-col="${tc}"]`);
                if (cell) {
                  // Always add preview class for glow effect
                  cell.classList.add(canPlace ? "preview" : "preview-invalid");
                  if (canPlace) {
                    // Change color if cell is NOT filled
                    if (!cell.classList.contains("filled")) {
                      cell.style.background = color;
                    }
                    // Ensure CSS box-shadow is not overridden (glow effect)
                    cell.style.boxShadow = "";
                    cell.style.removeProperty('box-shadow');
                    blockPreviewCells.push({ row: tr, col: tc });
                  }
                }
              }
            }
          }
        }

        // NEW: If can place, check if this placement would complete any lines
        if (canPlace) {
          // Simulate placement to check for completed lines
          const rowsToCheck = new Set();
          const colsToCheck = new Set();

          // Collect rows and cols that this block would fill
          for (let i = 0; i < shape.length; i++) {
            for (let j = 0; j < shape[i].length; j++) {
              if (shape[i][j]) {
                rowsToCheck.add(r + i);
                colsToCheck.add(c + j);
              }
            }
          }

          // Check which rows would be complete
          const completedRows = [];
          rowsToCheck.forEach(row => {
            let wouldBeComplete = true;
            for (let col = 0; col < 10; col++) {
              // Check if cell is already filled OR would be filled by this block
              const wouldBeFilled = (r <= row && row < r + shape.length &&
                c <= col && col < c + shape[0].length &&
                shape[row - r] && shape[row - r][col - c]) ||
                boardClassic[row][col] !== null;
              if (!wouldBeFilled) {
                wouldBeComplete = false;
                break;
              }
            }
            if (wouldBeComplete) {
              completedRows.push(row);
            }
          });

          // Check which cols would be complete
          const completedCols = [];
          colsToCheck.forEach(col => {
            let wouldBeComplete = true;
            for (let row = 0; row < 10; row++) {
              // Check if cell is already filled OR would be filled by this block
              const wouldBeFilled = (r <= row && row < r + shape.length &&
                c <= col && col < c + shape[0].length &&
                shape[row - r] && shape[row - r][col - c]) ||
                boardClassic[row][col] !== null;
              if (!wouldBeFilled) {
                wouldBeComplete = false;
                break;
              }
            }
            if (wouldBeComplete) {
              completedCols.push(col);
            }
          });

          // If lines would be completed, show them with block color and border-radius glow around entire line
          if (completedRows.length > 0 || completedCols.length > 0) {
            const grid = document.querySelector("#gridClassic");
            const cells = document.querySelectorAll("#gridClassic .cell");

            // Highlight completed rows - create glow lines in gaps between cells
            completedRows.forEach(row => {
              const rowCells = [];
              for (let col = 0; col < 10; col++) {
                const cellIndex = row * 10 + col;
                const cell = cells[cellIndex];
                if (cell) {
                  cell.classList.add("line-preview-complete");
                  // INSTANT COLOR CHANGE: Change cell color to dragged block color
                  cell.style.background = color;
                  cell.style.backgroundColor = color;
                  cell.style.transition = 'none';
                  rowCells.push(cell);
                }
              }

              // Create glow lines in the gaps between cells (horizontal line)
              if (rowCells.length > 0) {
                const firstCell = rowCells[0];
                const lastCell = rowCells[rowCells.length - 1];
                const firstRect = firstCell.getBoundingClientRect();
                const lastRect = lastCell.getBoundingClientRect();
                const gridRect = grid.getBoundingClientRect();
                const cellSize = firstRect.width;
                const gapSize = 2; // Grid gap is 2px
                const glowThickness = 6; // Glow line thickness is 6px

                const glowColors = ['#ff0080', '#00ff80', '#0080ff', '#ff8000', '#8000ff', '#ffff00'];
                const glowColor1 = glowColors[row % glowColors.length];
                const glowColor2 = glowColors[(row + 1) % glowColors.length];

                // Parse color to RGB for particles
                const hexToRgb = (hex) => {
                  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                  return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                  } : { r: 255, g: 255, b: 255 };
                };
                const particleColor = hexToRgb(glowColor1);
                const particleColorRgba = `rgba(${particleColor.r}, ${particleColor.g}, ${particleColor.b}, 0.8)`;

                // Create horizontal glow line above the row (top gap)
                const topGlowLine = document.createElement('div');
                topGlowLine.className = 'line-preview-glow-row';
                topGlowLine.style.cssText = `
                  position: absolute;
                  left: ${firstRect.left - gridRect.left}px;
                  top: ${firstRect.top - gridRect.top - gapSize - (glowThickness - gapSize) / 2}px;
                  width: ${lastRect.right - firstRect.left}px;
                  height: ${glowThickness}px;
                  background: linear-gradient(90deg, 
                    transparent 0%, 
                    ${particleColorRgba.replace('0.8', '0.3')} 10%,
                    ${particleColorRgba.replace('0.8', '0.8')} 20%,
                    ${particleColorRgba} 30%,
                    ${particleColorRgba} 70%,
                    ${particleColorRgba.replace('0.8', '0.8')} 80%,
                    ${particleColorRgba.replace('0.8', '0.3')} 90%,
                    transparent 100%
                  );
                  box-shadow: 
                    0 0 ${gapSize * 2}px ${glowColor1},
                    0 0 ${gapSize * 4}px ${color},
                    inset 0 0 ${gapSize * 3}px ${particleColorRgba};
                  pointer-events: none;
                  z-index: 3;
                `;
                grid.style.position = 'relative';
                grid.appendChild(topGlowLine);

                // Create horizontal glow line to the left of the row (left gap)
                const leftGlowLine = document.createElement('div');
                leftGlowLine.className = 'line-preview-glow-row';
                leftGlowLine.style.cssText = `
                  position: absolute;
                  left: ${firstRect.left - gridRect.left - gapSize - (glowThickness - gapSize) / 2}px;
                  top: ${firstRect.top - gridRect.top}px;
                  width: ${glowThickness}px;
                  height: ${firstRect.height}px;
                  background: linear-gradient(0deg, 
                    transparent 0%, 
                    ${particleColorRgba.replace('0.8', '0.3')} 10%,
                    ${particleColorRgba.replace('0.8', '0.8')} 20%,
                    ${particleColorRgba} 30%,
                    ${particleColorRgba} 70%,
                    ${particleColorRgba.replace('0.8', '0.8')} 80%,
                    ${particleColorRgba.replace('0.8', '0.3')} 90%,
                    transparent 100%
                  );
                  box-shadow: 
                    0 0 ${gapSize * 2}px ${glowColor1},
                    0 0 ${gapSize * 4}px ${color},
                    inset 0 0 ${gapSize * 3}px ${particleColorRgba};
                  pointer-events: none;
                  z-index: 3;
                `;
                grid.appendChild(leftGlowLine);

                // Create horizontal glow lines between each cell in the row
                for (let i = 0; i < rowCells.length - 1; i++) {
                  const cell1 = rowCells[i];
                  const cell2 = rowCells[i + 1];
                  const cell1Rect = cell1.getBoundingClientRect();

                  const betweenGlowLine = document.createElement('div');
                  betweenGlowLine.className = 'line-preview-glow-row';
                  betweenGlowLine.style.cssText = `
                    position: absolute;
                    left: ${cell1Rect.right - gridRect.left - (glowThickness - gapSize) / 2}px;
                    top: ${firstRect.top - gridRect.top}px;
                    width: ${glowThickness}px;
                    height: ${firstRect.height}px;
                    background: linear-gradient(0deg, 
                      transparent 0%, 
                      ${particleColorRgba.replace('0.8', '0.3')} 10%,
                      ${particleColorRgba.replace('0.8', '0.8')} 20%,
                      ${particleColorRgba} 30%,
                      ${particleColorRgba} 70%,
                      ${particleColorRgba.replace('0.8', '0.8')} 80%,
                      ${particleColorRgba.replace('0.8', '0.3')} 90%,
                      transparent 100%
                    );
                    box-shadow: 
                      0 0 ${gapSize * 2}px ${glowColor1},
                      0 0 ${gapSize * 4}px ${color},
                      inset 0 0 ${gapSize * 3}px ${particleColorRgba};
                    pointer-events: none;
                    z-index: 3;
                  `;
                  grid.appendChild(betweenGlowLine);
                }

                // Create horizontal glow line to the right of the row (right gap)
                const rightGlowLine = document.createElement('div');
                rightGlowLine.className = 'line-preview-glow-row';
                rightGlowLine.style.cssText = `
                  position: absolute;
                  left: ${lastRect.right - gridRect.left + (glowThickness - gapSize) / 2}px;
                  top: ${firstRect.top - gridRect.top}px;
                  width: ${glowThickness}px;
                  height: ${firstRect.height}px;
                  background: linear-gradient(0deg, 
                    transparent 0%, 
                    ${particleColorRgba.replace('0.8', '0.3')} 10%,
                    ${particleColorRgba.replace('0.8', '0.8')} 20%,
                    ${particleColorRgba} 30%,
                    ${particleColorRgba} 70%,
                    ${particleColorRgba.replace('0.8', '0.8')} 80%,
                    ${particleColorRgba.replace('0.8', '0.3')} 90%,
                    transparent 100%
                  );
                  box-shadow: 
                    0 0 ${gapSize * 2}px ${glowColor1},
                    0 0 ${gapSize * 4}px ${color},
                    inset 0 0 ${gapSize * 3}px ${particleColorRgba};
                  pointer-events: none;
                  z-index: 3;
                `;
                grid.appendChild(rightGlowLine);

                // Create horizontal glow line below the row (bottom gap)
                const bottomGlowLine = document.createElement('div');
                bottomGlowLine.className = 'line-preview-glow-row';
                bottomGlowLine.style.cssText = `
                  position: absolute;
                  left: ${firstRect.left - gridRect.left}px;
                  top: ${firstRect.bottom - gridRect.top + (glowThickness - gapSize) / 2}px;
                  width: ${lastRect.right - firstRect.left}px;
                  height: ${glowThickness}px;
                  background: linear-gradient(90deg, 
                    transparent 0%, 
                    ${particleColorRgba.replace('0.8', '0.3')} 10%,
                    ${particleColorRgba.replace('0.8', '0.8')} 20%,
                    ${particleColorRgba} 30%,
                    ${particleColorRgba} 70%,
                    ${particleColorRgba.replace('0.8', '0.8')} 80%,
                    ${particleColorRgba.replace('0.8', '0.3')} 90%,
                    transparent 100%
                  );
                  box-shadow: 
                    0 0 ${gapSize * 2}px ${glowColor1},
                    0 0 ${gapSize * 4}px ${color},
                    inset 0 0 ${gapSize * 3}px ${particleColorRgba};
                  pointer-events: none;
                  z-index: 3;
                `;
                grid.appendChild(bottomGlowLine);

                // NOW change ALL cells to block color (only after glow lines are created)
                rowCells.forEach(cell => {
                  cell.style.setProperty('background', color, 'important');
                  cell.style.setProperty('background-color', color, 'important');
                  cell.style.transition = 'background 0.2s ease-out, background-color 0.2s ease-out';
                });
              }
            });

            // Highlight completed cols - create glow lines in gaps between cells
            completedCols.forEach(col => {
              const colCells = [];
              for (let row = 0; row < 10; row++) {
                if (!completedRows.includes(row)) {
                  const cellIndex = row * 10 + col;
                  const cell = cells[cellIndex];
                  if (cell) {
                    cell.classList.add("line-preview-complete");
                    colCells.push(cell);
                  }
                }
              }

              // Create glow lines in the gaps between cells (vertical line)
              if (colCells.length > 0) {
                const firstCell = colCells[0];
                const lastCell = colCells[colCells.length - 1];
                const firstRect = firstCell.getBoundingClientRect();
                const lastRect = lastCell.getBoundingClientRect();
                const gridRect = grid.getBoundingClientRect();
                const cellSize = firstRect.height;
                const gapSize = 2; // Grid gap is 2px
                const glowThickness = 6; // Glow line thickness is 6px

                const glowColors = ['#ff0080', '#00ff80', '#0080ff', '#ff8000', '#8000ff', '#ffff00'];
                const glowColor1 = glowColors[col % glowColors.length];
                const glowColor2 = glowColors[(col + 1) % glowColors.length];

                // Parse color to RGB for particles
                const hexToRgb = (hex) => {
                  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                  return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                  } : { r: 255, g: 255, b: 255 };
                };
                const particleColor = hexToRgb(glowColor1);
                const particleColorRgba = `rgba(${particleColor.r}, ${particleColor.g}, ${particleColor.b}, 0.8)`;

                // Create vertical glow line above the column (top gap)
                const topGlowLine = document.createElement('div');
                topGlowLine.className = 'line-preview-glow-col';
                topGlowLine.style.cssText = `
                  position: absolute;
                  left: ${firstRect.left - gridRect.left}px;
                  top: ${firstRect.top - gridRect.top - gapSize - (glowThickness - gapSize) / 2}px;
                  width: ${firstRect.width}px;
                  height: ${glowThickness}px;
                  background: linear-gradient(90deg, 
                    transparent 0%, 
                    ${particleColorRgba.replace('0.8', '0.3')} 10%,
                    ${particleColorRgba.replace('0.8', '0.8')} 20%,
                    ${particleColorRgba} 30%,
                    ${particleColorRgba} 70%,
                    ${particleColorRgba.replace('0.8', '0.8')} 80%,
                    ${particleColorRgba.replace('0.8', '0.3')} 90%,
                    transparent 100%
                  );
                  box-shadow: 
                    0 0 ${gapSize * 2}px ${glowColor1},
                    0 0 ${gapSize * 4}px ${color},
                    inset 0 0 ${gapSize * 3}px ${particleColorRgba};
                  pointer-events: none;
                  z-index: 3;
                `;
                grid.style.position = 'relative';
                grid.appendChild(topGlowLine);

                // Create vertical glow line to the left of the column (left gap)
                const leftGlowLine = document.createElement('div');
                leftGlowLine.className = 'line-preview-glow-col';
                leftGlowLine.style.cssText = `
                  position: absolute;
                  left: ${firstRect.left - gridRect.left - gapSize - (glowThickness - gapSize) / 2}px;
                  top: ${firstRect.top - gridRect.top}px;
                  width: ${glowThickness}px;
                  height: ${lastRect.bottom - firstRect.top}px;
                  background: linear-gradient(0deg, 
                    transparent 0%, 
                    ${particleColorRgba.replace('0.8', '0.3')} 10%,
                    ${particleColorRgba.replace('0.8', '0.8')} 20%,
                    ${particleColorRgba} 30%,
                    ${particleColorRgba} 70%,
                    ${particleColorRgba.replace('0.8', '0.8')} 80%,
                    ${particleColorRgba.replace('0.8', '0.3')} 90%,
                    transparent 100%
                  );
                  box-shadow: 
                    0 0 ${gapSize * 2}px ${glowColor1},
                    0 0 ${gapSize * 4}px ${color},
                    inset 0 0 ${gapSize * 3}px ${particleColorRgba};
                  pointer-events: none;
                  z-index: 3;
                `;
                grid.appendChild(leftGlowLine);

                // Create vertical glow lines between each cell in the column
                for (let i = 0; i < colCells.length - 1; i++) {
                  const cell1 = colCells[i];
                  const cell2 = colCells[i + 1];
                  const cell1Rect = cell1.getBoundingClientRect();

                  const betweenGlowLine = document.createElement('div');
                  betweenGlowLine.className = 'line-preview-glow-col';
                  betweenGlowLine.style.cssText = `
                    position: absolute;
                    left: ${firstRect.left - gridRect.left}px;
                    top: ${cell1Rect.bottom - gridRect.top - (glowThickness - gapSize) / 2}px;
                    width: ${firstRect.width}px;
                    height: ${glowThickness}px;
                    background: linear-gradient(90deg, 
                      transparent 0%, 
                      ${particleColorRgba.replace('0.8', '0.3')} 10%,
                      ${particleColorRgba.replace('0.8', '0.8')} 20%,
                      ${particleColorRgba} 30%,
                      ${particleColorRgba} 70%,
                      ${particleColorRgba.replace('0.8', '0.8')} 80%,
                      ${particleColorRgba.replace('0.8', '0.3')} 90%,
                      transparent 100%
                    );
                    box-shadow: 
                      0 0 ${gapSize * 2}px ${glowColor1},
                      0 0 ${gapSize * 4}px ${color},
                      inset 0 0 ${gapSize * 3}px ${particleColorRgba};
                    pointer-events: none;
                    z-index: 3;
                  `;
                  grid.appendChild(betweenGlowLine);
                }

                // Create vertical glow line to the right of the column (right gap)
                const rightGlowLine = document.createElement('div');
                rightGlowLine.className = 'line-preview-glow-col';
                rightGlowLine.style.cssText = `
                  position: absolute;
                  left: ${firstRect.right - gridRect.left + (glowThickness - gapSize) / 2}px;
                  top: ${firstRect.top - gridRect.top}px;
                  width: ${glowThickness}px;
                  height: ${lastRect.bottom - firstRect.top}px;
                  background: linear-gradient(0deg, 
                    transparent 0%, 
                    ${particleColorRgba.replace('0.8', '0.3')} 10%,
                    ${particleColorRgba.replace('0.8', '0.8')} 20%,
                    ${particleColorRgba} 30%,
                    ${particleColorRgba} 70%,
                    ${particleColorRgba.replace('0.8', '0.8')} 80%,
                    ${particleColorRgba.replace('0.8', '0.3')} 90%,
                    transparent 100%
                  );
                  box-shadow: 
                    0 0 ${gapSize * 2}px ${glowColor1},
                    0 0 ${gapSize * 4}px ${color},
                    inset 0 0 ${gapSize * 3}px ${particleColorRgba};
                  pointer-events: none;
                  z-index: 3;
                `;
                grid.appendChild(rightGlowLine);

                // Create vertical glow line below the column (bottom gap)
                const bottomGlowLine = document.createElement('div');
                bottomGlowLine.className = 'line-preview-glow-col';
                bottomGlowLine.style.cssText = `
                  position: absolute;
                  left: ${firstRect.left - gridRect.left}px;
                  top: ${lastRect.bottom - gridRect.top + (glowThickness - gapSize) / 2}px;
                  width: ${firstRect.width}px;
                  height: ${glowThickness}px;
                  background: linear-gradient(90deg, 
                    transparent 0%, 
                    ${particleColorRgba.replace('0.8', '0.3')} 10%,
                    ${particleColorRgba.replace('0.8', '0.8')} 20%,
                    ${particleColorRgba} 30%,
                    ${particleColorRgba} 70%,
                    ${particleColorRgba.replace('0.8', '0.8')} 80%,
                    ${particleColorRgba.replace('0.8', '0.3')} 90%,
                    transparent 100%
                  );
                  box-shadow: 
                    0 0 ${gapSize * 2}px ${glowColor1},
                    0 0 ${gapSize * 4}px ${color},
                    inset 0 0 ${gapSize * 3}px ${particleColorRgba};
                  pointer-events: none;
                  z-index: 3;
                `;
                grid.appendChild(bottomGlowLine);

                // NOW change ALL cells to block color (only after glow lines are created)
                colCells.forEach(cell => {
                  cell.style.setProperty('background', color, 'important');
                  cell.style.setProperty('background-color', color, 'important');
                  cell.style.transition = 'background 0.2s ease-out, background-color 0.2s ease-out';
                });
              }
            });
          }
        }
      }

      function updateInvalidPiecesClassic() {
        document.querySelectorAll("#piecesClassic .piece").forEach((piece, idx) => {
          const obj = currentThreeClassic[idx];
          if (!obj) return;
          let canPlaceAnywhere = false;

          // Check placement without pause check (for visual feedback only)
          for (let r = 0; r < 10 && !canPlaceAnywhere; r++) {
            for (let c = 0; c < 10 && !canPlaceAnywhere; c++) {
              // Direct board check without pause validation
              const shape = obj.shape;
              const rows = shape.length;
              const cols = shape[0].length;
              if (r >= 0 && c >= 0 && r + rows <= 10 && c + cols <= 10) {
                let canPlace = true;
                for (let i = 0; i < rows && canPlace; i++) {
                  for (let j = 0; j < cols && canPlace; j++) {
                    if (shape[i][j] && boardClassic[r + i][c + j]) {
                      canPlace = false;
                    }
                  }
                }
                if (canPlace) canPlaceAnywhere = true;
              }
            }
          }

          if (canPlaceAnywhere) {
            piece.classList.remove("invalid");
          } else {
            piece.classList.add("invalid");
          }
        });
      }
      function drawPiecesClassic() {
        const wrap = document.getElementById("piecesClassic");
        console.log("🎨 drawPiecesClassic called - Container:", wrap);
        console.log("🎨 Current pieces:", currentThreeClassic);
        wrap.innerHTML = "";
        currentThreeClassic.forEach((obj, idx) => {
          console.log(`🎨 Drawing piece ${idx}:`, obj);
          const piece = document.createElement("div");
          piece.className = "piece";

          // Create inner container for the actual shape
          const pieceInner = document.createElement("div");
          pieceInner.className = "piece-inner";
          const rows = obj.shape.length, cols = obj.shape[0].length;
          pieceInner.style.gridTemplateColumns = `repeat(${cols}, var(--piece-block-size) )`;
          pieceInner.style.gridTemplateRows = `repeat(${rows}, var(--piece-block-size) )`;

          obj.shape.flat().forEach(val => {
            const b = document.createElement("div");
            if (val) {
              b.className = "block";
              b.style.backgroundColor = obj.color;  // Use backgroundColor to preserve gradient overlay
            }
            else { b.style.background = "transparent"; }
            pieceInner.appendChild(b);
          });

          piece.appendChild(pieceInner);

          // Drag functionality - single piece moves with cursor
          let isDragging = false;
          let dragMoveHandler, dragEndHandler;
          let rafId = null; // For requestAnimationFrame throttling
          let originalParent = null; // Store original parent for placeholder removal

          const startDrag = (e) => {
            e.preventDefault();

            // Check if game is paused - don't allow dragging
            if (isManuallyPaused) {
              console.log("⏸️ Game is paused - drag blocked");
              return;
            }

            // Also check if pause overlay is visible
            const pauseOverlay = document.getElementById("pauseOverlayClassic");
            if (pauseOverlay && pauseOverlay.style.display !== "none") {
              console.log("⏸️ Pause overlay visible - drag blocked");
              return;
            }

            isDragging = true;
            selectedClassic = obj;
            selectedIdxClassic = idx;

            // Play drag sound
            playSound('drag');

            // Mark piece as dragging and hide original position
            document.querySelectorAll("#piecesClassic .piece").forEach(p => {
              p.classList.remove("selected", "dragging");
            });
            piece.classList.add("dragging");

            // Store original parent for later restoration
            originalParent = piece.parentElement;

            // Create invisible placeholder to maintain space (prevents duplicate appearance)
            const placeholder = document.createElement('div');
            placeholder.className = 'drag-placeholder';
            placeholder.style.width = piece.offsetWidth + 'px';
            placeholder.style.height = piece.offsetHeight + 'px';
            placeholder.style.visibility = 'hidden';
            placeholder.style.pointerEvents = 'none';
            placeholder.style.display = 'inline-block';

            // CRITICAL: Move piece to body FIRST (this removes it from original parent)
            // Insert placeholder before removing piece
            originalParent.insertBefore(placeholder, piece);
            document.body.appendChild(piece);

            // Now piece is in body, set pointer events
            piece.style.pointerEvents = 'none';

            // Update piece-inner grid to use grid cell size
            const pieceInnerElem = piece.querySelector('.piece-inner');
            const rows = obj.shape.length;
            const cols = obj.shape[0].length;
            pieceInnerElem.style.gridTemplateColumns = `repeat(${cols}, var(--cell-size))`;
            pieceInnerElem.style.gridTemplateRows = `repeat(${rows}, var(--cell-size))`;

            // Use CSS transform for better mobile performance and stability
            piece.style.position = 'fixed';
            piece.style.willChange = 'transform';
            piece.style.left = '0';
            piece.style.top = '0';
            piece.style.margin = '0';

            // Get piece dimensions after resizing
            const rect = piece.getBoundingClientRect();
            const offsetX = rect.width / 2;

            // Offset: 125px above finger to prevent finger from covering block
            const verticalOffset = -125;

            // Position piece above cursor using transform for smooth, stable movement
            const x = e.clientX || (e.touches && e.touches[0].clientX);
            const y = e.clientY || (e.touches && e.touches[0].clientY);
            piece.style.transform = `translate3d(${x - offsetX}px, ${y + verticalOffset}px, 0)`;

            // Add move and end handlers
            dragMoveHandler = (e) => moveDrag(e, offsetX, verticalOffset);
            dragEndHandler = (e) => endDrag(e, verticalOffset);

            document.addEventListener("mousemove", dragMoveHandler);
            document.addEventListener("mouseup", dragEndHandler);
            document.addEventListener("touchmove", dragMoveHandler, { passive: false });
            document.addEventListener("touchend", dragEndHandler);
          };

          // Cache for performance optimization
          let cachedGridRect = null;
          let cachedCellSize = null;
          let lastPreviewRow = -1;
          let lastPreviewCol = -1;
          let lastPreviewUpdate = 0;
          const PREVIEW_THROTTLE = deviceInfo.isLowRefreshRate ? 32 : 16; // 32ms for 60Hz, 16ms for 120Hz

          const moveDrag = (e, offsetX, verticalOffset) => {
            if (!isDragging || !selectedClassic) return;

            e.preventDefault();

            const x = e.clientX || (e.touches && e.touches[0].clientX);
            const y = e.clientY || (e.touches && e.touches[0].clientY);

            // OPTIMIZATION: Use 2D transforms for Android 13 and below (faster on 60Hz devices)
            if (deviceInfo.use2DTransforms) {
              piece.style.transform = `translate(${x - offsetX}px, ${y + verticalOffset}px)`;
            } else {
              piece.style.transform = `translate3d(${x - offsetX}px, ${y + verticalOffset}px, 0)`;
            }

            // NO PREVIEW - Dragged piece itself is the preview (prevents duplicate blocks)
            // This eliminates z-index conflicts and stuck blocks
          };

          const endDrag = (e, verticalOffset) => {
            isDragging = false;

            // Check if game is paused - don't allow piece placement
            if (isManuallyPaused) {
              console.log("⏸️ Game is paused - piece placement blocked");
              // Reset piece position
              piece.classList.remove("dragging");
              piece.style.position = "";
              piece.style.left = "";
              piece.style.top = "";
              piece.style.willChange = 'auto';
              return;
            }

            // Remove CSS optimization hints
            piece.style.willChange = 'auto';

            const x = e.clientX || e.changedTouches?.[0]?.clientX;
            const y = e.clientY || e.changedTouches?.[0]?.clientY;

            let piecePlaced = false;

            // Check if dropped on grid and place the piece
            if (x && y) {
              const gridElem = document.getElementById("gridClassic");
              const gridRect = gridElem.getBoundingClientRect();

              // Use piece's center position for placement calculation (same as preview)
              const pieceRect = piece.getBoundingClientRect();
              const pieceCenterX = pieceRect.left + pieceRect.width / 2;
              const pieceCenterY = pieceRect.top + pieceRect.height / 2;

              if (pieceCenterX >= gridRect.left && pieceCenterX <= gridRect.right &&
                pieceCenterY >= gridRect.top && pieceCenterY <= gridRect.bottom) {
                const cellSize = gridRect.width / 10;
                const rows = selectedClassic.shape.length;
                const cols = selectedClassic.shape[0].length;

                // Use exact center calculation for precise placement
                const centerOffsetRow = rows / 2;
                const centerOffsetCol = cols / 2;

                // Round to nearest cell for exact center placement
                const col = Math.round((pieceCenterX - gridRect.left) / cellSize - centerOffsetCol);
                const row = Math.round((pieceCenterY - gridRect.top) / cellSize - centerOffsetRow);

                if (canPlaceClassic(row, col, selectedClassic)) {
                  // INSTANT PLACEMENT - All critical operations synchronously
                  pushUndo("classic");

                  // Record user activity for timer
                  recordUserActivity('classic');

                  // Apply piece to board immediately
                  applyClassic(row, col, selectedClassic);

                  // Update score instantly
                  let filledCells = 0;
                  for (let i = 0; i < selectedClassic.shape.length; i++) {
                    for (let j = 0; j < selectedClassic.shape[i].length; j++) {
                      if (selectedClassic.shape[i][j]) filledCells++;
                    }
                  }
                  scoreClassic += filledCells * 10;
                  document.getElementById("scoreClassic").textContent = "Score: " + scoreClassic;

                  // Check and clear lines BEFORE drawing (prevents duplicate blocks)
                  checkAndClearClassic();

                  // Draw grid immediately (after line clear)
                  drawGridClassic();

                  // CRITICAL: Remove placeholder BEFORE generating new piece
                  const placeholder = originalParent.querySelector('.drag-placeholder');
                  if (placeholder) {
                    placeholder.remove();
                  }

                  // Generate new piece immediately
                  currentThreeClassic[selectedIdxClassic] = randomShape();
                  selectedClassic = null;
                  selectedIdxClassic = null;
                  drawPiecesClassic();
                  updateInvalidPiecesClassic();

                  piecePlaced = true;

                  // Check if no moves available after piece placement
                  if (checkNoMovesClassic()) {
                    console.log("No moves available - triggering game over");
                    setTimeout(() => {
                      handleNoMovesClassic();
                    }, 100); // Small delay to ensure UI is updated
                  }

                  // Save game state IMMEDIATELY to localStorage (synchronous)
                  saveClassicGameState();

                  // Non-critical operations run async (no blocking)
                  setTimeout(() => {
                    showPointsPopup('#gridClassic', filledCells * 10);
                    playSound('place');
                    checkRealtimeAchievements('classic');
                    // Also save to general game state key for compatibility
                    saveGameState();
                  }, 0);
                } else {
                  // If placement failed, still remove placeholder
                  const placeholder = originalParent.querySelector('.drag-placeholder');
                  if (placeholder) {
                    placeholder.remove();
                  }
                }
              }
            }

            // Reset piece position and remove dragging class
            piece.classList.remove("dragging");
            piece.style.position = "";
            piece.style.left = "";
            piece.style.top = "";
            piece.style.transform = "";
            piece.style.willChange = 'auto';
            piece.style.display = "";
            piece.style.opacity = "";
            piece.style.pointerEvents = "";

            // Clear cached values
            cachedGridRect = null;
            cachedCellSize = null;
            lastPreviewRow = -1;
            lastPreviewCol = -1;

            // Only move piece back if it wasn't placed
            if (!piecePlaced) {
              // Reset piece-inner grid template back to original size
              const pieceInnerElem = piece.querySelector('.piece-inner');
              if (pieceInnerElem && selectedClassic) {
                const rows = selectedClassic.shape.length;
                const cols = selectedClassic.shape[0].length;
                pieceInnerElem.style.gridTemplateColumns = `repeat(${cols}, var(--piece-block-size))`;
                pieceInnerElem.style.gridTemplateRows = `repeat(${rows}, var(--piece-block-size))`;
              }
              wrap.appendChild(piece);
            } else {
              // Remove the piece element if it was placed
              piece.remove();
            }

            // Remove event listeners
            document.removeEventListener("mousemove", dragMoveHandler);
            document.removeEventListener("mouseup", dragEndHandler);
            document.removeEventListener("touchmove", dragMoveHandler, { passive: false });
            document.removeEventListener("touchend", dragEndHandler);
          };

          // Mouse events
          piece.onmousedown = startDrag;

          // Touch events - Android 13 compatible (only one handler to prevent duplicate)
          piece.addEventListener('touchstart', (e) => {
            e.preventDefault();
            e.stopPropagation();
            startDrag(e);
          }, { passive: false, capture: true });

          wrap.appendChild(piece);
        });
        updateInvalidPiecesClassic();
      }

      function canPlaceClassic(r, c, obj) {
        // Check if game is paused - don't allow placement

        if (isManuallyPaused) {
          console.log("⏸️ Game is paused - placement blocked in canPlaceClassic");
          return false;
        }

        // Also check if pause overlay is visible
        const pauseOverlay = document.getElementById("pauseOverlayClassic");
        if (pauseOverlay && pauseOverlay.style.display !== "none") {
          console.log("⏸️ Pause overlay visible - placement blocked");
          return false;
        }

        const shape = obj.shape; const rows = shape.length; const cols = shape[0].length;
        if (r < 0 || c < 0 || r + rows > 10 || c + cols > 10) return false;
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < cols; j++) {
            if (shape[i][j] && boardClassic[r + i][c + j]) return false;
          }
        }
        return true;
      }
      function applyClassic(r, c, obj) {
        const { shape, color } = obj;
        lastPlacedColorClassic = color; // Track last placed color for clearing animation

        // Apply block to board
        for (let i = 0; i < shape.length; i++) {
          for (let j = 0; j < shape[i].length; j++) {
            if (shape[i][j]) boardClassic[r + i][c + j] = { color };
          }
        }
      }
      function checkNoMovesClassic() {
        // If game is manually paused, being restored, or just drawing, don't check for game over
        if (isManuallyPaused || isGameRestoring || isDrawingOnly || gameOverGloballyDisabled) {
          console.log("Skipping game over check - manuallyPaused:", isManuallyPaused, "restoring:", isGameRestoring, "drawingOnly:", isDrawingOnly, "globallyDisabled:", gameOverGloballyDisabled);
          return false;
        }

        console.log("Checking for available moves in Classic mode...");
        for (const obj of currentThreeClassic) {
          for (let r = 0; r < 10; r++) {
            for (let c = 0; c < 10; c++) {
              if (canPlaceClassic(r, c, obj)) {
                console.log("Found valid move for Classic piece");
                return false;
              }
            }
          }
        }
        console.log("❌ No moves available in Classic mode!");
        return true;
      }
      function showPointsPopup(gridSelector, points) {
        const grid = document.querySelector(gridSelector);
        const rect = grid.getBoundingClientRect();

        const popup = document.createElement('div');
        popup.className = 'points-popup';
        popup.textContent = '+' + points;
        popup.style.left = (rect.left + rect.width / 2) + 'px';
        popup.style.top = (rect.top + rect.height / 2) + 'px';

        // Different colors based on point amount
        if (points <= 50) {
          popup.style.color = '#10b981'; // Green for cell placement
          popup.style.textShadow = '0 0 10px rgba(16, 185, 129, 0.8), 0 0 20px rgba(16, 185, 129, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.5)';
        } else if (points <= 100) {
          popup.style.color = '#fbbf24'; // Gold for lines
          popup.style.textShadow = '0 0 10px rgba(251, 191, 36, 0.8), 0 0 20px rgba(251, 191, 36, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.5)';
        } else {
          popup.style.color = '#f59e0b'; // Orange for big combos
          popup.style.textShadow = '0 0 10px rgba(245, 158, 11, 0.8), 0 0 20px rgba(245, 158, 11, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.5)';
        }

        document.body.appendChild(popup);

        setTimeout(() => {
          popup.remove();
        }, 1000); // Match 1.0s animation
      }

      // Calculate combo points based on combo count
      function calculateComboPoints(comboCount) {
        if (comboCount <= 0) return 0;

        const comboPointsMap = {
          1: 100,
          2: 200,
          3: 300,
          4: 400,
          5: 500,
          6: 600,
          7: 700,
          8: 800,
          9: 900,
          10: 1000,
          11: 1100,
          12: 1200,
          13: 1300,
          14: 1400
        };

        if (comboCount <= 14) {
          return comboPointsMap[comboCount];
        } else {
          // combo 15+ = 1500 + (combo - 15) * 500
          return 1500 + (comboCount - 15) * 100;
        }
      }

      function showComboPopup(mode, comboCount, comboPoints) {
        console.log(`🔥 COMBO POPUP - Mode: ${mode}, Count: ${comboCount}, Points: ${comboPoints}`);
        const grid = mode === 'classic' ? document.getElementById('gridClassic') : document.getElementById('gridTimed');
        const rect = grid.getBoundingClientRect();

        const popup = document.createElement('div');
        popup.className = 'points-popup'; // Use same class as points popup
        popup.textContent = comboCount === 1 ? `COMBO!\n+${comboPoints}` : `COMBO ${comboCount}!\n+${comboPoints}`;
        // Position at left side top corner of board
        popup.style.left = (rect.left + 20) + 'px';
        popup.style.top = (rect.top + 20) + 'px';
        // Smaller font size
        popup.style.fontSize = '2.2rem';
        // Make it more visible with background
        popup.style.background = 'rgba(0, 0, 0, 0.6)';
        popup.style.padding = '8px 16px';
        popup.style.borderRadius = '12px';
        popup.style.border = '2px solid rgba(255, 255, 255, 0.8)';
        popup.style.whiteSpace = 'pre-line';
        popup.style.textAlign = 'center';
        popup.style.lineHeight = '1.2';

        // Rainbow colors for higher combos
        const comboColors = [
          '#ec4899', // Pink
          '#f59e0b', // Orange
          '#10b981', // Green
          '#3b82f6', // Blue
          '#8b5cf6', // Purple
          '#ef4444', // Red
          '#14b8a6'  // Teal
        ];
        const colorIndex = (comboCount - 1) % comboColors.length;
        const color = comboColors[colorIndex];

        // Set color and text shadow - reduced intensity to prevent screen flashing
        popup.style.color = color;
        const r = parseInt(color.slice(1, 3), 16);
        const g = parseInt(color.slice(3, 5), 16);
        const b = parseInt(color.slice(5, 7), 16);
        popup.style.textShadow = `
          0 0 15px rgba(${r}, ${g}, ${b}, 0.8),
          0 0 30px rgba(${r}, ${g}, ${b}, 0.6),
          0 0 45px rgba(${r}, ${g}, ${b}, 0.4),
          2px 2px 4px rgba(0, 0, 0, 0.8)
        `;
        popup.style.boxShadow = `
          0 0 15px rgba(${r}, ${g}, ${b}, 0.6),
          0 0 30px rgba(${r}, ${g}, ${b}, 0.4),
          0 4px 16px rgba(0, 0, 0, 0.4)
        `;

        console.log(`🔥 Combo popup created:`, popup.textContent, color);
        // Smooth animation to prevent screen flashing
        popup.style.animation = 'popupFloat 1s ease-out forwards';
        popup.style.willChange = 'transform, opacity, filter';
        popup.style.backfaceVisibility = 'hidden';
        popup.style.transform = 'translateZ(0)'; // Force hardware acceleration
        document.body.appendChild(popup);

        setTimeout(() => {
          if (popup.parentNode) {
            popup.style.opacity = '0';
            popup.style.transition = 'opacity 0.2s ease-out';
            setTimeout(() => {
              if (popup.parentNode) popup.remove();
            }, 200);
          }
        }, 1000); // Remove after animation completes
      }

      function checkAndClearClassic() {
        // Determine which rows and cols are full first (do not mutate board while checking)
        const rowsToClear = [];
        const colsToClear = [];

        for (let r = 0; r < 10; r++) {
          if (boardClassic[r].every(x => x !== null)) rowsToClear.push(r);
        }

        for (let c = 0; c < 10; c++) {
          let full = true;
          for (let r = 0; r < 10; r++) {
            if (boardClassic[r][c] === null) { full = false; break; }
          }
          if (full) colsToClear.push(c);
        }

        // If nothing to clear, exit
        if (rowsToClear.length === 0 && colsToClear.length === 0) {
          return;
        }

        // Collect cells to animate butterflies BEFORE clearing
        const cellsToAnimate = [];
        rowsToClear.forEach(r => {
          for (let c = 0; c < 10; c++) {
            cellsToAnimate.push({ row: r, col: c, type: 'row' });
          }
        });
        colsToClear.forEach(c => {
          for (let r = 0; r < 10; r++) {
            if (!rowsToClear.includes(r)) {
              cellsToAnimate.push({ row: r, col: c, type: 'col' });
            }
          }
        });

        // GLOW EFFECT AND COLOR CHANGE: Show glow and change color BEFORE clearing
        const grid = document.getElementById('gridClassic');
        const boardFrame = grid.parentElement; // Get boardFrame parent to append glow lines
        const cells = document.querySelectorAll("#gridClassic .cell");
        const color = lastPlacedColorClassic || '#ff0080'; // Use last placed color or default

        // Helper function to convert hex to RGB
        const hexToRgb = (hex) => {
          const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
          return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
          } : { r: 255, g: 255, b: 255 };
        };

        const gapSize = 2; // Grid gap is 2px
        const glowThickness = 6; // Glow line thickness is 6px
        const gridRect = grid.getBoundingClientRect();
        const boardFrameRect = boardFrame.getBoundingClientRect();

        // Highlight completed rows with glow and color change
        rowsToClear.forEach(row => {
          const rowCells = [];
          for (let col = 0; col < 10; col++) {
            const cellIndex = row * 10 + col;
            const cell = cells[cellIndex];
            if (cell) {
              cell.classList.add("line-preview-complete");
              // INSTANT COLOR CHANGE: Change cell color to last placed color
              cell.style.background = color;
              cell.style.backgroundColor = color;
              cell.style.transition = 'none';
              rowCells.push(cell);
            }
          }

          // Create glow lines around the row
          if (rowCells.length > 0) {
            const firstCell = rowCells[0];
            const lastCell = rowCells[rowCells.length - 1];
            const firstRect = firstCell.getBoundingClientRect();
            const lastRect = lastCell.getBoundingClientRect();

            const glowColors = ['#ff0080', '#00ff80', '#0080ff', '#ff8000', '#8000ff', '#ffff00'];
            const glowColor1 = glowColors[row % glowColors.length];
            const particleColor = hexToRgb(glowColor1);
            const particleColorRgba = `rgba(${particleColor.r}, ${particleColor.g}, ${particleColor.b}, 0.8)`;

            // Create horizontal glow line above the row (append to boardFrame to survive grid.innerHTML = "")
            const topGlowLine = document.createElement('div');
            topGlowLine.className = 'line-preview-glow-row';
            topGlowLine.style.cssText = `
              position: absolute;
              left: ${firstRect.left - boardFrameRect.left}px;
              top: ${firstRect.top - boardFrameRect.top - gapSize - (glowThickness - gapSize) / 2}px;
              width: ${lastRect.right - firstRect.left}px;
              height: ${glowThickness}px;
              background: linear-gradient(90deg, 
                transparent 0%, 
                ${particleColorRgba.replace('0.8', '0.3')} 10%,
                ${particleColorRgba.replace('0.8', '0.8')} 20%,
                ${particleColorRgba} 30%,
                ${particleColorRgba} 70%,
                ${particleColorRgba.replace('0.8', '0.8')} 80%,
                ${particleColorRgba.replace('0.8', '0.3')} 90%,
                transparent 100%
              );
              box-shadow: 
                0 0 ${gapSize * 2}px ${glowColor1},
                0 0 ${gapSize * 4}px ${color},
                inset 0 0 ${gapSize * 3}px ${particleColorRgba};
              pointer-events: none;
              z-index: 3;
            `;
            boardFrame.style.position = 'relative';
            boardFrame.appendChild(topGlowLine);

            // Auto-remove glow line after animation
            setTimeout(() => {
              if (topGlowLine.parentNode) {
                topGlowLine.remove();
              }
            }, 300);

            // Create horizontal glow line below the row
            const bottomGlowLine = document.createElement('div');
            bottomGlowLine.className = 'line-preview-glow-row';
            bottomGlowLine.style.cssText = `
              position: absolute;
              left: ${firstRect.left - boardFrameRect.left}px;
              top: ${firstRect.bottom - boardFrameRect.top + (glowThickness - gapSize) / 2}px;
              width: ${lastRect.right - firstRect.left}px;
              height: ${glowThickness}px;
              background: linear-gradient(90deg, 
                transparent 0%, 
                ${particleColorRgba.replace('0.8', '0.3')} 10%,
                ${particleColorRgba.replace('0.8', '0.8')} 20%,
                ${particleColorRgba} 30%,
                ${particleColorRgba} 70%,
                ${particleColorRgba.replace('0.8', '0.8')} 80%,
                ${particleColorRgba.replace('0.8', '0.3')} 90%,
                transparent 100%
              );
              box-shadow: 
                0 0 ${gapSize * 2}px ${glowColor1},
                0 0 ${gapSize * 4}px ${color},
                inset 0 0 ${gapSize * 3}px ${particleColorRgba};
              pointer-events: none;
              z-index: 3;
            `;
            boardFrame.appendChild(bottomGlowLine);

            // Auto-remove glow line after animation
            setTimeout(() => {
              if (bottomGlowLine.parentNode) {
                bottomGlowLine.remove();
              }
            }, 300);
          }
        });

        // Highlight completed cols with glow and color change
        colsToClear.forEach(col => {
          const colCells = [];
          for (let row = 0; row < 10; row++) {
            if (!rowsToClear.includes(row)) {
              const cellIndex = row * 10 + col;
              const cell = cells[cellIndex];
              if (cell) {
                cell.classList.add("line-preview-complete");
                // INSTANT COLOR CHANGE: Change cell color to last placed color
                cell.style.background = color;
                cell.style.backgroundColor = color;
                cell.style.transition = 'none';
                colCells.push(cell);
              }
            }
          }

          // Create glow lines around the column
          if (colCells.length > 0) {
            const firstCell = colCells[0];
            const lastCell = colCells[colCells.length - 1];
            const firstRect = firstCell.getBoundingClientRect();
            const lastRect = lastCell.getBoundingClientRect();

            const glowColors = ['#ff0080', '#00ff80', '#0080ff', '#ff8000', '#8000ff', '#ffff00'];
            const glowColor1 = glowColors[col % glowColors.length];
            const particleColor = hexToRgb(glowColor1);
            const particleColorRgba = `rgba(${particleColor.r}, ${particleColor.g}, ${particleColor.b}, 0.8)`;

            // Create vertical glow line to the left of the column (append to boardFrame)
            const leftGlowLine = document.createElement('div');
            leftGlowLine.className = 'line-preview-glow-col';
            leftGlowLine.style.cssText = `
              position: absolute;
              left: ${firstRect.left - boardFrameRect.left - gapSize - (glowThickness - gapSize) / 2}px;
              top: ${firstRect.top - boardFrameRect.top}px;
              width: ${glowThickness}px;
              height: ${lastRect.bottom - firstRect.top}px;
              background: linear-gradient(0deg, 
                transparent 0%, 
                ${particleColorRgba.replace('0.8', '0.3')} 10%,
                ${particleColorRgba.replace('0.8', '0.8')} 20%,
                ${particleColorRgba} 30%,
                ${particleColorRgba} 70%,
                ${particleColorRgba.replace('0.8', '0.8')} 80%,
                ${particleColorRgba.replace('0.8', '0.3')} 90%,
                transparent 100%
              );
              box-shadow: 
                0 0 ${gapSize * 2}px ${glowColor1},
                0 0 ${gapSize * 4}px ${color},
                inset 0 0 ${gapSize * 3}px ${particleColorRgba};
              pointer-events: none;
              z-index: 3;
            `;
            boardFrame.appendChild(leftGlowLine);

            // Auto-remove glow line after animation
            setTimeout(() => {
              if (leftGlowLine.parentNode) {
                leftGlowLine.remove();
              }
            }, 300);

            // Create vertical glow line to the right of the column
            const rightGlowLine = document.createElement('div');
            rightGlowLine.className = 'line-preview-glow-col';
            rightGlowLine.style.cssText = `
              position: absolute;
              left: ${lastRect.right - boardFrameRect.left + (glowThickness - gapSize) / 2}px;
              top: ${firstRect.top - boardFrameRect.top}px;
              width: ${glowThickness}px;
              height: ${lastRect.bottom - firstRect.top}px;
              background: linear-gradient(0deg, 
                transparent 0%, 
                ${particleColorRgba.replace('0.8', '0.3')} 10%,
                ${particleColorRgba.replace('0.8', '0.8')} 20%,
                ${particleColorRgba} 30%,
                ${particleColorRgba} 70%,
                ${particleColorRgba.replace('0.8', '0.8')} 80%,
                ${particleColorRgba.replace('0.8', '0.3')} 90%,
                transparent 100%
              );
              box-shadow: 
                0 0 ${gapSize * 2}px ${glowColor1},
                0 0 ${gapSize * 4}px ${color},
                inset 0 0 ${gapSize * 3}px ${particleColorRgba};
              pointer-events: none;
              z-index: 3;
            `;
            boardFrame.appendChild(rightGlowLine);

            // Auto-remove glow line after animation
            setTimeout(() => {
              if (rightGlowLine.parentNode) {
                rightGlowLine.remove();
              }
            }, 300);
          }
        });

        // Simply clear the board cells - no animations or effects
        rowsToClear.forEach(r => {
          for (let c = 0; c < 10; c++) {
            boardClassic[r][c] = null;
          }
        });

        colsToClear.forEach(c => {
          for (let r = 0; r < 10; r++) {
            if (!rowsToClear.includes(r)) {
              boardClassic[r][c] = null;
            }
          }
        });

        // DON'T redraw here - will be drawn after this function returns
        // drawGridClassic(); // REMOVED - causes duplicate blocks

        // Create butterfly animations in background (non-blocking)
        if (cellsToAnimate.length > 0) {
          const grid = document.getElementById('gridClassic');
          const gridRect = grid.getBoundingClientRect();
          const cellSize = gridRect.width / 10;

          // Animation directions: up, down, left, right, diagonal
          const directions = ['up', 'down', 'left', 'right', 'diagonal'];

          // 10 different hue-rotate values for butterflies (to change actual color)
          const butterflyHues = [
            0,      // Original (pink/red)
            60,     // Yellow
            120,    // Green
            180,    // Cyan
            240,    // Blue
            300,    // Magenta
            30,     // Orange
            150,    // Light Green
            270,    // Purple
            90      // Yellow-Green
          ];

          cellsToAnimate.forEach((cell, index) => {
            const cellElement = grid.querySelector(`.cell[data-row="${cell.row}"][data-col="${cell.col}"]`);
            if (!cellElement) return;

            const cellRect = cellElement.getBoundingClientRect();
            const direction = directions[index % directions.length];
            const hue = butterflyHues[index % butterflyHues.length];

            // Create butterfly overlay
            const butterfly = document.createElement('div');
            butterfly.textContent = '🦋';
            butterfly.style.cssText = `
              position: fixed;
              left: ${cellRect.left + cellRect.width / 2}px;
              top: ${cellRect.top + cellRect.height / 2}px;
              font-size: 1.5rem;
              pointer-events: none;
              z-index: 1000;
              transform: translate(-50%, -50%);
              filter: hue-rotate(${hue}deg) saturate(1.2) brightness(1.1);
            `;

            // Set animation based on direction
            let animationName = 'butterflyFlyUp';
            if (direction === 'down') animationName = 'butterflyFlyDown';
            else if (direction === 'left') animationName = 'butterflyFlyLeft';
            else if (direction === 'right') animationName = 'butterflyFlyRight';
            else if (direction === 'diagonal') animationName = 'butterflyFlyDiagonal';

            butterfly.style.animation = `${animationName} 2s ease-out forwards`;
            document.body.appendChild(butterfly);

            // Remove butterfly after animation
            setTimeout(() => {
              if (butterfly.parentNode) {
                butterfly.remove();
              }
            }, 2000);
          });
        }

        const horizontalLines = rowsToClear.length;
        const verticalLines = colsToClear.length;
        const totalLines = horizontalLines + verticalLines;
        let linePoints = 0;

        // Play line clear sound based on total lines
        if (totalLines > 0) {
          playSound('clear' + Math.min(totalLines, 6));

          // Check for combo (consecutive clears within time window)
          const now = Date.now();
          const timeSinceLastClear = now - lastClearTimeClassic;
          console.log(`⏱️ Time since last clear: ${timeSinceLastClear}ms (window: ${COMBO_TIME_WINDOW}ms)`);

          if (timeSinceLastClear <= COMBO_TIME_WINDOW && timeSinceLastClear > 0) {
            comboCountClassic++;
            console.log(`🎯 COMBO DETECTED! Count: ${comboCountClassic}`);

            // Calculate and add combo points
            const comboPoints = calculateComboPoints(comboCountClassic);
            scoreClassic += comboPoints;
            document.getElementById("scoreClassic").textContent = "Score: " + scoreClassic;

            showComboPopup('classic', comboCountClassic, comboPoints);

            // Play combo voice sound for specific combo counts
            playComboVoice(comboCountClassic);
          } else {
            console.log(`❌ No combo - resetting counter`);
            comboCountClassic = 0; // Reset combo
          }
          lastClearTimeClassic = now;

          // Also check for multi-line combo (4+ lines at once)
          if (totalLines >= 4) {
            console.log(`🌟 MULTI-LINE COMBO! ${totalLines} lines cleared`);
          }
        }

        // Award points for horizontal lines (if any)
        if (horizontalLines === 1) {
          linePoints += 10;
        } else if (horizontalLines === 2) {
          linePoints += 30;
        } else if (horizontalLines === 3) {
          linePoints += 50;
        } else if (horizontalLines === 4) {
          linePoints += 70;
        } else if (horizontalLines === 5) {
          linePoints += 100;
        } else if (horizontalLines >= 6) {
          linePoints += 150;
        }

        // Award points for vertical lines (if any)
        if (verticalLines === 1) {
          linePoints += 10;
        } else if (verticalLines === 2) {
          linePoints += 30;
        } else if (verticalLines === 3) {
          linePoints += 50;
        } else if (verticalLines === 4) {
          linePoints += 70;
        } else if (verticalLines === 5) {
          linePoints += 100;
        } else if (verticalLines >= 6) {
          linePoints += 150;
        }

        // Extra cross bonus if both horizontal AND vertical lines cleared
        if (horizontalLines > 0 && verticalLines > 0) {
          const totalLines = horizontalLines + verticalLines;
          if (totalLines === 2) {
            linePoints += 20;  // 1H + 1V
          } else if (totalLines === 3) {
            linePoints += 40;  // 2H + 1V or 1H + 2V
          } else if (totalLines === 4) {
            linePoints += 80;  // 2H + 2V or 3H + 1V or 1H + 3V
          } else if (totalLines === 5) {
            linePoints += 160; // Various combinations
          } else if (totalLines >= 6) {
            linePoints += 320; // 3H + 3V or more
          }
        }

        // Show points popup
        showPointsPopup('#gridClassic', linePoints);

        // Update total lines counters for achievement tracking (horizontal + vertical)
        const linesClearedClassic = horizontalLines + verticalLines;
        if (linesClearedClassic > 0) {
          totalLinesClassic += linesClearedClassic;
        }

        scoreClassic += linePoints;

        // Check for real-time achievements after line clear
        checkRealtimeAchievements('classic');
      }

      document.getElementById("pauseClassicBtn").onclick = () => {
        // Pause game play timer when pausing game
        pauseGamePlayTimer('classic');
        isManuallyPaused = true; // Set flag for manual pause
        pausedClassic = {
          score: scoreClassic,
          board: JSON.parse(JSON.stringify(boardClassic)),
          currentThree: JSON.parse(JSON.stringify(currentThreeClassic)),
          selectedIdx: selectedIdxClassic,
          timer: null // Classic માં timer નથી
        };
        // stop recharge while paused
        stopUndoRecharge("classic");
        // Pause music when game is paused
        if (currentBgMusic && !currentBgMusic.paused) {
          currentBgMusic.pause();
          updateMusicButtonState();
        }
        document.getElementById("pauseOverlayClassic").style.display = "block";
        showPausePopup('classic');
      };
      // undo button handlers & keyboard shortcut
      document.getElementById("undoClassicBtn").onclick = () => undoMove("classic");
      document.getElementById("undoTimedBtn").onclick = () => undoMove("timed");
      document.addEventListener("keydown", (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "z") {
          if (document.getElementById("classicContainer").style.display === "flex") undoMove("classic");
          else if (document.getElementById("timedContainer").style.display === "flex") undoMove("timed");
        }
      });
      document.getElementById("resumeClassicBtn").onclick = () => {
        isManuallyPaused = false; // Reset flag when resuming
        clearManualPauseStatus(); // Clear saved status when resuming
        document.getElementById("pauseOverlayClassic").style.display = "none";
        hidePausePopup('classic'); // Hide the small popup too

        // Resume game play timer when resuming game
        resumeGamePlayTimer('classic');

        // Re-enable game over immediately when resuming
        gameOverGloballyDisabled = false;
        console.log("✅ Game over ENABLED after Classic resume");

        // resume recharge
        startUndoRecharge("classic");

        // Update music button state
        updateMusicButtonState();
      };

      // Restart button for pause overlay Classic
      const restartPauseOverlayClassicBtn = document.getElementById("restartPauseOverlayClassicBtn");
      if (restartPauseOverlayClassicBtn) {
        restartPauseOverlayClassicBtn.onclick = async (e) => {
          e.preventDefault();
          // Hide the pause overlay
          document.getElementById("pauseOverlayClassic").style.display = "none";
          hidePausePopup('classic');
          // Reset pause flags
          isManuallyPaused = false;
          clearManualPauseStatus();
          // Start a new classic game
          await startClassicGame();
        };
      }

      // Support Resume from the small pause-popup for Classic
      const pausePopupClassicResumeBtn = document.getElementById("pausePopupClassicResume");
      if (pausePopupClassicResumeBtn) {
        pausePopupClassicResumeBtn.onclick = (e) => {
          e.preventDefault();
          // Trigger the main resume handler
          const resumeBtn = document.getElementById("resumeClassicBtn");
          if (resumeBtn) resumeBtn.click();
        };
      }

      // Support Restart from the small pause-popup for Classic
      const pausePopupClassicRestartBtn = document.getElementById("pausePopupClassicRestart");
      if (pausePopupClassicRestartBtn) {
        pausePopupClassicRestartBtn.onclick = async (e) => {
          e.preventDefault();
          // Hide the pause popup
          hidePausePopup('classic');
          // Start a new classic game
          await startClassicGame();
        };
      }

      // Music toggle button for Classic mode (now controls both music and sound effects)
      document.getElementById("musicToggleClassicBtn").onclick = () => {
        try {
          if (currentBgMusic) {
            if (currentBgMusic.paused) {
              // Enable both music and sound effects
              currentBgMusic.play().catch(e => {
                if (e && e.message && typeof e.message === 'string' && e.message.includes('interrupted') && e.message.includes('pause')) return;
                console.warn('Music play failed (if 403: Firebase Storage rules must allow public read):', e.message || e);
              });
              soundEffectsEnabled = true;
            } else {
              // Disable both music and sound effects
              currentBgMusic.pause();
              soundEffectsEnabled = false;
            }
            updateMusicButtonState();
          } else {
            // If no music is loaded, just toggle sound effects
            soundEffectsEnabled = !soundEffectsEnabled;
            updateMusicButtonState();
          }
        } catch (error) {
          console.error("Error in music toggle:", error);
        }
      };

      document.getElementById("goHomeClassicBtn").onclick = async () => {
        // Show loading when returning to home
        showLoadingPopup('Saving game...');

        // Pause game play timer when leaving game
        pauseGamePlayTimer('classic');

        // Auto-pause current game before leaving
        autoPauseCurrentGame();

        // Disable achievement tracking when leaving game
        isGameActive = false;

        // End game session and save total time
        endGameSession();

        // stop recharge when leaving to home (credits remain)
        stopUndoRecharge("classic");
        stopMusic();

        // Save user data if logged in
        if (currentFirebaseUser && isUserDataLoaded) {
          try {
            showLoadingPopup('Syncing data...');
            await saveUserDataToFirebase(currentFirebaseUser.uid);
          } catch (error) {
            console.error('Error saving data on home:', error);
          }
        }

        // Hide loading
        hideLoadingPopup();

        popFromNavigationStack();
        transitionToScreen('classicContainer', 'homeScreen');
        hidePausePopup('classic');

        // ===== UPDATE UI WHEN RETURNING TO HOME =====
        updateUIWithUserData();
        console.log("UI updated when returning to home from classic");
      };
      document.getElementById("restartClassicBtn").onclick = async () => {
        await startClassicGame();
      };
      document.getElementById("goHomeClassicOverBtn").onclick = () => {
        // Pause game play timer when leaving game
        pauseGamePlayTimer('classic');

        // Clear game state since game is over
        clearGameState();

        // Disable achievement tracking when leaving game
        isGameActive = false;

        // Reset legitimate game over flag
        isLegitimateGameOver = false;

        // End game session and save total time
        endGameSession();

        stopMusic();
        document.getElementById("gameOverClassic").style.display = "none";
        transitionToScreen('classicContainer', 'homeScreen');
        hidePausePopup('classic');

        // ===== UPDATE UI WHEN RETURNING TO HOME =====
        updateUIWithUserData();
        console.log("UI updated when returning to home from classic game over");
      };

      /* Game Over Classic */
      async function handleNoMovesClassic() {
        console.log("=== handleNoMovesClassic called ===");
        hidePausePopup('classic');

        // NUCLEAR OPTION: If game over is globally disabled, block immediately
        if (gameOverGloballyDisabled) {
          console.log("🚫 Game over GLOBALLY DISABLED - blocking Classic game over");
          return;
        }

        console.log("isManuallyPaused:", isManuallyPaused);
        console.log("isGameRestoring:", isGameRestoring);
        console.log("isDrawingOnly:", isDrawingOnly);
        console.log("pausedClassic exists:", !!pausedClassic);
        console.log("Stack trace:", new Error().stack);

        // If game was manually paused, don't show game over - just return
        if (isManuallyPaused) {
          console.log("Game manually paused - skipping game over for Classic");
          return;
        }

        // If game is being restored, don't show game over
        if (isGameRestoring) {
          console.log("Game restoring - skipping game over for Classic");
          return;
        }

        // If we're just drawing pieces, don't show game over
        if (isDrawingOnly) {
          console.log("Drawing only - skipping game over for Classic");
          return;
        }

        // Reset all blocking flags before showing game over
        isManuallyPaused = false;
        isGameRestoring = false;
        isDrawingOnly = false;
        gameOverGloballyDisabled = false;
        isLegitimateGameOver = true; // Mark as legitimate game over

        // Play board clear animation before showing game over
        await playBoardClearAnimation('classic');

        // FORCE HIDE pause overlay before showing game over
        document.getElementById("pauseOverlayClassic").style.display = "none";

        // Clear CLASSIC game state since game is over
        clearClassicGameState();

        // Clear paused state BEFORE showing game over
        pausedClassic = null;

        // Disable achievement tracking as game is over
        isGameActive = false;

        // Pause music when game over popup is shown
        pauseMusicAndEffects();
        if (currentBgMusic && currentBgMusic.paused) {
          console.log("🔇 Music paused - game over popup shown");
        }

        playSound('gameover');
        const highscore = updateHighscore("classic", scoreClassic);
        document.getElementById("finalScoreClassic").textContent = "Final Score: " + scoreClassic;

        // stop recharge when game over
        stopUndoRecharge("classic");

        // Pause game play timer when game over
        pauseGamePlayTimer('classic');

        showGameOverPopup('classic');
      }

      // Function to show game over popup
      function showGameOverPopup(mode) {
        if (mode === 'classic') {
          console.log("✅ Showing Classic game over popup");
          document.getElementById("gameOverClassic").style.display = "block";

          // ===== FIREBASE DATA SYNC =====
          // Save game result to Firebase/Local Storage
          const gameResult = {
            mode: 'classic',
            score: scoreClassic,
            lines: totalLinesClassic || 0,
            duration: Math.floor((Date.now() - gameStartTime) / 1000) || 0,
            level: 1, // Classic mode doesn't have levels
            blocks: totalBlocksPlaced || 0,
            timestamp: new Date().toISOString()
          };

          // Update user stats and check achievements
          updateGameStats(gameResult);
        } else if (mode === 'timed') {
          console.log("✅ Showing Timed game over popup");
          document.getElementById("gameOverTimed").style.display = "block";

          // ===== FIREBASE DATA SYNC =====
          // Save game result to Firebase/Local Storage
          const gameResult = {
            mode: 'timed',
            score: scoreTimed,
            lines: totalLinesTimed || 0,
            duration: 180 - timer, // Time played (3 minutes - remaining time)
            level: currentLevelTimed || 1,
            blocks: totalBlocksPlacedTimed || 0,
            extraTime: extraTimeEarnedInGame || 0, // Include extra time earned
            timestamp: new Date().toISOString()
          };

          // Update user stats and check achievements
          updateGameStats(gameResult);
        }
      }

      /* ========== Timed ========== */
      function placeBonusCells() {
        // Find empty cells
        const emptyCells = [];
        for (let r = 0; r < 10; r++) {
          for (let c = 0; c < 10; c++) {
            if (boardTimed[r][c] === null) {
              emptyCells.push({ r, c });
            }
          }
        }

        // If less than 3 empty cells, don't place bonus
        if (emptyCells.length < 3) return;

        // Randomly select 3 cells
        const bonusCells = [];
        for (let i = 0; i < 3; i++) {
          const randomIndex = Math.floor(Math.random() * emptyCells.length);
          bonusCells.push(emptyCells[randomIndex]);
          emptyCells.splice(randomIndex, 1); // Remove selected cell
        }

        // Place bonus cells with random bonus time (10-60 seconds)
        bonusCells.forEach(({ r, c }) => {
          const bonusSeconds = Math.floor(Math.random() * 51) + 10; // 10 to 60
          boardTimed[r][c] = {
            color: '#fbbf24', // Gold color for bonus
            isBonus: true,
            bonusSeconds: bonusSeconds
          };
        });

        drawGridTimed();
      }

      async function startTimedGame() {
        // ===== FIREBASE TRACKING INITIALIZATION =====
        gameStartTime = Date.now();
        totalLinesTimed = 0;
        totalBlocksPlacedTimed = 0;
        currentLevelTimed = 1;
        extraTimeEarnedInGame = 0; // Reset extra time tracking
        totalLinesEarned = 0; // Reset cumulative achievement tracker for fresh game
        totalExtraTimeEarned = 0; // Reset extra time achievement tracker for fresh game

        // Start game play timer for Timed mode (only if first time entering)
        startGamePlayTimer('timed');

        // Reset all game flags for fresh start
        resetGameFlags();

        // Clear any saved game state since we're starting fresh
        clearTimedGameState();

        // Hide all overlays
        document.getElementById("pauseOverlayTimed").style.display = "none";
        document.getElementById("gameOverTimed").style.display = "none";
        hidePausePopup('timed');

        // Clear any saved game state since we're starting fresh
        clearGameState();

        scoreTimed = 0; timer = 300;
        boardTimed = Array(10).fill().map(() => Array(10).fill(null));
        currentThreeTimed = [randomShape(), randomShape(), randomShape()];
        selectedTimed = null; selectedIdxTimed = null;
        pausedTimed = null; // Reset paused state

        document.getElementById("scoreTimed").textContent = "Score: " + scoreTimed;
        document.getElementById("timerDisplay").textContent = "Time: " + timer;

        // Draw grid first, then play animation
        drawGridTimed();

        // Play board fill animation after grid is drawn
        await playBoardFillAnimation('timed');

        drawPiecesTimed();
        document.getElementById("pauseOverlayTimed").style.display = "none";
        document.getElementById("gameOverTimed").style.display = "none";
        clearInterval(timerInterval);
        clearInterval(bonusCellInterval);

        // start undo recharge while playing timed
        startUndoRecharge("timed");

        // Update music button state to show correct icon
        updateMusicButtonState();

        // Timer countdown
        timerInterval = setInterval(() => {
          timer--;
          document.getElementById("timerDisplay").textContent = "Time: " + timer;

          if (timer <= 0) {
            clearInterval(timerInterval);
            clearInterval(bonusCellInterval);
            // Only call game over if game is not manually paused or being restored
            if (!isManuallyPaused && !isGameRestoring) {
              handleNoMovesTimed();
            } else {
              console.log("Timer expired but game is paused/restoring - not triggering game over");
            }
          }
        }, 1000);

        // Bonus cells every 60 seconds
        bonusCellInterval = setInterval(() => {
          placeBonusCells();
        }, 60000); // 60,000 ms = 60 seconds
      }
      function drawGridTimed() {
        const grid = document.getElementById("gridTimed");

        // Safety check - ensure boardTimed is properly initialized
        if (!boardTimed || !Array.isArray(boardTimed) || boardTimed.length !== 10) {
          console.warn("boardTimed not properly initialized, creating empty board");
          boardTimed = Array(10).fill().map(() => Array(10).fill(null));
        }

        // Store existing butterfly shadows before clearing
        const shadowPositions = [];
        grid.querySelectorAll('.butterfly-shadow').forEach(cell => {
          if (!cell.classList.contains('filled')) {
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            shadowPositions.push({ row, col });
          }
        });

        grid.innerHTML = "";
        for (let r = 0; r < 10; r++) {
          for (let c = 0; c < 10; c++) {
            const cell = document.createElement("div");
            cell.className = "cell";
            cell.dataset.row = r;
            cell.dataset.col = c;

            // Safety check for board row
            const boardRow = boardTimed[r];
            const data = boardRow && boardRow[c] ? boardRow[c] : null;

            if (data) {
              cell.style.background = data.color;
              cell.classList.add("filled");

              // Display bonus timer if it's a bonus cell
              if (data.isBonus && data.bonusSeconds) {
                const timerText = document.createElement("div");
                timerText.textContent = `+${data.bonusSeconds}s`;
                timerText.style.cssText = `
                  position: absolute;
                  top: 50%;
                  left: 50%;
                  transform: translate(-50%, -50%);
                  font-size: 0.65rem;
                  font-weight: bold;
                  color: #1f2937;
                  text-shadow: 0 1px 3px rgba(255,255,255,0.8);
                  pointer-events: none;
                  z-index: 10;
                `;
                cell.style.position = "relative";
                cell.appendChild(timerText);
              }
            } else {
              // Clear any inline background style for empty cells
              cell.style.background = "";
              cell.style.removeProperty('background');
              cell.style.removeProperty('background-color');
              // Restore butterfly shadow if this position had one
              const hasShadow = shadowPositions.some(pos => pos.row === r && pos.col === c);
              if (hasShadow) {
                cell.classList.add('butterfly-shadow');
              }
            }

            grid.appendChild(cell);
          }
        }
        updateInvalidPiecesTimed();
      }

      function clearPreviewTimed() {
        // Remove glow overlays immediately
        document.querySelectorAll("#gridTimed .line-preview-glow-row, #gridTimed .line-preview-glow-col").forEach(overlay => {
          overlay.remove();
        });

        let needsRedraw = false;

        document.querySelectorAll("#gridTimed .cell").forEach(c => {
          // Check if this cell had preview applied
          const hadPreview = c.classList.contains("preview") || c.classList.contains("line-preview-complete");

          // Remove all preview classes
          c.classList.remove("preview", "preview-invalid", "line-preview-complete");

          // Remove background color only if it's not a filled cell
          if (!c.classList.contains("filled")) {
            c.style.background = "";
            c.style.removeProperty('background');
          } else {
            // For filled cells, remove any inline background override
            if (hadPreview) {
              c.style.removeProperty('background');
              c.style.removeProperty('background-color');
              needsRedraw = true;
            }
          }

          // Remove transitions
          c.style.transition = "";
          c.style.removeProperty('transition');
        });

        // Redraw grid immediately if we modified filled cells
        if (needsRedraw) {
          drawGridTimed();
        }
      }

      function showPreviewTimed(r, c, obj) {
        const shape = obj.shape;
        const color = obj.color;
        const canPlace = canPlaceTimed(r, c, obj);

        // First, show the block preview (simple preview without glow)
        const blockPreviewCells = [];
        for (let i = 0; i < shape.length; i++) {
          for (let j = 0; j < shape[i].length; j++) {
            if (shape[i][j]) {
              const tr = r + i;
              const tc = c + j;
              if (tr < 10 && tc < 10) {
                const cell = document.querySelector(`#gridTimed .cell[data-row="${tr}"][data-col="${tc}"]`);
                if (cell) {
                  cell.classList.add(canPlace ? "preview" : "preview-invalid");
                  if (canPlace) {
                    // Simple preview - only change color if cell is NOT filled
                    if (!cell.classList.contains("filled")) {
                      cell.style.background = color;
                    }
                    // Don't change filled cells' colors - they keep their original color
                    // Keep CSS box-shadow for glow effect (don't override with inline style)
                    blockPreviewCells.push({ row: tr, col: tc });
                  }
                }
              }
            }
          }
        }

        // NEW: If can place, check if this placement would complete any lines
        if (canPlace) {
          // Simulate placement to check for completed lines
          const rowsToCheck = new Set();
          const colsToCheck = new Set();

          // Collect rows and cols that this block would fill
          for (let i = 0; i < shape.length; i++) {
            for (let j = 0; j < shape[i].length; j++) {
              if (shape[i][j]) {
                rowsToCheck.add(r + i);
                colsToCheck.add(c + j);
              }
            }
          }

          // Check which rows would be complete
          const completedRows = [];
          rowsToCheck.forEach(row => {
            let wouldBeComplete = true;
            for (let col = 0; col < 10; col++) {
              // Check if cell is already filled OR would be filled by this block
              const wouldBeFilled = (r <= row && row < r + shape.length &&
                c <= col && col < c + shape[0].length &&
                shape[row - r] && shape[row - r][col - c]) ||
                boardTimed[row][col] !== null;
              if (!wouldBeFilled) {
                wouldBeComplete = false;
                break;
              }
            }
            if (wouldBeComplete) {
              completedRows.push(row);
            }
          });

          // Check which cols would be complete
          const completedCols = [];
          colsToCheck.forEach(col => {
            let wouldBeComplete = true;
            for (let row = 0; row < 10; row++) {
              // Check if cell is already filled OR would be filled by this block
              const wouldBeFilled = (r <= row && row < r + shape.length &&
                c <= col && col < c + shape[0].length &&
                shape[row - r] && shape[row - r][col - c]) ||
                boardTimed[row][col] !== null;
              if (!wouldBeFilled) {
                wouldBeComplete = false;
                break;
              }
            }
            if (wouldBeComplete) {
              completedCols.push(col);
            }
          });

          // If lines would be completed, show them with block color and border-radius glow around entire line
          if (completedRows.length > 0 || completedCols.length > 0) {
            const grid = document.querySelector("#gridTimed");
            const cells = document.querySelectorAll("#gridTimed .cell");

            // Highlight completed rows - create glow lines in gaps between cells
            completedRows.forEach(row => {
              const rowCells = [];
              for (let col = 0; col < 10; col++) {
                const cellIndex = row * 10 + col;
                const cell = cells[cellIndex];
                if (cell) {
                  cell.classList.add("line-preview-complete");
                  rowCells.push(cell);
                }
              }

              // Create glow lines in the gaps between cells (horizontal line)
              if (rowCells.length > 0) {
                const firstCell = rowCells[0];
                const lastCell = rowCells[rowCells.length - 1];
                const firstRect = firstCell.getBoundingClientRect();
                const lastRect = lastCell.getBoundingClientRect();
                const gridRect = grid.getBoundingClientRect();
                const cellSize = firstRect.width;
                const gapSize = 2; // Grid gap is 2px
                const glowThickness = 6; // Glow line thickness is 6px

                const glowColors = ['#ff0080', '#00ff80', '#0080ff', '#ff8000', '#8000ff', '#ffff00'];
                const glowColor1 = glowColors[row % glowColors.length];
                const glowColor2 = glowColors[(row + 1) % glowColors.length];

                // Parse color to RGB for particles
                const hexToRgb = (hex) => {
                  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                  return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                  } : { r: 255, g: 255, b: 255 };
                };
                const particleColor = hexToRgb(glowColor1);
                const particleColorRgba = `rgba(${particleColor.r}, ${particleColor.g}, ${particleColor.b}, 0.8)`;

                // Create horizontal glow line above the row (top gap)
                const topGlowLine = document.createElement('div');
                topGlowLine.className = 'line-preview-glow-row';
                topGlowLine.style.cssText = `
                  position: absolute;
                  left: ${firstRect.left - gridRect.left}px;
                  top: ${firstRect.top - gridRect.top - gapSize - (glowThickness - gapSize) / 2}px;
                  width: ${lastRect.right - firstRect.left}px;
                  height: ${glowThickness}px;
                  background: linear-gradient(90deg, 
                    transparent 0%, 
                    ${particleColorRgba.replace('0.8', '0.3')} 10%,
                    ${particleColorRgba.replace('0.8', '0.8')} 20%,
                    ${particleColorRgba} 30%,
                    ${particleColorRgba} 70%,
                    ${particleColorRgba.replace('0.8', '0.8')} 80%,
                    ${particleColorRgba.replace('0.8', '0.3')} 90%,
                    transparent 100%
                  );
                  box-shadow: 
                    0 0 ${gapSize * 2}px ${glowColor1},
                    0 0 ${gapSize * 4}px ${color},
                    inset 0 0 ${gapSize * 3}px ${particleColorRgba};
                  pointer-events: none;
                  z-index: 3;
                `;
                grid.style.position = 'relative';
                grid.appendChild(topGlowLine);

                // Create horizontal glow line to the left of the row (left gap)
                const leftGlowLine = document.createElement('div');
                leftGlowLine.className = 'line-preview-glow-row';
                leftGlowLine.style.cssText = `
                  position: absolute;
                  left: ${firstRect.left - gridRect.left - gapSize - (glowThickness - gapSize) / 2}px;
                  top: ${firstRect.top - gridRect.top}px;
                  width: ${glowThickness}px;
                  height: ${firstRect.height}px;
                  background: linear-gradient(0deg, 
                    transparent 0%, 
                    ${particleColorRgba.replace('0.8', '0.3')} 10%,
                    ${particleColorRgba.replace('0.8', '0.8')} 20%,
                    ${particleColorRgba} 30%,
                    ${particleColorRgba} 70%,
                    ${particleColorRgba.replace('0.8', '0.8')} 80%,
                    ${particleColorRgba.replace('0.8', '0.3')} 90%,
                    transparent 100%
                  );
                  box-shadow: 
                    0 0 ${gapSize * 2}px ${glowColor1},
                    0 0 ${gapSize * 4}px ${color},
                    inset 0 0 ${gapSize * 3}px ${particleColorRgba};
                  pointer-events: none;
                  z-index: 3;
                `;
                grid.appendChild(leftGlowLine);

                // Create horizontal glow lines between each cell in the row
                for (let i = 0; i < rowCells.length - 1; i++) {
                  const cell1 = rowCells[i];
                  const cell2 = rowCells[i + 1];
                  const cell1Rect = cell1.getBoundingClientRect();

                  const betweenGlowLine = document.createElement('div');
                  betweenGlowLine.className = 'line-preview-glow-row';
                  betweenGlowLine.style.cssText = `
                    position: absolute;
                    left: ${cell1Rect.right - gridRect.left - (glowThickness - gapSize) / 2}px;
                    top: ${firstRect.top - gridRect.top}px;
                    width: ${glowThickness}px;
                    height: ${firstRect.height}px;
                    background: linear-gradient(0deg, 
                      transparent 0%, 
                      ${particleColorRgba.replace('0.8', '0.3')} 10%,
                      ${particleColorRgba.replace('0.8', '0.8')} 20%,
                      ${particleColorRgba} 30%,
                      ${particleColorRgba} 70%,
                      ${particleColorRgba.replace('0.8', '0.8')} 80%,
                      ${particleColorRgba.replace('0.8', '0.3')} 90%,
                      transparent 100%
                    );
                    box-shadow: 
                      0 0 ${gapSize * 2}px ${glowColor1},
                      0 0 ${gapSize * 4}px ${color},
                      inset 0 0 ${gapSize * 3}px ${particleColorRgba};
                    pointer-events: none;
                    z-index: 3;
                  `;
                  grid.appendChild(betweenGlowLine);
                }

                // Create horizontal glow line to the right of the row (right gap)
                const rightGlowLine = document.createElement('div');
                rightGlowLine.className = 'line-preview-glow-row';
                rightGlowLine.style.cssText = `
                  position: absolute;
                  left: ${lastRect.right - gridRect.left + (glowThickness - gapSize) / 2}px;
                  top: ${firstRect.top - gridRect.top}px;
                  width: ${glowThickness}px;
                  height: ${firstRect.height}px;
                  background: linear-gradient(0deg, 
                    transparent 0%, 
                    ${particleColorRgba.replace('0.8', '0.3')} 10%,
                    ${particleColorRgba.replace('0.8', '0.8')} 20%,
                    ${particleColorRgba} 30%,
                    ${particleColorRgba} 70%,
                    ${particleColorRgba.replace('0.8', '0.8')} 80%,
                    ${particleColorRgba.replace('0.8', '0.3')} 90%,
                    transparent 100%
                  );
                  box-shadow: 
                    0 0 ${gapSize * 2}px ${glowColor1},
                    0 0 ${gapSize * 4}px ${color},
                    inset 0 0 ${gapSize * 3}px ${particleColorRgba};
                  pointer-events: none;
                  z-index: 3;
                `;
                grid.appendChild(rightGlowLine);

                // Create horizontal glow line below the row (bottom gap)
                const bottomGlowLine = document.createElement('div');
                bottomGlowLine.className = 'line-preview-glow-row';
                bottomGlowLine.style.cssText = `
                  position: absolute;
                  left: ${firstRect.left - gridRect.left}px;
                  top: ${firstRect.bottom - gridRect.top + (glowThickness - gapSize) / 2}px;
                  width: ${lastRect.right - firstRect.left}px;
                  height: ${glowThickness}px;
                  background: linear-gradient(90deg, 
                    transparent 0%, 
                    ${particleColorRgba.replace('0.8', '0.3')} 10%,
                    ${particleColorRgba.replace('0.8', '0.8')} 20%,
                    ${particleColorRgba} 30%,
                    ${particleColorRgba} 70%,
                    ${particleColorRgba.replace('0.8', '0.8')} 80%,
                    ${particleColorRgba.replace('0.8', '0.3')} 90%,
                    transparent 100%
                  );
                  box-shadow: 
                    0 0 ${gapSize * 2}px ${glowColor1},
                    0 0 ${gapSize * 4}px ${color},
                    inset 0 0 ${gapSize * 3}px ${particleColorRgba};
                  pointer-events: none;
                  z-index: 3;
                `;
                grid.appendChild(bottomGlowLine);

                // NOW change ALL cells to block color (only after glow lines are created)
                rowCells.forEach(cell => {
                  cell.style.setProperty('background', color, 'important');
                  cell.style.setProperty('background-color', color, 'important');
                  cell.style.transition = 'background 0.2s ease-out, background-color 0.2s ease-out';
                });
              }
            });

            // Highlight completed cols - create glow lines in gaps between cells
            completedCols.forEach(col => {
              const colCells = [];
              for (let row = 0; row < 10; row++) {
                if (!completedRows.includes(row)) {
                  const cellIndex = row * 10 + col;
                  const cell = cells[cellIndex];
                  if (cell) {
                    cell.classList.add("line-preview-complete");
                    colCells.push(cell);
                  }
                }
              }

              // Create glow lines in the gaps between cells (vertical line)
              if (colCells.length > 0) {
                const firstCell = colCells[0];
                const lastCell = colCells[colCells.length - 1];
                const firstRect = firstCell.getBoundingClientRect();
                const lastRect = lastCell.getBoundingClientRect();
                const gridRect = grid.getBoundingClientRect();
                const cellSize = firstRect.height;
                const gapSize = 2; // Grid gap is 2px
                const glowThickness = 6; // Glow line thickness is 6px

                const glowColors = ['#ff0080', '#00ff80', '#0080ff', '#ff8000', '#8000ff', '#ffff00'];
                const glowColor1 = glowColors[col % glowColors.length];
                const glowColor2 = glowColors[(col + 1) % glowColors.length];

                // Parse color to RGB for particles
                const hexToRgb = (hex) => {
                  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                  return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                  } : { r: 255, g: 255, b: 255 };
                };
                const particleColor = hexToRgb(glowColor1);
                const particleColorRgba = `rgba(${particleColor.r}, ${particleColor.g}, ${particleColor.b}, 0.8)`;

                // Create vertical glow line above the column (top gap)
                const topGlowLine = document.createElement('div');
                topGlowLine.className = 'line-preview-glow-col';
                topGlowLine.style.cssText = `
                  position: absolute;
                  left: ${firstRect.left - gridRect.left}px;
                  top: ${firstRect.top - gridRect.top - gapSize - (glowThickness - gapSize) / 2}px;
                  width: ${firstRect.width}px;
                  height: ${glowThickness}px;
                  background: linear-gradient(90deg, 
                    transparent 0%, 
                    ${particleColorRgba.replace('0.8', '0.3')} 10%,
                    ${particleColorRgba.replace('0.8', '0.8')} 20%,
                    ${particleColorRgba} 30%,
                    ${particleColorRgba} 70%,
                    ${particleColorRgba.replace('0.8', '0.8')} 80%,
                    ${particleColorRgba.replace('0.8', '0.3')} 90%,
                    transparent 100%
                  );
                  box-shadow: 
                    0 0 ${gapSize * 2}px ${glowColor1},
                    0 0 ${gapSize * 4}px ${color},
                    inset 0 0 ${gapSize * 3}px ${particleColorRgba};
                  pointer-events: none;
                  z-index: 3;
                `;
                grid.style.position = 'relative';
                grid.appendChild(topGlowLine);

                // Create vertical glow line to the left of the column (left gap)
                const leftGlowLine = document.createElement('div');
                leftGlowLine.className = 'line-preview-glow-col';
                leftGlowLine.style.cssText = `
                  position: absolute;
                  left: ${firstRect.left - gridRect.left - gapSize - (glowThickness - gapSize) / 2}px;
                  top: ${firstRect.top - gridRect.top}px;
                  width: ${glowThickness}px;
                  height: ${lastRect.bottom - firstRect.top}px;
                  background: linear-gradient(0deg, 
                    transparent 0%, 
                    ${particleColorRgba.replace('0.8', '0.3')} 10%,
                    ${particleColorRgba.replace('0.8', '0.8')} 20%,
                    ${particleColorRgba} 30%,
                    ${particleColorRgba} 70%,
                    ${particleColorRgba.replace('0.8', '0.8')} 80%,
                    ${particleColorRgba.replace('0.8', '0.3')} 90%,
                    transparent 100%
                  );
                  box-shadow: 
                    0 0 ${gapSize * 2}px ${glowColor1},
                    0 0 ${gapSize * 4}px ${color},
                    inset 0 0 ${gapSize * 3}px ${particleColorRgba};
                  pointer-events: none;
                  z-index: 3;
                `;
                grid.appendChild(leftGlowLine);

                // Create vertical glow lines between each cell in the column
                for (let i = 0; i < colCells.length - 1; i++) {
                  const cell1 = colCells[i];
                  const cell2 = colCells[i + 1];
                  const cell1Rect = cell1.getBoundingClientRect();

                  const betweenGlowLine = document.createElement('div');
                  betweenGlowLine.className = 'line-preview-glow-col';
                  betweenGlowLine.style.cssText = `
                    position: absolute;
                    left: ${firstRect.left - gridRect.left}px;
                    top: ${cell1Rect.bottom - gridRect.top - (glowThickness - gapSize) / 2}px;
                    width: ${firstRect.width}px;
                    height: ${glowThickness}px;
                    background: linear-gradient(90deg, 
                      transparent 0%, 
                      ${particleColorRgba.replace('0.8', '0.3')} 10%,
                      ${particleColorRgba.replace('0.8', '0.8')} 20%,
                      ${particleColorRgba} 30%,
                      ${particleColorRgba} 70%,
                      ${particleColorRgba.replace('0.8', '0.8')} 80%,
                      ${particleColorRgba.replace('0.8', '0.3')} 90%,
                      transparent 100%
                    );
                    box-shadow: 
                      0 0 ${gapSize * 2}px ${glowColor1},
                      0 0 ${gapSize * 4}px ${color},
                      inset 0 0 ${gapSize * 3}px ${particleColorRgba};
                    pointer-events: none;
                    z-index: 3;
                  `;
                  grid.appendChild(betweenGlowLine);
                }

                // Create vertical glow line to the right of the column (right gap)
                const rightGlowLine = document.createElement('div');
                rightGlowLine.className = 'line-preview-glow-col';
                rightGlowLine.style.cssText = `
                  position: absolute;
                  left: ${firstRect.right - gridRect.left + (glowThickness - gapSize) / 2}px;
                  top: ${firstRect.top - gridRect.top}px;
                  width: ${glowThickness}px;
                  height: ${lastRect.bottom - firstRect.top}px;
                  background: linear-gradient(0deg, 
                    transparent 0%, 
                    ${particleColorRgba.replace('0.8', '0.3')} 10%,
                    ${particleColorRgba.replace('0.8', '0.8')} 20%,
                    ${particleColorRgba} 30%,
                    ${particleColorRgba} 70%,
                    ${particleColorRgba.replace('0.8', '0.8')} 80%,
                    ${particleColorRgba.replace('0.8', '0.3')} 90%,
                    transparent 100%
                  );
                  box-shadow: 
                    0 0 ${gapSize * 2}px ${glowColor1},
                    0 0 ${gapSize * 4}px ${color},
                    inset 0 0 ${gapSize * 3}px ${particleColorRgba};
                  pointer-events: none;
                  z-index: 3;
                `;
                grid.appendChild(rightGlowLine);

                // Create vertical glow line below the column (bottom gap)
                const bottomGlowLine = document.createElement('div');
                bottomGlowLine.className = 'line-preview-glow-col';
                bottomGlowLine.style.cssText = `
                  position: absolute;
                  left: ${firstRect.left - gridRect.left}px;
                  top: ${lastRect.bottom - gridRect.top + (glowThickness - gapSize) / 2}px;
                  width: ${firstRect.width}px;
                  height: ${glowThickness}px;
                  background: linear-gradient(90deg, 
                    transparent 0%, 
                    ${particleColorRgba.replace('0.8', '0.3')} 10%,
                    ${particleColorRgba.replace('0.8', '0.8')} 20%,
                    ${particleColorRgba} 30%,
                    ${particleColorRgba} 70%,
                    ${particleColorRgba.replace('0.8', '0.8')} 80%,
                    ${particleColorRgba.replace('0.8', '0.3')} 90%,
                    transparent 100%
                  );
                  box-shadow: 
                    0 0 ${gapSize * 2}px ${glowColor1},
                    0 0 ${gapSize * 4}px ${color},
                    inset 0 0 ${gapSize * 3}px ${particleColorRgba};
                  pointer-events: none;
                  z-index: 3;
                `;
                grid.appendChild(bottomGlowLine);

                // NOW change ALL cells to block color (only after glow lines are created)
                colCells.forEach(cell => {
                  cell.style.setProperty('background', color, 'important');
                  cell.style.setProperty('background-color', color, 'important');
                  cell.style.transition = 'background 0.2s ease-out, background-color 0.2s ease-out';
                });
              }
            });
          }
        }
      }

      function updateInvalidPiecesTimed() {
        document.querySelectorAll("#piecesTimed .piece").forEach((piece, idx) => {
          const obj = currentThreeTimed[idx];
          if (!obj) return;
          let canPlaceAnywhere = false;

          // Check placement without pause check (for visual feedback only)
          for (let r = 0; r < 10 && !canPlaceAnywhere; r++) {
            for (let c = 0; c < 10 && !canPlaceAnywhere; c++) {
              // Direct board check without pause validation
              const shape = obj.shape;
              const rows = shape.length;
              const cols = shape[0].length;
              if (r >= 0 && c >= 0 && r + rows <= 10 && c + cols <= 10) {
                let canPlace = true;
                for (let i = 0; i < rows && canPlace; i++) {
                  for (let j = 0; j < cols && canPlace; j++) {
                    if (shape[i][j] && boardTimed[r + i][c + j]) {
                      canPlace = false;
                    }
                  }
                }
                if (canPlace) canPlaceAnywhere = true;
              }
            }
          }

          if (canPlaceAnywhere) {
            piece.classList.remove("invalid");
          } else {
            piece.classList.add("invalid");
          }
        });
      }
      function drawPiecesTimed() {
        const wrap = document.getElementById("piecesTimed");
        wrap.innerHTML = "";
        currentThreeTimed.forEach((obj, idx) => {
          const piece = document.createElement("div");
          piece.className = "piece";

          // Create inner container for the actual shape
          const pieceInner = document.createElement("div");
          pieceInner.className = "piece-inner";
          const rows = obj.shape.length, cols = obj.shape[0].length;
          pieceInner.style.gridTemplateColumns = `repeat(${cols}, var(--piece-block-size) )`;
          pieceInner.style.gridTemplateRows = `repeat(${rows}, var(--piece-block-size) )`;

          obj.shape.flat().forEach(val => {
            const b = document.createElement("div");
            if (val) {
              b.className = "block";
              b.style.backgroundColor = obj.color;  // Use backgroundColor to preserve gradient overlay
            }
            else { b.style.background = "transparent"; }
            pieceInner.appendChild(b);
          });

          piece.appendChild(pieceInner);

          // Drag functionality - single piece moves with cursor
          let isDragging = false;
          let dragMoveHandler, dragEndHandler;
          let rafIdTimed = null; // For requestAnimationFrame throttling
          let originalParent = null; // Store original parent for placeholder removal

          const startDrag = (e) => {
            e.preventDefault();

            // Check if game is paused - don't allow dragging
            if (isManuallyPaused) {
              console.log("⏸️ Timed game is paused - drag blocked");
              return;
            }

            // Also check if pause overlay is visible
            const pauseOverlay = document.getElementById("pauseOverlayTimed");
            if (pauseOverlay && pauseOverlay.style.display !== "none") {
              console.log("⏸️ Timed pause overlay visible - drag blocked");
              return;
            }

            isDragging = true;
            selectedTimed = obj;
            selectedIdxTimed = idx;

            // Play drag sound
            playSound('drag');

            // Mark piece as dragging and hide original position
            document.querySelectorAll("#piecesTimed .piece").forEach(p => {
              p.classList.remove("selected", "dragging");
            });
            piece.classList.add("dragging");

            // Store original parent for later restoration
            originalParent = piece.parentElement;

            // Create invisible placeholder to maintain space (prevents duplicate appearance)
            const placeholder = document.createElement('div');
            placeholder.className = 'drag-placeholder';
            placeholder.style.width = piece.offsetWidth + 'px';
            placeholder.style.height = piece.offsetHeight + 'px';
            placeholder.style.visibility = 'hidden';
            placeholder.style.pointerEvents = 'none';
            placeholder.style.display = 'inline-block';

            // CRITICAL: Move piece to body FIRST (this removes it from original parent)
            // Insert placeholder before removing piece
            originalParent.insertBefore(placeholder, piece);
            document.body.appendChild(piece);

            // Now piece is in body, set pointer events
            piece.style.pointerEvents = 'none';

            // Update piece-inner grid to use grid cell size
            const pieceInnerElem = piece.querySelector('.piece-inner');
            const rows = obj.shape.length;
            const cols = obj.shape[0].length;
            pieceInnerElem.style.gridTemplateColumns = `repeat(${cols}, var(--cell-size))`;
            pieceInnerElem.style.gridTemplateRows = `repeat(${rows}, var(--cell-size))`;

            // Use CSS transform for better mobile performance and stability
            piece.style.position = 'fixed';
            piece.style.willChange = 'transform';
            piece.style.left = '0';
            piece.style.top = '0';
            piece.style.margin = '0';

            // Get piece dimensions after resizing
            const rect = piece.getBoundingClientRect();
            const offsetX = rect.width / 2;

            // Offset: 125px above finger to prevent finger from covering block
            const verticalOffset = -125;

            // Position piece above cursor using transform for smooth, stable movement
            const x = e.clientX || (e.touches && e.touches[0].clientX);
            const y = e.clientY || (e.touches && e.touches[0].clientY);
            piece.style.transform = `translate3d(${x - offsetX}px, ${y + verticalOffset}px, 0)`;

            // Add move and end handlers
            dragMoveHandler = (e) => moveDrag(e, offsetX, verticalOffset);
            dragEndHandler = (e) => endDrag(e, verticalOffset);

            document.addEventListener("mousemove", dragMoveHandler);
            document.addEventListener("mouseup", dragEndHandler);
            document.addEventListener("touchmove", dragMoveHandler, { passive: false });
            document.addEventListener("touchend", dragEndHandler);
          };

          // Cache for performance optimization
          let cachedGridRectTimed = null;
          let cachedCellSizeTimed = null;
          let lastPreviewRowTimed = -1;
          let lastPreviewColTimed = -1;
          let lastPreviewUpdateTimed = 0;
          const PREVIEW_THROTTLE_TIMED = deviceInfo.isLowRefreshRate ? 32 : 16; // 32ms for 60Hz, 16ms for 120Hz

          const moveDrag = (e, offsetX, verticalOffset) => {
            if (!isDragging || !selectedTimed) return;

            e.preventDefault();

            const x = e.clientX || (e.touches && e.touches[0].clientX);
            const y = e.clientY || (e.touches && e.touches[0].clientY);

            // OPTIMIZATION: Use 2D transforms for Android 13 and below (faster on 60Hz devices)
            if (deviceInfo.use2DTransforms) {
              piece.style.transform = `translate(${x - offsetX}px, ${y + verticalOffset}px)`;
            } else {
              piece.style.transform = `translate3d(${x - offsetX}px, ${y + verticalOffset}px, 0)`;
            }

            // NO PREVIEW - Dragged piece itself is the preview (prevents duplicate blocks)
            // This eliminates z-index conflicts and stuck blocks
          };

          const endDrag = (e, verticalOffset) => {
            isDragging = false;

            // Check if game is paused - don't allow piece placement
            if (isManuallyPaused) {
              console.log("⏸️ Timed game is paused - piece placement blocked");
              // Reset piece position
              piece.classList.remove("dragging");
              piece.style.position = "";
              piece.style.left = "";
              piece.style.top = "";
              piece.style.willChange = 'auto';
              return;
            }

            // Remove CSS optimization hints
            piece.style.willChange = 'auto';

            const x = e.clientX || e.changedTouches?.[0]?.clientX;
            const y = e.clientY || e.changedTouches?.[0]?.clientY;

            let piecePlaced = false;

            // Check if dropped on grid and place the piece
            if (x && y) {
              const gridElem = document.getElementById("gridTimed");
              const gridRect = gridElem.getBoundingClientRect();

              // Use piece's center position for placement calculation (same as preview)
              const pieceRect = piece.getBoundingClientRect();
              const pieceCenterX = pieceRect.left + pieceRect.width / 2;
              const pieceCenterY = pieceRect.top + pieceRect.height / 2;

              if (pieceCenterX >= gridRect.left && pieceCenterX <= gridRect.right &&
                pieceCenterY >= gridRect.top && pieceCenterY <= gridRect.bottom) {
                const cellSize = gridRect.width / 10;
                const rows = selectedTimed.shape.length;
                const cols = selectedTimed.shape[0].length;

                // Use exact center calculation for precise placement
                const centerOffsetRow = rows / 2;
                const centerOffsetCol = cols / 2;

                // Round to nearest cell for exact center placement
                const col = Math.round((pieceCenterX - gridRect.left) / cellSize - centerOffsetCol);
                const row = Math.round((pieceCenterY - gridRect.top) / cellSize - centerOffsetRow);

                if (canPlaceTimed(row, col, selectedTimed)) {
                  // INSTANT PLACEMENT - All critical operations synchronously
                  pushUndo("timed");

                  // Record user activity for timer
                  recordUserActivity('timed');

                  // Apply piece to board immediately
                  applyTimed(row, col, selectedTimed);

                  // Update score instantly
                  let filledCells = 0;
                  for (let i = 0; i < selectedTimed.shape.length; i++) {
                    for (let j = 0; j < selectedTimed.shape[i].length; j++) {
                      if (selectedTimed.shape[i][j]) filledCells++;
                    }
                  }
                  scoreTimed += filledCells * 10;
                  document.getElementById("scoreTimed").textContent = "Score: " + scoreTimed;

                  // Check and clear lines BEFORE drawing (prevents duplicate blocks)
                  checkAndClearTimed();

                  // Draw grid immediately (after line clear)
                  drawGridTimed();

                  // CRITICAL: Remove placeholder BEFORE generating new piece
                  const placeholderTimed = originalParent.querySelector('.drag-placeholder');
                  if (placeholderTimed) {
                    placeholderTimed.remove();
                  }

                  // Generate new piece immediately
                  currentThreeTimed[selectedIdxTimed] = randomShape();
                  selectedTimed = null;
                  selectedIdxTimed = null;
                  drawPiecesTimed();
                  updateInvalidPiecesTimed();

                  piecePlaced = true;

                  // Check if no moves available after piece placement
                  if (checkNoMovesTimed()) {
                    console.log("No moves available - triggering timed game over");
                    setTimeout(() => {
                      handleNoMovesTimed();
                    }, 100); // Small delay to ensure UI is updated
                  }

                  // Save game state IMMEDIATELY to localStorage (synchronous)
                  saveTimedGameState();

                  // Non-critical operations run async (no blocking)
                  setTimeout(() => {
                    showPointsPopup('#gridTimed', filledCells * 10);
                    playSound('place');
                    checkRealtimeAchievements('timed');
                    // Also save to general game state key for compatibility
                    saveGameState();
                  }, 0);
                } else {
                  // If placement failed, still remove placeholder
                  const placeholderTimed = originalParent.querySelector('.drag-placeholder');
                  if (placeholderTimed) {
                    placeholderTimed.remove();
                  }
                }
              }
            }

            // Reset piece position and remove dragging class
            piece.classList.remove("dragging");
            piece.style.position = "";
            piece.style.left = "";
            piece.style.top = "";
            piece.style.transform = "";
            piece.style.willChange = 'auto';
            piece.style.display = "";
            piece.style.opacity = "";
            piece.style.pointerEvents = "";

            // Clear cached values
            cachedGridRectTimed = null;
            cachedCellSizeTimed = null;
            lastPreviewRowTimed = -1;
            lastPreviewColTimed = -1;

            // Only move piece back if it wasn't placed
            if (!piecePlaced) {
              // Reset piece-inner grid template back to original size
              const pieceInnerElem = piece.querySelector('.piece-inner');
              if (pieceInnerElem && selectedTimed) {
                const rows = selectedTimed.shape.length;
                const cols = selectedTimed.shape[0].length;
                pieceInnerElem.style.gridTemplateColumns = `repeat(${cols}, var(--piece-block-size))`;
                pieceInnerElem.style.gridTemplateRows = `repeat(${rows}, var(--piece-block-size))`;
              }
              wrap.appendChild(piece);
            } else {
              // Remove the piece element if it was placed
              piece.remove();
            }

            // Remove event listeners
            document.removeEventListener("mousemove", dragMoveHandler);
            document.removeEventListener("mouseup", dragEndHandler);
            document.removeEventListener("touchmove", dragMoveHandler, { passive: false });
            document.removeEventListener("touchend", dragEndHandler);
          };

          // Mouse events
          piece.onmousedown = startDrag;

          // Touch events - Android 13 compatible (only one handler to prevent duplicate)
          piece.addEventListener('touchstart', (e) => {
            e.preventDefault();
            e.stopPropagation();
            startDrag(e);
          }, { passive: false, capture: true });

          wrap.appendChild(piece);
        });
        updateInvalidPiecesTimed();
      }
      function canPlaceTimed(r, c, obj) {
        // Check if game is paused - don't allow placement
        if (isManuallyPaused) {
          console.log("⏸️ Timed game is paused - placement blocked in canPlaceTimed");
          return false;
        }

        // Also check if pause overlay is visible
        const pauseOverlay = document.getElementById("pauseOverlayTimed");
        if (pauseOverlay && pauseOverlay.style.display !== "none") {
          console.log("⏸️ Timed pause overlay visible - placement blocked");
          return false;
        }

        const shape = obj.shape; const rows = shape.length; const cols = shape[0].length;
        if (r < 0 || c < 0 || r + rows > 10 || c + cols > 10) return false;
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < cols; j++) {
            if (shape[i][j] && boardTimed[r + i][c + j]) return false;
          }
        }
        return true;
      }
      function applyTimed(r, c, obj) {
        const { shape, color } = obj;
        lastPlacedColorTimed = color; // Track last placed color for clearing animation

        // Apply block to board
        for (let i = 0; i < shape.length; i++) {
          for (let j = 0; j < shape[i].length; j++) {
            if (shape[i][j]) boardTimed[r + i][c + j] = { color };
          }
        }
      }
      function checkNoMovesTimed() {
        // If game is manually paused, being restored, or just drawing, don't check for game over
        if (isManuallyPaused || isGameRestoring || isDrawingOnly || gameOverGloballyDisabled) {
          console.log("Skipping game over check - manuallyPaused:", isManuallyPaused, "restoring:", isGameRestoring, "drawingOnly:", isDrawingOnly, "globallyDisabled:", gameOverGloballyDisabled);
          return false;
        }

        console.log("Checking for available moves in Timed mode...");
        for (const obj of currentThreeTimed) {
          for (let r = 0; r < 10; r++) {
            for (let c = 0; c < 10; c++) {
              if (canPlaceTimed(r, c, obj)) {
                console.log("Found valid move for Timed piece");
                return false;
              }
            }
          }
        }
        console.log("❌ No moves available in Timed mode!");
        return true;
      }
      function checkAndClearTimed() {
        // Determine which rows and cols are full first
        const rowsToClear = [];
        const colsToClear = [];

        for (let r = 0; r < 10; r++) {
          if (boardTimed[r].every(x => x !== null)) rowsToClear.push(r);
        }

        for (let c = 0; c < 10; c++) {
          let full = true;
          for (let r = 0; r < 10; r++) { if (boardTimed[r][c] === null) { full = false; break; } }
          if (full) colsToClear.push(c);
        }

        // If nothing to clear, exit
        if (rowsToClear.length === 0 && colsToClear.length === 0) {
          return;
        }

        // Collect bonus seconds from cells being cleared
        let totalBonusSeconds = 0;
        rowsToClear.forEach(r => {
          for (let c = 0; c < 10; c++) {
            const data = boardTimed[r][c];
            if (data && data.isBonus && data.bonusSeconds) {
              totalBonusSeconds += data.bonusSeconds;
            }
          }
        });
        colsToClear.forEach(c => {
          for (let r = 0; r < 10; r++) {
            const data = boardTimed[r][c];
            if (data && data.isBonus && data.bonusSeconds) {
              // Check if not already counted (from row)
              if (!rowsToClear.includes(r)) {
                totalBonusSeconds += data.bonusSeconds;
              }
            }
          }
        });

        // Add bonus time to timer
        if (totalBonusSeconds > 0) {
          timer += totalBonusSeconds;
          extraTimeEarnedInGame += totalBonusSeconds; // Track extra time earned
          document.getElementById("timerDisplay").textContent = "Time: " + timer;

          // Play bonus sound
          playSound('bonus');

          // Show bonus time notification
          const bonusNotif = document.createElement("div");
          bonusNotif.textContent = `+${totalBonusSeconds}s`;
          bonusNotif.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            color: #1f2937;
            font-size: 2rem;
            font-weight: bold;
            padding: 1rem 2rem;
            border-radius: 1rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            z-index: 1000;
            animation: bonusPulse 1s ease-out;
          `;
          document.body.appendChild(bonusNotif);
          setTimeout(() => bonusNotif.remove(), 1000);
        }

        // Collect cells to animate butterflies BEFORE clearing
        const cellsToAnimate = [];
        rowsToClear.forEach(r => {
          for (let c = 0; c < 10; c++) {
            cellsToAnimate.push({ row: r, col: c, type: 'row' });
          }
        });
        colsToClear.forEach(c => {
          for (let r = 0; r < 10; r++) {
            if (!rowsToClear.includes(r)) {
              cellsToAnimate.push({ row: r, col: c, type: 'col' });
            }
          }
        });

        // GLOW EFFECT AND COLOR CHANGE: Show glow and change color BEFORE clearing
        const grid = document.getElementById('gridTimed');
        const boardFrame = grid.parentElement; // Get boardFrame parent to append glow lines
        const cells = document.querySelectorAll("#gridTimed .cell");
        const color = lastPlacedColorTimed || '#ff0080'; // Use last placed color or default

        // Helper function to convert hex to RGB
        const hexToRgb = (hex) => {
          const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
          return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
          } : { r: 255, g: 255, b: 255 };
        };

        const gapSize = 2; // Grid gap is 2px
        const glowThickness = 6; // Glow line thickness is 6px
        const gridRect = grid.getBoundingClientRect();
        const boardFrameRect = boardFrame.getBoundingClientRect();

        // Highlight completed rows with glow and color change
        rowsToClear.forEach(row => {
          const rowCells = [];
          for (let col = 0; col < 10; col++) {
            const cellIndex = row * 10 + col;
            const cell = cells[cellIndex];
            if (cell) {
              cell.classList.add("line-preview-complete");
              // INSTANT COLOR CHANGE: Change cell color to last placed color
              cell.style.background = color;
              cell.style.backgroundColor = color;
              cell.style.transition = 'none';
              rowCells.push(cell);
            }
          }

          // Create glow lines around the row
          if (rowCells.length > 0) {
            const firstCell = rowCells[0];
            const lastCell = rowCells[rowCells.length - 1];
            const firstRect = firstCell.getBoundingClientRect();
            const lastRect = lastCell.getBoundingClientRect();

            const glowColors = ['#ff0080', '#00ff80', '#0080ff', '#ff8000', '#8000ff', '#ffff00'];
            const glowColor1 = glowColors[row % glowColors.length];
            const particleColor = hexToRgb(glowColor1);
            const particleColorRgba = `rgba(${particleColor.r}, ${particleColor.g}, ${particleColor.b}, 0.8)`;

            // Create horizontal glow line above the row (append to boardFrame to survive grid.innerHTML = "")
            const topGlowLine = document.createElement('div');
            topGlowLine.className = 'line-preview-glow-row';
            topGlowLine.style.cssText = `
              position: absolute;
              left: ${firstRect.left - boardFrameRect.left}px;
              top: ${firstRect.top - boardFrameRect.top - gapSize - (glowThickness - gapSize) / 2}px;
              width: ${lastRect.right - firstRect.left}px;
              height: ${glowThickness}px;
              background: linear-gradient(90deg, 
                transparent 0%, 
                ${particleColorRgba.replace('0.8', '0.3')} 10%,
                ${particleColorRgba.replace('0.8', '0.8')} 20%,
                ${particleColorRgba} 30%,
                ${particleColorRgba} 70%,
                ${particleColorRgba.replace('0.8', '0.8')} 80%,
                ${particleColorRgba.replace('0.8', '0.3')} 90%,
                transparent 100%
              );
              box-shadow: 
                0 0 ${gapSize * 2}px ${glowColor1},
                0 0 ${gapSize * 4}px ${color},
                inset 0 0 ${gapSize * 3}px ${particleColorRgba};
              pointer-events: none;
              z-index: 3;
            `;
            boardFrame.style.position = 'relative';
            boardFrame.appendChild(topGlowLine);

            // Auto-remove glow line after animation
            setTimeout(() => {
              if (topGlowLine.parentNode) {
                topGlowLine.remove();
              }
            }, 300);

            // Create horizontal glow line below the row
            const bottomGlowLine = document.createElement('div');
            bottomGlowLine.className = 'line-preview-glow-row';
            bottomGlowLine.style.cssText = `
              position: absolute;
              left: ${firstRect.left - boardFrameRect.left}px;
              top: ${firstRect.bottom - boardFrameRect.top + (glowThickness - gapSize) / 2}px;
              width: ${lastRect.right - firstRect.left}px;
              height: ${glowThickness}px;
              background: linear-gradient(90deg, 
                transparent 0%, 
                ${particleColorRgba.replace('0.8', '0.3')} 10%,
                ${particleColorRgba.replace('0.8', '0.8')} 20%,
                ${particleColorRgba} 30%,
                ${particleColorRgba} 70%,
                ${particleColorRgba.replace('0.8', '0.8')} 80%,
                ${particleColorRgba.replace('0.8', '0.3')} 90%,
                transparent 100%
              );
              box-shadow: 
                0 0 ${gapSize * 2}px ${glowColor1},
                0 0 ${gapSize * 4}px ${color},
                inset 0 0 ${gapSize * 3}px ${particleColorRgba};
              pointer-events: none;
              z-index: 3;
            `;
            boardFrame.appendChild(bottomGlowLine);

            // Auto-remove glow line after animation
            setTimeout(() => {
              if (bottomGlowLine.parentNode) {
                bottomGlowLine.remove();
              }
            }, 300);
          }
        });

        // Highlight completed cols with glow and color change
        colsToClear.forEach(col => {
          const colCells = [];
          for (let row = 0; row < 10; row++) {
            if (!rowsToClear.includes(row)) {
              const cellIndex = row * 10 + col;
              const cell = cells[cellIndex];
              if (cell) {
                cell.classList.add("line-preview-complete");
                // INSTANT COLOR CHANGE: Change cell color to last placed color
                cell.style.background = color;
                cell.style.backgroundColor = color;
                cell.style.transition = 'none';
                colCells.push(cell);
              }
            }
          }

          // Create glow lines around the column
          if (colCells.length > 0) {
            const firstCell = colCells[0];
            const lastCell = colCells[colCells.length - 1];
            const firstRect = firstCell.getBoundingClientRect();
            const lastRect = lastCell.getBoundingClientRect();

            const glowColors = ['#ff0080', '#00ff80', '#0080ff', '#ff8000', '#8000ff', '#ffff00'];
            const glowColor1 = glowColors[col % glowColors.length];
            const particleColor = hexToRgb(glowColor1);
            const particleColorRgba = `rgba(${particleColor.r}, ${particleColor.g}, ${particleColor.b}, 0.8)`;

            // Create vertical glow line to the left of the column (append to boardFrame)
            const leftGlowLine = document.createElement('div');
            leftGlowLine.className = 'line-preview-glow-col';
            leftGlowLine.style.cssText = `
              position: absolute;
              left: ${firstRect.left - boardFrameRect.left - gapSize - (glowThickness - gapSize) / 2}px;
              top: ${firstRect.top - boardFrameRect.top}px;
              width: ${glowThickness}px;
              height: ${lastRect.bottom - firstRect.top}px;
              background: linear-gradient(0deg, 
                transparent 0%, 
                ${particleColorRgba.replace('0.8', '0.3')} 10%,
                ${particleColorRgba.replace('0.8', '0.8')} 20%,
                ${particleColorRgba} 30%,
                ${particleColorRgba} 70%,
                ${particleColorRgba.replace('0.8', '0.8')} 80%,
                ${particleColorRgba.replace('0.8', '0.3')} 90%,
                transparent 100%
              );
              box-shadow: 
                0 0 ${gapSize * 2}px ${glowColor1},
                0 0 ${gapSize * 4}px ${color},
                inset 0 0 ${gapSize * 3}px ${particleColorRgba};
              pointer-events: none;
              z-index: 3;
            `;
            boardFrame.appendChild(leftGlowLine);

            // Auto-remove glow line after animation
            setTimeout(() => {
              if (leftGlowLine.parentNode) {
                leftGlowLine.remove();
              }
            }, 300);

            // Create vertical glow line to the right of the column
            const rightGlowLine = document.createElement('div');
            rightGlowLine.className = 'line-preview-glow-col';
            rightGlowLine.style.cssText = `
              position: absolute;
              left: ${lastRect.right - boardFrameRect.left + (glowThickness - gapSize) / 2}px;
              top: ${firstRect.top - boardFrameRect.top}px;
              width: ${glowThickness}px;
              height: ${lastRect.bottom - firstRect.top}px;
              background: linear-gradient(0deg, 
                transparent 0%, 
                ${particleColorRgba.replace('0.8', '0.3')} 10%,
                ${particleColorRgba.replace('0.8', '0.8')} 20%,
                ${particleColorRgba} 30%,
                ${particleColorRgba} 70%,
                ${particleColorRgba.replace('0.8', '0.8')} 80%,
                ${particleColorRgba.replace('0.8', '0.3')} 90%,
                transparent 100%
              );
              box-shadow: 
                0 0 ${gapSize * 2}px ${glowColor1},
                0 0 ${gapSize * 4}px ${color},
                inset 0 0 ${gapSize * 3}px ${particleColorRgba};
              pointer-events: none;
              z-index: 3;
            `;
            boardFrame.appendChild(rightGlowLine);

            // Auto-remove glow line after animation
            setTimeout(() => {
              if (rightGlowLine.parentNode) {
                rightGlowLine.remove();
              }
            }, 300);
          }
        });

        // Simply clear the board cells - no animations or effects
        rowsToClear.forEach(r => {
          for (let c = 0; c < 10; c++) {
            boardTimed[r][c] = null;
          }
        });

        colsToClear.forEach(c => {
          for (let r = 0; r < 10; r++) {
            if (!rowsToClear.includes(r)) {
              boardTimed[r][c] = null;
            }
          }
        });

        // DON'T redraw here - will be drawn after this function returns
        // drawGridTimed(); // REMOVED - causes duplicate blocks

        // Create butterfly animations in background (non-blocking)
        if (cellsToAnimate.length > 0) {
          const grid = document.getElementById('gridTimed');
          const gridRect = grid.getBoundingClientRect();
          const cellSize = gridRect.width / 10;

          // Animation directions: up, down, left, right, diagonal
          const directions = ['up', 'down', 'left', 'right', 'diagonal'];

          // 10 different hue-rotate values for butterflies (to change actual color)
          const butterflyHues = [
            0,      // Original (pink/red)
            60,     // Yellow
            120,    // Green
            180,    // Cyan
            240,    // Blue
            300,    // Magenta
            30,     // Orange
            150,    // Light Green
            270,    // Purple
            90      // Yellow-Green
          ];

          cellsToAnimate.forEach((cell, index) => {
            const cellElement = grid.querySelector(`.cell[data-row="${cell.row}"][data-col="${cell.col}"]`);
            if (!cellElement) return;

            const cellRect = cellElement.getBoundingClientRect();
            const direction = directions[index % directions.length];
            const hue = butterflyHues[index % butterflyHues.length];

            // Create butterfly overlay
            const butterfly = document.createElement('div');
            butterfly.textContent = '🦋';
            butterfly.style.cssText = `
              position: fixed;
              left: ${cellRect.left + cellRect.width / 2}px;
              top: ${cellRect.top + cellRect.height / 2}px;
              font-size: 1.5rem;
              pointer-events: none;
              z-index: 1000;
              transform: translate(-50%, -50%);
              filter: hue-rotate(${hue}deg) saturate(1.2) brightness(1.1);
            `;

            // Set animation based on direction
            let animationName = 'butterflyFlyUp';
            if (direction === 'down') animationName = 'butterflyFlyDown';
            else if (direction === 'left') animationName = 'butterflyFlyLeft';
            else if (direction === 'right') animationName = 'butterflyFlyRight';
            else if (direction === 'diagonal') animationName = 'butterflyFlyDiagonal';

            butterfly.style.animation = `${animationName} 2s ease-out forwards`;
            document.body.appendChild(butterfly);

            // Remove butterfly after animation
            setTimeout(() => {
              if (butterfly.parentNode) {
                butterfly.remove();
              }
            }, 2000);
          });
        }

        const horizontalLines = rowsToClear.length;
        const verticalLines = colsToClear.length;

        // Play sound based on total lines cleared
        const totalLines = horizontalLines + verticalLines;
        if (totalLines > 0) {
          playSound('clear' + Math.min(totalLines, 6));

          // Check for combo (consecutive clears within time window)
          const now = Date.now();
          const timeSinceLastClear = now - lastClearTimeTimed;
          console.log(`⏱️ Timed: Time since last clear: ${timeSinceLastClear}ms (window: ${COMBO_TIME_WINDOW}ms)`);

          if (timeSinceLastClear <= COMBO_TIME_WINDOW && timeSinceLastClear > 0) {
            comboCountTimed++;
            console.log(`🎯 TIMED COMBO DETECTED! Count: ${comboCountTimed}`);

            // Calculate and add combo points
            const comboPoints = calculateComboPoints(comboCountTimed);
            scoreTimed += comboPoints;
            document.getElementById("scoreTimed").textContent = "Score: " + scoreTimed;

            showComboPopup('timed', comboCountTimed, comboPoints);

            // Play combo voice sound for specific combo counts
            playComboVoice(comboCountTimed);
          } else {
            console.log(`❌ No combo - resetting counter`);
            comboCountTimed = 0; // Reset combo
          }
          lastClearTimeTimed = now;
        }

        let linePoints = 0;

        // Award points for horizontal lines (if any)
        if (horizontalLines === 1) {
          linePoints += 10;
        } else if (horizontalLines === 2) {
          linePoints += 30;
        } else if (horizontalLines === 3) {
          linePoints += 50;
        } else if (horizontalLines === 4) {
          linePoints += 70;
        } else if (horizontalLines === 5) {
          linePoints += 100;
        } else if (horizontalLines >= 6) {
          linePoints += 150;
        }

        // Award points for vertical lines (if any)
        if (verticalLines === 1) {
          linePoints += 10;
        } else if (verticalLines === 2) {
          linePoints += 30;
        } else if (verticalLines === 3) {
          linePoints += 50;
        } else if (verticalLines === 4) {
          linePoints += 70;
        } else if (verticalLines === 5) {
          linePoints += 100;
        } else if (verticalLines >= 6) {
          linePoints += 150;
        }

        // Extra cross bonus if both horizontal AND vertical lines cleared
        if (horizontalLines > 0 && verticalLines > 0) {
          const totalLines = horizontalLines + verticalLines;
          if (totalLines === 2) {
            linePoints += 20;  // 1H + 1V
          } else if (totalLines === 3) {
            linePoints += 40;  // 2H + 1V or 1H + 2V
          } else if (totalLines === 4) {
            linePoints += 80;  // 2H + 2V or 3H + 1V or 1H + 3V
          } else if (totalLines === 5) {
            linePoints += 160; // Various combinations
          } else if (totalLines >= 6) {
            linePoints += 320; // 3H + 3V or more
          }
        }

        // Show points popup
        showPointsPopup('#gridTimed', linePoints);

        // Update total lines counters for achievement tracking (horizontal + vertical)
        const linesClearedTimed = horizontalLines + verticalLines;
        if (linesClearedTimed > 0) {
          totalLinesTimed += linesClearedTimed;
        }

        scoreTimed += linePoints;

        // Check for real-time achievements after line clear
        checkRealtimeAchievements('timed');
      }

      document.getElementById("pauseTimedBtn").onclick = () => {
        // Pause game play timer when pausing game
        pauseGamePlayTimer('timed');

        isManuallyPaused = true; // Set flag for manual pause
        pausedTimed = {
          score: scoreTimed,
          board: JSON.parse(JSON.stringify(boardTimed)),
          currentThree: JSON.parse(JSON.stringify(currentThreeTimed)),
          selectedIdx: selectedIdxTimed,
          timer: timer
        };
        clearInterval(timerInterval);
        clearInterval(bonusCellInterval);
        // stop recharge while paused
        stopUndoRecharge("timed");
        // Pause music when game is paused
        pauseMusicAndEffects();
        if (typeof timer === 'number' && timer <= 0) {
          timer = 1;
          document.getElementById("timerDisplay").textContent = "Time: " + timer;
        }
        document.getElementById("pauseOverlayTimed").style.display = "block";
        showPausePopup('timed');
      };
      document.getElementById("resumeTimedBtn").onclick = () => {
        // Resume game play timer when resuming game
        resumeGamePlayTimer('timed');
        isManuallyPaused = false; // Reset flag when resuming
        clearManualPauseStatus(); // Clear saved status when resuming
        document.getElementById("pauseOverlayTimed").style.display = "none";
        hidePausePopup('timed'); // Hide the small popup too

        // Re-enable game over ONLY on explicit resume
        gameOverGloballyDisabled = false;
        console.log("✅ Game over ENABLED after Timed resume");

        // Restart timer interval
        clearInterval(timerInterval);
        timerInterval = setInterval(() => {
          timer--;
          document.getElementById("timerDisplay").textContent = "Time: " + timer;
          if (timer <= 0) {
            clearInterval(timerInterval);
            clearInterval(bonusCellInterval);
            const overlayVisible = document.getElementById("pauseOverlayTimed").style.display === "block";
            if (!overlayVisible && !isManuallyPaused && !isGameRestoring && !isDrawingOnly && !gameOverGloballyDisabled) {
              handleNoMovesTimed();
            } else {
              console.log("Timer expired (resume path) but not active gameplay - blocking game over. overlayVisible:", overlayVisible);
            }
          }
        }, 1000);

        // Restart bonus cell interval (every 60s)
        clearInterval(bonusCellInterval);
        bonusCellInterval = setInterval(() => {
          placeBonusCells();
        }, 60000);

        // resume undo recharge
        startUndoRecharge("timed");

        // Update music button state
        updateMusicButtonState();
      };

      // Restart button for pause overlay Timed
      const restartPauseOverlayTimedBtn = document.getElementById("restartPauseOverlayTimedBtn");
      if (restartPauseOverlayTimedBtn) {
        restartPauseOverlayTimedBtn.onclick = async (e) => {
          e.preventDefault();
          // Hide the pause overlay
          document.getElementById("pauseOverlayTimed").style.display = "none";
          hidePausePopup('timed');
          // Reset pause flags
          isManuallyPaused = false;
          clearManualPauseStatus();
          // Start a new timed game
          await startTimedGame();
        };
      }

      // Support Resume from the small pause-popup (e.g., "You switched tabs" message)
      const pausePopupTimedResumeBtn = document.getElementById("pausePopupTimedResume");
      if (pausePopupTimedResumeBtn) {
        pausePopupTimedResumeBtn.onclick = (e) => {
          e.preventDefault();
          // Trigger the main resume handler
          const resumeBtn = document.getElementById("resumeTimedBtn");
          if (resumeBtn) resumeBtn.click();
        };
      }

      // Support Restart from the small pause-popup for Timed
      const pausePopupTimedRestartBtn = document.getElementById("pausePopupTimedRestart");
      if (pausePopupTimedRestartBtn) {
        pausePopupTimedRestartBtn.onclick = async (e) => {
          e.preventDefault();
          // Hide the pause popup
          hidePausePopup('timed');
          // Start a new timed game
          await startTimedGame();
        };
      }

      document.getElementById("goHomeTimedBtn").onclick = async () => {
        // Show loading when returning to home
        showLoadingPopup('Saving game...');

        // Pause game play timer when leaving game
        pauseGamePlayTimer('timed');

        // Auto-pause current game before leaving
        autoPauseCurrentGame();

        // Disable achievement tracking when leaving game
        isGameActive = false;

        // End game session and save total time
        endGameSession();

        // stop recharge when leaving to home (credits remain)
        stopUndoRecharge("timed");
        stopMusic();

        // Save user data if logged in
        if (currentFirebaseUser && isUserDataLoaded) {
          try {
            showLoadingPopup('Syncing data...');
            await saveUserDataToFirebase(currentFirebaseUser.uid);
          } catch (error) {
            console.error('Error saving data on home:', error);
          }
        }

        // Hide loading
        hideLoadingPopup();

        popFromNavigationStack();
        transitionToScreen('timedContainer', 'homeScreen');
        clearInterval(timerInterval);
        clearInterval(bonusCellInterval);
        hidePausePopup('timed');

        // ===== UPDATE UI WHEN RETURNING TO HOME =====
        updateUIWithUserData();
        console.log("UI updated when returning to home from timed");
      };
      document.getElementById("restartTimedBtn").onclick = async () => {
        await startTimedGame();
      };

      // Music toggle button for Timed mode
      // Music toggle button for Timed mode (now controls both music and sound effects)
      document.getElementById("musicToggleTimedBtn").onclick = () => {
        try {
          if (currentBgMusic) {
            if (currentBgMusic.paused) {
              // Enable both music and sound effects
              currentBgMusic.play().catch(e => {
                if (e && e.message && typeof e.message === 'string' && e.message.includes('interrupted') && e.message.includes('pause')) return;
                console.warn('Music play failed (if 403: Firebase Storage rules must allow public read):', e.message || e);
              });
              soundEffectsEnabled = true;
            } else {
              // Disable both music and sound effects
              currentBgMusic.pause();
              soundEffectsEnabled = false;
            }
            updateMusicButtonState();
          } else {
            // If no music is loaded, just toggle sound effects
            soundEffectsEnabled = !soundEffectsEnabled;
            updateMusicButtonState();
          }
        } catch (error) {
          console.error("Error in music toggle:", error);
        }
      };
      document.getElementById("goHomeTimedOverBtn").onclick = () => {
        // Pause game play timer when leaving game
        pauseGamePlayTimer('timed');
        // Clear game state since game is over
        clearGameState();

        // Disable achievement tracking when leaving game
        isGameActive = false;

        // Reset legitimate game over flag
        isLegitimateGameOver = false;

        // End game session and save total time
        endGameSession();

        document.getElementById("gameOverTimed").style.display = "none";
        transitionToScreen('timedContainer', 'homeScreen');
        clearInterval(timerInterval);
        clearInterval(bonusCellInterval);
        hidePausePopup('timed');

        // ===== UPDATE UI WHEN RETURNING TO HOME =====
        updateUIWithUserData();
        console.log("UI updated when returning to home from timed game over");
      };

      /* Game Over Timed */
      async function handleNoMovesTimed() {
        console.log("=== handleNoMovesTimed called ===");
        hidePausePopup('timed');

        // Overlay visible? then not a true game over.
        const overlay = document.getElementById('pauseOverlayTimed');
        const overlayVisible = overlay && overlay.style.display === 'block';
        if (overlayVisible) {
          console.log('🚫 Pause overlay still visible - aborting game over');
          return;
        }

        // Globally disabled? abort.
        if (gameOverGloballyDisabled) {
          console.log('🚫 Global disable active - aborting timed game over');
          return;
        }

        // Restoration or drawing phase – abort.
        if (isGameRestoring || isDrawingOnly) {
          console.log('🚫 Restoring/drawing phase - aborting timed game over');
          return;
        }

        // Manual pause? abort (should not happen if overlay hidden already).
        if (isManuallyPaused) {
          console.log('🚫 Manually paused flag still true - aborting timed game over');
          return;
        }

        // Reset all blocking flags before showing game over
        isManuallyPaused = false;
        isGameRestoring = false;
        isDrawingOnly = false;
        gameOverGloballyDisabled = false;
        isLegitimateGameOver = true; // Mark as legitimate game over

        // Play board clear animation before showing game over
        await playBoardClearAnimation('timed');

        // FORCE HIDE pause overlay before showing game over
        document.getElementById("pauseOverlayTimed").style.display = "none";

        // Clear state & disable gameplay tracking
        clearTimedGameState();
        pausedTimed = null;
        isGameActive = false;

        // Pause music when game over popup is shown
        pauseMusicAndEffects();
        if (currentBgMusic && currentBgMusic.paused) {
          console.log("🔇 Music paused - game over popup shown");
        }

        playSound('gameover');
        clearInterval(timerInterval);
        clearInterval(bonusCellInterval);
        const highscore = updateHighscore("timed", scoreTimed);
        document.getElementById("finalScoreTimed").textContent = "Final Score: " + scoreTimed;

        // stop recharge when game over
        stopUndoRecharge("timed");

        // Pause game play timer when game over
        pauseGamePlayTimer('timed');

        showGameOverPopup('timed');
      }

      document.getElementById("toggleLangBtn").onclick = () => {
        currentLang = currentLang === "gu" ? "en" : "gu";
        // reflect in user settings if available
        if (userData && userData.settings) {
          userData.settings.language = currentLang;
          saveLocalUserData();
        }
        SafeStorage.setItem('blockPuzzleLang', currentLang);
        updateLanguageUI();
      };

      updateLanguageUI();

      // Start home page timer update interval
      startHomePageTimerUpdate();

    }); // End DOMContentLoaded
  </script>
  <!-- SEO Content Section - Hidden from game UI, visible to search engines -->
  <!-- ===================================================================== -->
  <!-- SEO ARTICLE SECTION                                                    -->
  <!-- Accessible to search engines but hidden visually                       -->
  <!-- ===================================================================== -->
  <div aria-hidden="true" class="seo-content-wrapper">
    <section class="seo-content-inner">

      <h1>Block Puzzle Free Butterfly – Play Online</h1>

      <p>
        Block Puzzle Free Butterfly is a relaxing and addictive brain puzzle game designed for players who love logic
        challenges and colorful gameplay. This online puzzle game combines classic block mechanics with beautiful
        butterfly-themed graphics, making it perfect for both kids and adults.
      </p>

      <h2>How to Play Block Puzzle Free Butterfly</h2>

      <p>
        The goal of the game is simple: drag and drop butterfly blocks onto the board and complete full rows or columns
        to clear them. Once a line is filled completely, it disappears and gives you points. The more lines you clear at
        once, the higher your score will be.
      </p>

      <p>
        There is no time limit, so you can play at your own pace. However, you must think carefully before placing each
        block because the game ends when there is no more space left on the board.
      </p>

      <h2>Why You Will Love This Puzzle Game</h2>

      <ul>
        <li>Beautiful butterfly-themed graphics</li>
        <li>Relaxing yet challenging gameplay</li>
        <li>No time limit – play at your own speed</li>
        <li>Improves logical thinking and concentration</li>
        <li>Free to play online without download</li>
      </ul>

      <h2>Play Online for Free</h2>

      <p>
        You can enjoy Block Puzzle Free Butterfly directly in your browser without installing anything. If you prefer
        playing on your mobile device, you can also download the Android version from Google Play Store.
      </p>

      <p>
        Start playing now and challenge yourself to beat your highest score in this fun and addictive block puzzle game!
      </p>

    </section>
  </div>
  <!-- ===================================================================== -->
  <!-- END SEO CONTENT SECTION                                                -->
  <!-- ===================================================================== -->

</body>


</html>


